<p>We use a "breadth-first search" to find the path with the least number of steps. A breadth-first search works like this. We have a stack, and put the starting number on the stack. Then we loop: in the loop, we remove the number on the top of the stack. If that number is the ending number, we exit the loop; otherwise, add all the possible numbers that we can go to from that one to the stack (except the numbers that we've already put on the stack). For each number, we record what number we came from to get to it.</p>

<p>When we finish, we have the ending number, and the number that came before it, and the number that came before that, and so on. This gives us the path, but backwards. So we simply put the path into an array or list, and read the answer off backwards.</p>

<p>To determine which numbers we can visit, we need a list of prime numbers. There are many ways to do this, but since there aren't strict time constraints, we can use a very simple one. To check if a number is prime, just loop through all the numbers between 2 and it, and check if the original number is divisible by that number. If it is divisible by any of the numbers besides itself, then it is not prime.</p>
