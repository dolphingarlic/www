<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>Hardware interrupts</title>
<link rel="stylesheet" href="../fpdoc.css" type="text/css">

</head>
<body>
<table class="bar" width="100%" border="0" cellpadding="4" cellspacing="0">
<tr>
<td><b>[<a href="../go32/softwareinterrupts.html">Previous</a>][<a href="../go32/index.html">Up</a>][<a href="../go32/disablinginterrupts.html">Next</a>]</b></td>
<td align="right"><span class="bartitle">Reference for unit 'go32' (<a href="../index.html">#rtl</a>)</span></td>
</tr>
</table>
<h2>Hardware interrupts</h2>
<p>Hardware interrupts are generated by hardware devices when something unusual happens; this could be a keypress or a mouse move or any other action. This is done to minimize CPU time, else the CPU would have to check all installed hardware for data in a big loop (this method is called 'polling') and this would take much time. A standard IBM-PC has two interrupt controllers, that are responsible for these hardware interrupts: both allow up to 8 different interrupt sources (IRQs, interrupt requests). The second controller is connected to the first through IRQ 2 for compatibility reasons, e.g. if controller 1 gets an IRQ 2, he hands the IRQ over to controller 2. Because of this up to 15 different hardware interrupt sources can be handled. IRQ 0 through IRQ 7 are mapped to interrupts 8h to Fh and the second controller (IRQ 8 to 15) is mapped to interrupt 70h to 77h. All of the code and data touched by these handlers MUST be locked (via the various locking functions) to avoid page faults at interrupt time. Because hardware interrupts are called (as in real mode) with interrupts disabled, the handler has to enable them before it returns to normal program execution. Additionally a hardware interrupt must send an EOI (end of interrupt) command to the responsible controller; this is acomplished by sending the value 20h to port 20h (for the first controller) or A0h (for the second controller). The following example shows how to redirect the keyboard interrupt. </p>
<h2>Example</h2>
<pre><span class="cmt">{ This example demonstrates how to chain to a hardware interrupt.</span>
<span class="cmt"></span>
<span class="cmt">In more detail, it hooks the keyboard interrupt, calls a user</span>
<span class="cmt">procedure which in this case simply turns the PC speaker on and off.</span>
<span class="cmt">Then the old interrupt is called.</span>
<span class="cmt">}</span>

<span class="dir">{$ASMMODE ATT}</span>
<span class="dir">{$MODE FPC}</span>

<span class="kw">uses</span>
        crt<span class="sym">,</span>
        go32<span class="sym">;</span>

<span class="kw">const</span>
        <span class="cmt">{ keyboard is IRQ 1 -&gt; interrupt 9 }</span>
        kbdint <span class="sym">=</span> <span class="num">$9</span><span class="sym">;</span>

<span class="kw">var</span>
        <span class="cmt">{ holds old PM interrupt handler address }</span>
        oldint9_handler <span class="sym">:</span> tseginfo<span class="sym">;</span>
        <span class="cmt">{ new PM interrupt handler }</span>
        newint9_handler <span class="sym">:</span> tseginfo<span class="sym">;</span>

        <span class="cmt">{ pointer to interrupt handler }</span>
        clickproc <span class="sym">:</span> pointer<span class="sym">;</span>
        <span class="cmt">{ the data segment selector }</span>
        backupDS <span class="sym">:</span> Word<span class="sym">;</span> external name <span class="str">'___v2prt0_ds_alias'</span><span class="sym">;</span>

<span class="cmt">{ interrupt handler }</span>
<span class="kw">procedure</span> int9_handler<span class="sym">;</span> <span class="kw">assembler</span><span class="sym">;</span>
<span class="kw">asm</span><span class="asm"></span>
<span class="asm">        cli</span>
<span class="asm">        </span><span class="cmt">{ save all registers, because we don't know which the compiler</span>
<span class="cmt">        uses for the called procedure }</span><span class="asm"></span>
<span class="asm">        pushl %ds</span>
<span class="asm">        pushl %es</span>
<span class="asm">        pushl %fs</span>
<span class="asm">        pushl %gs</span>
<span class="asm">        pushal</span>
<span class="asm">        </span><span class="cmt">{ set up to call a FPC procedure }</span>
<span class="asm">        movw %cs:backupDS, %ax</span>
<span class="asm">        movw %ax, %ds</span>
<span class="asm">        movw %ax, %es</span>
<span class="asm">        movw dosmemselector, %ax</span>
<span class="asm">        movw %ax, %fs</span>
<span class="asm">        </span><span class="cmt">{ call user procedure }</span>
<span class="asm">        call *clickproc</span>
<span class="asm">        </span><span class="cmt">{ restore all registers }</span>
<span class="asm">        popal</span>
<span class="asm">        popl %gs</span>
<span class="asm">        popl %fs</span>
<span class="asm">        popl %es</span>
<span class="asm">        popl %ds</span>
<span class="asm">        </span><span class="cmt">{ note: in go32v2 mode %cs=%ds=%es !!!}</span>
<span class="asm">        ljmp %cs:oldint9_handler </span><span class="cmt">{ call old handler }</span>
<span class="asm">        </span><span class="cmt">{ we don't need to do anything more, because the old interrupt</span>
<span class="cmt">        handler does this for us (send EOI command, iret, sti...) }</span><span class="asm"></span>
<span class="kw">end</span><span class="sym">;</span>
<span class="cmt">{ dummy procedure to retrieve exact length of handler, for locking</span>
<span class="cmt">and unlocking functions  }</span>
<span class="kw">procedure</span> int9_dummy<span class="sym">;</span> <span class="kw">begin</span> <span class="kw">end</span><span class="sym">;</span>

<span class="cmt">{ demo user procedure, simply clicks on every keypress }</span>
<span class="kw">procedure</span> clicker<span class="sym">;</span>
<span class="kw">begin</span>
        sound<span class="sym">(</span><span class="num">500</span><span class="sym">)</span><span class="sym">;</span> delay<span class="sym">(</span><span class="num">10</span><span class="sym">)</span><span class="sym">;</span> nosound<span class="sym">;</span>
<span class="kw">end</span><span class="sym">;</span>
<span class="cmt">{ dummy procedure to retrieve exact length of user procedure for</span>
<span class="cmt">locking and unlocking functions }</span>
<span class="kw">procedure</span> clicker_dummy<span class="sym">;</span> <span class="kw">begin</span> <span class="kw">end</span><span class="sym">;</span>

<span class="cmt">{ installs our new handler }</span>
<span class="kw">procedure</span> install_click<span class="sym">;</span>
<span class="kw">begin</span>
        clickproc <span class="sym">:=</span> <span class="sym">@</span>clicker<span class="sym">;</span>
        <span class="cmt">{ lock used code and data }</span>
        lock_data<span class="sym">(</span>clickproc<span class="sym">,</span> sizeof<span class="sym">(</span>clickproc<span class="sym">)</span><span class="sym">)</span><span class="sym">;</span>
        lock_data<span class="sym">(</span>dosmemselector<span class="sym">,</span> sizeof<span class="sym">(</span>dosmemselector<span class="sym">)</span><span class="sym">)</span><span class="sym">;</span>

        lock_code<span class="sym">(</span><span class="sym">@</span>clicker<span class="sym">,</span>
                longint<span class="sym">(</span><span class="sym">@</span>clicker_dummy<span class="sym">)</span> <span class="sym">-</span> longint<span class="sym">(</span><span class="sym">@</span>clicker<span class="sym">)</span><span class="sym">)</span><span class="sym">;</span>
        lock_code<span class="sym">(</span><span class="sym">@</span>int9_handler<span class="sym">,</span>
                longint<span class="sym">(</span><span class="sym">@</span>int9_dummy<span class="sym">)</span><span class="sym">-</span>longint<span class="sym">(</span><span class="sym">@</span>int9_handler<span class="sym">)</span><span class="sym">)</span><span class="sym">;</span>
        <span class="cmt">{ fill in new handler's 48 bit pointer }</span>
        newint9_handler<span class="sym">.</span>offset <span class="sym">:=</span> <span class="sym">@</span>int9_handler<span class="sym">;</span>
        newint9_handler<span class="sym">.</span>segment <span class="sym">:=</span> get_cs<span class="sym">;</span>
        <span class="cmt">{ get old PM interrupt handler }</span>
        get_pm_interrupt<span class="sym">(</span>kbdint<span class="sym">,</span> oldint9_handler<span class="sym">)</span><span class="sym">;</span>
        <span class="cmt">{ set the new interrupt handler }</span>
        <span class="kw">set</span>_pm_interrupt<span class="sym">(</span>kbdint<span class="sym">,</span> newint9_handler<span class="sym">)</span><span class="sym">;</span>
<span class="kw">end</span><span class="sym">;</span>

<span class="cmt">{ deinstalls our interrupt handler }</span>
<span class="kw">procedure</span> remove_click<span class="sym">;</span>
<span class="kw">begin</span>
        <span class="cmt">{ set old handler }</span>
        <span class="kw">set</span>_pm_interrupt<span class="sym">(</span>kbdint<span class="sym">,</span> oldint9_handler<span class="sym">)</span><span class="sym">;</span>
        <span class="cmt">{ unlock used code &amp; data }</span>
        unlock_data<span class="sym">(</span>dosmemselector<span class="sym">,</span> sizeof<span class="sym">(</span>dosmemselector<span class="sym">)</span><span class="sym">)</span><span class="sym">;</span>
        unlock_data<span class="sym">(</span>clickproc<span class="sym">,</span> sizeof<span class="sym">(</span>clickproc<span class="sym">)</span><span class="sym">)</span><span class="sym">;</span>

        unlock_code<span class="sym">(</span><span class="sym">@</span>clicker<span class="sym">,</span>
                longint<span class="sym">(</span><span class="sym">@</span>clicker_dummy<span class="sym">)</span><span class="sym">-</span>longint<span class="sym">(</span><span class="sym">@</span>clicker<span class="sym">)</span><span class="sym">)</span><span class="sym">;</span>
        unlock_code<span class="sym">(</span><span class="sym">@</span>int9_handler<span class="sym">,</span>
                longint<span class="sym">(</span><span class="sym">@</span>int9_dummy<span class="sym">)</span><span class="sym">-</span>longint<span class="sym">(</span><span class="sym">@</span>int9_handler<span class="sym">)</span><span class="sym">)</span><span class="sym">;</span>
<span class="kw">end</span><span class="sym">;</span>

<span class="kw">var</span>
        ch <span class="sym">:</span> char<span class="sym">;</span>

<span class="kw">begin</span>
        install_click<span class="sym">;</span>
        Writeln<span class="sym">(</span><span class="str">'Enter any message. Press return when finished'</span><span class="sym">)</span><span class="sym">;</span>
        <span class="kw">while</span> <span class="sym">(</span>ch <span class="sym">&lt;</span><span class="sym">&gt;</span> <span class="chr">#13</span><span class="sym">)</span> <span class="kw">do</span> <span class="kw">begin</span>
                ch <span class="sym">:=</span> readkey<span class="sym">;</span> write<span class="sym">(</span>ch<span class="sym">)</span><span class="sym">;</span>
        <span class="kw">end</span><span class="sym">;</span>
        remove_click<span class="sym">;</span>
<span class="kw">end</span><span class="sym">.</span>
</pre>
<hr>

<span class="footer">Documentation generated on: Sep 28 2017</span>
</body>
</html>
