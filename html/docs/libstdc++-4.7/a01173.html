<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libstdc++: functional File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a01173.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">functional File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="a01173_source.html">Go to the source code of this file.</a></p>
<h2><a name="nested-classes"></a>
Classes</h2>
<ul>
<li>struct <a class="el" href="a00470.html">std::__is_location_invariant&lt; _Tp &gt;</a>
<li>struct <a class="el" href="a00489.html">std::_Derives_from_binary_function&lt; _Tp &gt;</a>
<dl class="el"><dd class="mdescRight">Determines if the type _Tp derives from <a class="el" href="a00428.html">binary_function</a>.  <a href="a00489.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00490.html">std::_Derives_from_unary_function&lt; _Tp &gt;</a>
<dl class="el"><dd class="mdescRight">Determines if the type _Tp derives from <a class="el" href="a00920.html">unary_function</a>.  <a href="a00490.html#details">More...</a><br/></dl><li>class <a class="el" href="a00491.html">std::_Function_base</a>
<dl class="el"><dd class="mdescRight">Base class of all polymorphic function object wrappers.  <a href="a00491.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00411.html">std::_Maybe_get_result_type&lt; _Has_result_type, _Functor &gt;</a>
<dl class="el"><dd class="mdescRight">If we have found a result_type, extract it.  <a href="a00411.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00412.html">std::_Maybe_unary_or_binary_function&lt; _Res, _ArgTypes &gt;</a>
<li>struct <a class="el" href="a00500.html">std::_Maybe_unary_or_binary_function&lt; _Res, _T1 &gt;</a>
<dl class="el"><dd class="mdescRight">Derives from <code><a class="el" href="a00920.html">unary_function</a></code>, as appropriate.  <a href="a00500.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00501.html">std::_Maybe_unary_or_binary_function&lt; _Res, _T1, _T2 &gt;</a>
<dl class="el"><dd class="mdescRight">Derives from <code><a class="el" href="a00428.html">binary_function</a></code>, as appropriate.  <a href="a00501.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00502.html">std::_Maybe_wrap_member_pointer&lt; _Tp &gt;</a>
<li>struct <a class="el" href="a00503.html">std::_Maybe_wrap_member_pointer&lt; _Tp _Class::* &gt;</a>
<li>class <a class="el" href="a00504.html">std::_Mem_fn&lt; _Res(_Class::*)(_ArgTypes...) const  &gt;</a>
<dl class="el"><dd class="mdescRight">Implementation of <code>mem_fn</code> for const member function pointers.  <a href="a00504.html#details">More...</a><br/></dl><li>class <a class="el" href="a00505.html">std::_Mem_fn&lt; _Res(_Class::*)(_ArgTypes...) const volatile &gt;</a>
<dl class="el"><dd class="mdescRight">Implementation of <code>mem_fn</code> for const volatile member function pointers.  <a href="a00505.html#details">More...</a><br/></dl><li>class <a class="el" href="a00506.html">std::_Mem_fn&lt; _Res(_Class::*)(_ArgTypes...) volatile &gt;</a>
<dl class="el"><dd class="mdescRight">Implementation of <code>mem_fn</code> for volatile member function pointers.  <a href="a00506.html#details">More...</a><br/></dl><li>class <a class="el" href="a00507.html">std::_Mem_fn&lt; _Res(_Class::*)(_ArgTypes...)&gt;</a>
<dl class="el"><dd class="mdescRight">Implementation of <code>mem_fn</code> for member function pointers.  <a href="a00507.html#details">More...</a><br/></dl><li>class <a class="el" href="a00508.html">std::_Mu&lt; _Arg, false, false &gt;</a>
<li>class <a class="el" href="a00509.html">std::_Mu&lt; _Arg, false, true &gt;</a>
<li>class <a class="el" href="a00510.html">std::_Mu&lt; _Arg, true, false &gt;</a>
<li>class <a class="el" href="a00511.html">std::_Mu&lt; reference_wrapper&lt; _Tp &gt;, false, false &gt;</a>
<li>struct <a class="el" href="a00512.html">std::_Placeholder&lt; _Num &gt;</a>
<dl class="el"><dd class="mdescRight">The type of placeholder objects defined by libstdc++.  <a href="a00512.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00413.html">std::_Reference_wrapper_base&lt; _Tp &gt;</a>
<li>struct <a class="el" href="a00513.html">std::_Safe_tuple_element&lt; __i, _Tuple &gt;</a>
<li>struct <a class="el" href="a00414.html">std::_Safe_tuple_element_impl&lt; __i, _Tuple, _IsSafe &gt;</a>
<li>struct <a class="el" href="a00514.html">std::_Safe_tuple_element_impl&lt; __i, _Tuple, false &gt;</a>
<li>struct <a class="el" href="a00416.html">std::_Weak_result_type&lt; _Functor &gt;</a>
<li>struct <a class="el" href="a00417.html">std::_Weak_result_type_impl&lt; _Functor &gt;</a>
<li>struct <a class="el" href="a00518.html">std::_Weak_result_type_impl&lt; _Res(&amp;)(_ArgTypes...)&gt;</a>
<dl class="el"><dd class="mdescRight">Retrieve the result type for a function reference.  <a href="a00518.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00519.html">std::_Weak_result_type_impl&lt; _Res(*)(_ArgTypes...)&gt;</a>
<dl class="el"><dd class="mdescRight">Retrieve the result type for a function pointer.  <a href="a00519.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00520.html">std::_Weak_result_type_impl&lt; _Res(_ArgTypes...)&gt;</a>
<dl class="el"><dd class="mdescRight">Retrieve the result type for a function type.  <a href="a00520.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00521.html">std::_Weak_result_type_impl&lt; _Res(_Class::*)(_ArgTypes...) const  &gt;</a>
<dl class="el"><dd class="mdescRight">Retrieve result type for a const member function pointer.  <a href="a00521.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00522.html">std::_Weak_result_type_impl&lt; _Res(_Class::*)(_ArgTypes...) const volatile &gt;</a>
<dl class="el"><dd class="mdescRight">Retrieve result type for a const volatile member function pointer.  <a href="a00522.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00523.html">std::_Weak_result_type_impl&lt; _Res(_Class::*)(_ArgTypes...) volatile &gt;</a>
<dl class="el"><dd class="mdescRight">Retrieve result type for a volatile member function pointer.  <a href="a00523.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00524.html">std::_Weak_result_type_impl&lt; _Res(_Class::*)(_ArgTypes...)&gt;</a>
<dl class="el"><dd class="mdescRight">Retrieve result type for a member function pointer.  <a href="a00524.html#details">More...</a><br/></dl><li>class <a class="el" href="a00561.html">std::bad_function_call</a>
<dl class="el"><dd class="mdescRight">Exception class thrown when class template function's operator() is called with an empty target.  <a href="a00561.html#details">More...</a><br/></dl><li>class <a class="el" href="a00650.html">std::function&lt; _Res(_ArgTypes...)&gt;</a>
<dl class="el"><dd class="mdescRight">Primary class template for std::function.Polymorphic function wrapper.  <a href="a00650.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00718.html">std::is_bind_expression&lt; _Tp &gt;</a>
<dl class="el"><dd class="mdescRight">Determines if the given type _Tp is a function object should be treated as a subexpression when evaluating calls to function objects returned by <a class="el" href="a01640.html#ga4c3052b337dde285bace96cbb996055c" title="Function template for std::bind.">bind()</a>. [TR1 3.6.1].  <a href="a00718.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00719.html">std::is_bind_expression&lt; _Bind&lt; _Signature &gt; &gt;</a>
<dl class="el"><dd class="mdescRight">Class template _Bind is always a bind expression.  <a href="a00719.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00720.html">std::is_bind_expression&lt; _Bind_result&lt; _Result, _Signature &gt; &gt;</a>
<dl class="el"><dd class="mdescRight">Class template _Bind_result is always a bind expression.  <a href="a00720.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00721.html">std::is_bind_expression&lt; const _Bind&lt; _Signature &gt; &gt;</a>
<dl class="el"><dd class="mdescRight">Class template _Bind is always a bind expression.  <a href="a00721.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00722.html">std::is_bind_expression&lt; const _Bind_result&lt; _Result, _Signature &gt; &gt;</a>
<dl class="el"><dd class="mdescRight">Class template _Bind_result is always a bind expression.  <a href="a00722.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00723.html">std::is_bind_expression&lt; const volatile _Bind&lt; _Signature &gt; &gt;</a>
<dl class="el"><dd class="mdescRight">Class template _Bind is always a bind expression.  <a href="a00723.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00724.html">std::is_bind_expression&lt; const volatile _Bind_result&lt; _Result, _Signature &gt; &gt;</a>
<dl class="el"><dd class="mdescRight">Class template _Bind_result is always a bind expression.  <a href="a00724.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00725.html">std::is_bind_expression&lt; volatile _Bind&lt; _Signature &gt; &gt;</a>
<dl class="el"><dd class="mdescRight">Class template _Bind is always a bind expression.  <a href="a00725.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00726.html">std::is_bind_expression&lt; volatile _Bind_result&lt; _Result, _Signature &gt; &gt;</a>
<dl class="el"><dd class="mdescRight">Class template _Bind_result is always a bind expression.  <a href="a00726.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00757.html">std::is_placeholder&lt; _Tp &gt;</a>
<dl class="el"><dd class="mdescRight">Determines if the given type _Tp is a placeholder in a <a class="el" href="a01640.html#ga4c3052b337dde285bace96cbb996055c" title="Function template for std::bind.">bind()</a> expression and, if so, which placeholder it is. [TR1 3.6.2].  <a href="a00757.html#details">More...</a><br/></dl><li>struct <a class="el" href="a00758.html">std::is_placeholder&lt; _Placeholder&lt; _Num &gt; &gt;</a>
<li>class <a class="el" href="a00876.html">std::reference_wrapper&lt; _Tp &gt;</a>
<dl class="el"><dd class="mdescRight">Primary class template for <a class="el" href="a00876.html" title="Primary class template for reference_wrapper.">reference_wrapper</a>.  <a href="a00876.html#details">More...</a><br/></dl></ul>
<h2><a name="namespaces"></a>
Namespaces</h2>
<ul>
<li>namespace <a class="el" href="a01576.html">std</a>
<li>namespace <a class="el" href="a01586.html">std::placeholders</a>
</ul>
<h2><a name="define-members"></a>
Defines</h2>
<ul>
<li><a class="anchor" id="ad969f4b8b5dae55db2256754cb3163e4"></a><!-- doxytag: member="functional::_GLIBCXX_FUNCTIONAL" ref="ad969f4b8b5dae55db2256754cb3163e4" args="" -->
#define <b>_GLIBCXX_FUNCTIONAL</b>
</ul>
<h2><a name="enum-members"></a>
Enumerations</h2>
<ul>
<li>enum <b>_Manager_operation</b> { <b>__get_type_info</b>, 
<b>__get_functor_ptr</b>, 
<b>__clone_functor</b>, 
<b>__destroy_functor</b>
 }
</ul>
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li><a class="anchor" id="a69486d46df2571f8305fb943d954415b"></a><!-- doxytag: member="functional::__bind_simple" ref="a69486d46df2571f8305fb943d954415b" args="(_Callable &amp;&amp;__callable, _Args &amp;&amp;...__args)" -->
template&lt;typename _Callable , typename... _Args&gt; _Bind_simple_helper&lt; _Callable, <br class="typebreak"/>
_Args...&gt;::__type <b>std::__bind_simple</b> (_Callable &amp;&amp;__callable, _Args &amp;&amp;...__args)
<li><a class="anchor" id="acbc4160d0f900ca49d5394f0e0a62068"></a><!-- doxytag: member="functional::__callable_functor" ref="acbc4160d0f900ca49d5394f0e0a62068" args="(_Functor &amp;__f)" -->
template&lt;typename _Functor &gt; _Functor &amp; <b>std::__callable_functor</b> (_Functor &amp;__f)
<li><a class="anchor" id="afb2f1d204c44b2699beea68fbb6081bb"></a><!-- doxytag: member="functional::__callable_functor" ref="afb2f1d204c44b2699beea68fbb6081bb" args="(_Member _Class::*&amp;__p)" -->
template&lt;typename _Member , typename _Class &gt; _Mem_fn&lt; _Member _Class::* &gt; <b>std::__callable_functor</b> (_Member _Class::*&amp;__p)
<li><a class="anchor" id="a8d8ba61d6afd15c5b198cf0b3f5d3978"></a><!-- doxytag: member="functional::__callable_functor" ref="a8d8ba61d6afd15c5b198cf0b3f5d3978" args="(_Member _Class::*const &amp;__p)" -->
template&lt;typename _Member , typename _Class &gt; _Mem_fn&lt; _Member _Class::* &gt; <b>std::__callable_functor</b> (_Member _Class::*const &amp;__p)
<li><a class="anchor" id="a22cea82228afe25e0148b2366af9133e"></a><!-- doxytag: member="functional::__volget" ref="a22cea82228afe25e0148b2366af9133e" args="(volatile tuple&lt; _Tp...&gt; &amp;__tuple)&#45;&gt; typename tuple_element&lt; _Ind" -->
template&lt;std::size_t _Ind, typename... _Tp&gt; auto <b>std::__volget</b> (volatile tuple&lt; _Tp...&gt; &amp;__tuple)-&gt; typename tuple_element&lt; _Ind
<li><a class="anchor" id="a67f8b9b0cbf5713bf495654c41e679e6"></a><!-- doxytag: member="functional::__volget" ref="a67f8b9b0cbf5713bf495654c41e679e6" args="(const volatile tuple&lt; _Tp...&gt; &amp;__tuple)&#45;&gt; typename tuple_element&lt; _Ind" -->
typename _Tp auto <b>std::__volget</b> (const volatile tuple&lt; _Tp...&gt; &amp;__tuple)-&gt; typename tuple_element&lt; _Ind
<li>template&lt;typename _Func , typename... _BoundArgs&gt; _Bind_helper&lt; __is_socketlike<br class="typebreak"/>
&lt; _Func &gt;::value, _Func, <br class="typebreak"/>
_BoundArgs...&gt;::type <a class="el" href="a01640.html#ga4c3052b337dde285bace96cbb996055c">std::bind</a> (_Func &amp;&amp;__f, _BoundArgs &amp;&amp;...__args)
<li>template&lt;typename _Result , typename _Func , typename... _BoundArgs&gt; _Bindres_helper&lt; _Result, <br class="typebreak"/>
_Func, _BoundArgs...&gt;::type <a class="el" href="a01640.html#ga771f3f4c823c6d7fe240037dfe30a7b9">std::bind</a> (_Func &amp;&amp;__f, _BoundArgs &amp;&amp;...__args)
<li>template&lt;typename _Tp , typename _Class &gt; _Mem_fn&lt; _Tp _Class::* &gt; <a class="el" href="a01629.html#ga0bbd36f0ace24ae7496a60e19ac082fd">std::mem_fn</a> (_Tp _Class::*__pm)
<li>template&lt;typename _Res , typename... _Args&gt; bool <a class="el" href="a01576.html#a48d985ba8cc72e159372b14b9114da73">std::operator!=</a> (const function&lt; _Res(_Args...)&gt; &amp;__f, nullptr_t) noexcept
<li>template&lt;typename _Res , typename... _Args&gt; bool <a class="el" href="a01576.html#ac0daaa77f5550fd185352175aa05fc89">std::operator!=</a> (nullptr_t, const function&lt; _Res(_Args...)&gt; &amp;__f) noexcept
<li>template&lt;typename _Res , typename... _Args&gt; bool <a class="el" href="a01576.html#ad2629e7ee31ca36d6d593639e698db6b">std::operator==</a> (const function&lt; _Res(_Args...)&gt; &amp;__f, nullptr_t) noexcept
<li>template&lt;typename _Res , typename... _Args&gt; bool <a class="el" href="a01576.html#a225870d9721816ebaa535af4e19d0cc1">std::operator==</a> (nullptr_t, const function&lt; _Res(_Args...)&gt; &amp;__f) noexcept
<li>template&lt;typename _Res , typename... _Args&gt; void <a class="el" href="a01576.html#aa36b65fec3dac007e5357c3fc03d0335">std::swap</a> (function&lt; _Res(_Args...)&gt; &amp;__x, function&lt; _Res(_Args...)&gt; &amp;__y)
</ul>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<ul>
<li>template&lt;typename _Tp &gt; reference_wrapper&lt; _Tp &gt; <a class="el" href="a01576.html#a1912c220e1851d8dd8484d3cb6317b33">std::ref</a> (_Tp &amp;__t) noexcept
<li>template&lt;typename _Tp &gt; reference_wrapper&lt; const _Tp &gt; <a class="el" href="a01576.html#afc6f7bb2ebc4f03c54cdf91f5ecb1f15">std::cref</a> (const _Tp &amp;__t) noexcept
<li>template&lt;typename _Tp &gt; void <a class="el" href="a01576.html#a444af9242db07977d6e1b8098ed9c97a">std::ref</a> (const _Tp &amp;&amp;)
<li>template&lt;typename _Tp &gt; void <a class="el" href="a01576.html#a71f535a244b1f3e300756009684a1a4c">std::cref</a> (const _Tp &amp;&amp;)
<li>template&lt;typename _Tp &gt; reference_wrapper&lt; _Tp &gt; <a class="el" href="a01576.html#aa6e7c9ad5dbd731664fab89868983bc8">std::ref</a> (reference_wrapper&lt; _Tp &gt; __t) noexcept
<li>template&lt;typename _Tp &gt; reference_wrapper&lt; const _Tp &gt; <a class="el" href="a01576.html#a173f93c3bca58d0411f16989cce6fedc">std::cref</a> (reference_wrapper&lt; _Tp &gt; __t) noexcept
</ul>
<h2><a name="var-members"></a>
Variables</h2>
<ul>
<li><a class="anchor" id="a2fc0f0362dcbb255851329f836dd994c"></a><!-- doxytag: member="functional::_1" ref="a2fc0f0362dcbb255851329f836dd994c" args="" -->
const _Placeholder&lt; 1 &gt; <b>std::placeholders::_1</b>
<li><a class="anchor" id="ad921f4f9c8e13568bce48d6d82155f64"></a><!-- doxytag: member="functional::_10" ref="ad921f4f9c8e13568bce48d6d82155f64" args="" -->
const _Placeholder&lt; 10 &gt; <b>std::placeholders::_10</b>
<li><a class="anchor" id="a1c865315305bf33533839e5e0c553ed5"></a><!-- doxytag: member="functional::_11" ref="a1c865315305bf33533839e5e0c553ed5" args="" -->
const _Placeholder&lt; 11 &gt; <b>std::placeholders::_11</b>
<li><a class="anchor" id="a318a322f95331f489de2d6c80b4cd36c"></a><!-- doxytag: member="functional::_12" ref="a318a322f95331f489de2d6c80b4cd36c" args="" -->
const _Placeholder&lt; 12 &gt; <b>std::placeholders::_12</b>
<li><a class="anchor" id="adea5300a700f3bb28ab2bac676f4c541"></a><!-- doxytag: member="functional::_13" ref="adea5300a700f3bb28ab2bac676f4c541" args="" -->
const _Placeholder&lt; 13 &gt; <b>std::placeholders::_13</b>
<li><a class="anchor" id="a7d4e97928e2722751bd8d54be9175305"></a><!-- doxytag: member="functional::_14" ref="a7d4e97928e2722751bd8d54be9175305" args="" -->
const _Placeholder&lt; 14 &gt; <b>std::placeholders::_14</b>
<li><a class="anchor" id="af96bac9b98759b97f4b252f5ee22a701"></a><!-- doxytag: member="functional::_15" ref="af96bac9b98759b97f4b252f5ee22a701" args="" -->
const _Placeholder&lt; 15 &gt; <b>std::placeholders::_15</b>
<li><a class="anchor" id="a34ad7a01131ddd48ffd9c9912aa7fe11"></a><!-- doxytag: member="functional::_16" ref="a34ad7a01131ddd48ffd9c9912aa7fe11" args="" -->
const _Placeholder&lt; 16 &gt; <b>std::placeholders::_16</b>
<li><a class="anchor" id="a30c7f6199cb7be8b4c84654935ec83a2"></a><!-- doxytag: member="functional::_17" ref="a30c7f6199cb7be8b4c84654935ec83a2" args="" -->
const _Placeholder&lt; 17 &gt; <b>std::placeholders::_17</b>
<li><a class="anchor" id="ad189477c04a405b70707c57f46af0e37"></a><!-- doxytag: member="functional::_18" ref="ad189477c04a405b70707c57f46af0e37" args="" -->
const _Placeholder&lt; 18 &gt; <b>std::placeholders::_18</b>
<li><a class="anchor" id="acd48341076504807f332fcd825b4ffb3"></a><!-- doxytag: member="functional::_19" ref="acd48341076504807f332fcd825b4ffb3" args="" -->
const _Placeholder&lt; 19 &gt; <b>std::placeholders::_19</b>
<li><a class="anchor" id="a55b11ed0d8a2b832618ac7aad73f76b6"></a><!-- doxytag: member="functional::_2" ref="a55b11ed0d8a2b832618ac7aad73f76b6" args="" -->
const _Placeholder&lt; 2 &gt; <b>std::placeholders::_2</b>
<li><a class="anchor" id="a7d3670a314a561d794075ec793efd183"></a><!-- doxytag: member="functional::_20" ref="a7d3670a314a561d794075ec793efd183" args="" -->
const _Placeholder&lt; 20 &gt; <b>std::placeholders::_20</b>
<li><a class="anchor" id="ab1c6202e49d25a778f96d104490b1b51"></a><!-- doxytag: member="functional::_21" ref="ab1c6202e49d25a778f96d104490b1b51" args="" -->
const _Placeholder&lt; 21 &gt; <b>std::placeholders::_21</b>
<li><a class="anchor" id="af83002c1ed35b3189d9c1bab847708ab"></a><!-- doxytag: member="functional::_22" ref="af83002c1ed35b3189d9c1bab847708ab" args="" -->
const _Placeholder&lt; 22 &gt; <b>std::placeholders::_22</b>
<li><a class="anchor" id="a742ac621c87b473d3cfd7685b9e33182"></a><!-- doxytag: member="functional::_23" ref="a742ac621c87b473d3cfd7685b9e33182" args="" -->
const _Placeholder&lt; 23 &gt; <b>std::placeholders::_23</b>
<li><a class="anchor" id="a6d1c0f76c6a82d1b56a4846079cb9810"></a><!-- doxytag: member="functional::_24" ref="a6d1c0f76c6a82d1b56a4846079cb9810" args="" -->
const _Placeholder&lt; 24 &gt; <b>std::placeholders::_24</b>
<li><a class="anchor" id="ac82c3d71c908a987c7b41b03dafcd74a"></a><!-- doxytag: member="functional::_25" ref="ac82c3d71c908a987c7b41b03dafcd74a" args="" -->
const _Placeholder&lt; 25 &gt; <b>std::placeholders::_25</b>
<li><a class="anchor" id="a57b7af87da238fcd80e82f16bc56b78b"></a><!-- doxytag: member="functional::_26" ref="a57b7af87da238fcd80e82f16bc56b78b" args="" -->
const _Placeholder&lt; 26 &gt; <b>std::placeholders::_26</b>
<li><a class="anchor" id="a77e4b3dc6551371487c8a452d515d178"></a><!-- doxytag: member="functional::_27" ref="a77e4b3dc6551371487c8a452d515d178" args="" -->
const _Placeholder&lt; 27 &gt; <b>std::placeholders::_27</b>
<li><a class="anchor" id="a7ad05d9bce90e3a594b75eb87d22bf57"></a><!-- doxytag: member="functional::_28" ref="a7ad05d9bce90e3a594b75eb87d22bf57" args="" -->
const _Placeholder&lt; 28 &gt; <b>std::placeholders::_28</b>
<li><a class="anchor" id="a00abca0c45b7b542b1fa8236551c5d30"></a><!-- doxytag: member="functional::_29" ref="a00abca0c45b7b542b1fa8236551c5d30" args="" -->
const _Placeholder&lt; 29 &gt; <b>std::placeholders::_29</b>
<li><a class="anchor" id="ac9a3670461cfa7ad937f72b49e09b7e9"></a><!-- doxytag: member="functional::_3" ref="ac9a3670461cfa7ad937f72b49e09b7e9" args="" -->
const _Placeholder&lt; 3 &gt; <b>std::placeholders::_3</b>
<li><a class="anchor" id="a14431494741a52f8d2b6fd7a9fe2c546"></a><!-- doxytag: member="functional::_4" ref="a14431494741a52f8d2b6fd7a9fe2c546" args="" -->
const _Placeholder&lt; 4 &gt; <b>std::placeholders::_4</b>
<li><a class="anchor" id="ab8a8d5d48398a435c3e12dffb23c7237"></a><!-- doxytag: member="functional::_5" ref="ab8a8d5d48398a435c3e12dffb23c7237" args="" -->
const _Placeholder&lt; 5 &gt; <b>std::placeholders::_5</b>
<li><a class="anchor" id="ada3631773f0e0252f5d9df68770fdc7e"></a><!-- doxytag: member="functional::_6" ref="ada3631773f0e0252f5d9df68770fdc7e" args="" -->
const _Placeholder&lt; 6 &gt; <b>std::placeholders::_6</b>
<li><a class="anchor" id="a8a90a0c477c3ed52c43bc5e5cc777f36"></a><!-- doxytag: member="functional::_7" ref="a8a90a0c477c3ed52c43bc5e5cc777f36" args="" -->
const _Placeholder&lt; 7 &gt; <b>std::placeholders::_7</b>
<li><a class="anchor" id="aabd4b34ab9dd748ad39a19754d359946"></a><!-- doxytag: member="functional::_8" ref="aabd4b34ab9dd748ad39a19754d359946" args="" -->
const _Placeholder&lt; 8 &gt; <b>std::placeholders::_8</b>
<li><a class="anchor" id="ab8a2cd5d26178d663e67f6bfd919c525"></a><!-- doxytag: member="functional::_9" ref="ab8a2cd5d26178d663e67f6bfd919c525" args="" -->
const _Placeholder&lt; 9 &gt; <b>std::placeholders::_9</b>
<li>enable_if&lt; (!is_member_pointer<br class="typebreak"/>
&lt; _Functor &gt;::value <br class="typebreak"/>
&amp;&amp;!is_function&lt; _Functor &gt;<br class="typebreak"/>
::value &amp;&amp;!is_function<br class="typebreak"/>
&lt; typename remove_pointer<br class="typebreak"/>
&lt; _Functor &gt;::type &gt;::value), <br class="typebreak"/>
typename result_of&lt; _Functor(_Args &amp;&amp;...)&gt;<br class="typebreak"/>
::type &gt;::type <a class="el" href="a01576.html#a8e0a457d7544b390fa7835b1696be1ed">std::__invoke</a> (_Functor &amp;__f, _Args &amp;&amp;...__args)
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This is a Standard C++ Library header. </p>

<p>Definition in file <a class="el" href="a01173_source.html">functional</a>.</p>
</div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a01173.html">functional</a>      </li>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
