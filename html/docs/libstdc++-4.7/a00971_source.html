<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libstdc++: basic_string.tcc Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00971.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">basic_string.tcc</div>  </div>
</div><!--header-->
<div class="contents">
<a href="a00971.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// Components for manipulating sequences of characters -*- C++ -*-</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="comment">// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,</span>
<a name="l00004"></a>00004 <span class="comment">// 2006, 2007, 2008, 2009, 2010, 2011</span>
<a name="l00005"></a>00005 <span class="comment">// Free Software Foundation, Inc.</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">// This file is part of the GNU ISO C++ Library.  This library is free</span>
<a name="l00008"></a>00008 <span class="comment">// software; you can redistribute it and/or modify it under the</span>
<a name="l00009"></a>00009 <span class="comment">// terms of the GNU General Public License as published by the</span>
<a name="l00010"></a>00010 <span class="comment">// Free Software Foundation; either version 3, or (at your option)</span>
<a name="l00011"></a>00011 <span class="comment">// any later version.</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
<a name="l00014"></a>00014 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00015"></a>00015 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00016"></a>00016 <span class="comment">// GNU General Public License for more details.</span>
<a name="l00017"></a>00017 
<a name="l00018"></a>00018 <span class="comment">// Under Section 7 of GPL version 3, you are granted additional</span>
<a name="l00019"></a>00019 <span class="comment">// permissions described in the GCC Runtime Library Exception, version</span>
<a name="l00020"></a>00020 <span class="comment">// 3.1, as published by the Free Software Foundation.</span>
<a name="l00021"></a>00021 
<a name="l00022"></a>00022 <span class="comment">// You should have received a copy of the GNU General Public License and</span>
<a name="l00023"></a>00023 <span class="comment">// a copy of the GCC Runtime Library Exception along with this program;</span>
<a name="l00024"></a>00024 <span class="comment">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</span>
<a name="l00025"></a>00025 <span class="comment">// &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00026"></a>00026 <span class="comment"></span>
<a name="l00027"></a>00027 <span class="comment">/** @file bits/basic_string.tcc</span>
<a name="l00028"></a>00028 <span class="comment"> *  This is an internal header file, included by other library headers.</span>
<a name="l00029"></a>00029 <span class="comment"> *  Do not attempt to use it directly. @headername{string}</span>
<a name="l00030"></a>00030 <span class="comment"> */</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="comment">//</span>
<a name="l00033"></a>00033 <span class="comment">// ISO C++ 14882: 21  Strings library</span>
<a name="l00034"></a>00034 <span class="comment">//</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="comment">// Written by Jason Merrill based upon the specification by Takanori Adachi</span>
<a name="l00037"></a>00037 <span class="comment">// in ANSI X3J16/94-0013R2.  Rewritten by Nathan Myers to ISO-14882.</span>
<a name="l00038"></a>00038 
<a name="l00039"></a>00039 <span class="preprocessor">#ifndef _BASIC_STRING_TCC</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor">#define _BASIC_STRING_TCC 1</span>
<a name="l00041"></a>00041 <span class="preprocessor"></span>
<a name="l00042"></a>00042 <span class="preprocessor">#pragma GCC system_header</span>
<a name="l00043"></a>00043 <span class="preprocessor"></span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;<a class="code" href="a01079.html">bits/cxxabi_forced.h</a>&gt;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="keyword">namespace </span>std _GLIBCXX_VISIBILITY(default)
<a name="l00047"></a>00047 {
<a name="l00048"></a>00048 _GLIBCXX_BEGIN_NAMESPACE_VERSION
<a name="l00049"></a>00049 
<a name="l00050"></a>00050   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00051"></a>00051     <span class="keyword">const</span> <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type
<a name="l00052"></a>00052     basic_string&lt;_CharT, _Traits, _Alloc&gt;::
<a name="l00053"></a>00053     _Rep::_S_max_size = (((npos - <span class="keyword">sizeof</span>(_Rep_base))/<span class="keyword">sizeof</span>(_CharT)) - 1) / 4;
<a name="l00054"></a>00054 
<a name="l00055"></a>00055   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00056"></a>00056     <span class="keyword">const</span> _CharT
<a name="l00057"></a>00057     basic_string&lt;_CharT, _Traits, _Alloc&gt;::
<a name="l00058"></a>00058     _Rep::_S_terminal = _CharT();
<a name="l00059"></a>00059 
<a name="l00060"></a>00060   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00061"></a>00061     <span class="keyword">const</span> <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type
<a name="l00062"></a>00062     basic_string&lt;_CharT, _Traits, _Alloc&gt;::npos;
<a name="l00063"></a>00063 
<a name="l00064"></a>00064   <span class="comment">// Linker sets _S_empty_rep_storage to all 0s (one reference, empty string)</span>
<a name="l00065"></a>00065   <span class="comment">// at static init time (before static ctors are run).</span>
<a name="l00066"></a>00066   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00067"></a>00067     <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type
<a name="l00068"></a>00068     basic_string&lt;_CharT, _Traits, _Alloc&gt;::_Rep::_S_empty_rep_storage[
<a name="l00069"></a>00069     (<span class="keyword">sizeof</span>(_Rep_base) + <span class="keyword">sizeof</span>(_CharT) + <span class="keyword">sizeof</span>(size_type) - 1) /
<a name="l00070"></a>00070       <span class="keyword">sizeof</span>(size_type)];
<a name="l00071"></a>00071 
<a name="l00072"></a>00072   <span class="comment">// NB: This is the special case for Input Iterators, used in</span>
<a name="l00073"></a>00073   <span class="comment">// istreambuf_iterators, etc.</span>
<a name="l00074"></a>00074   <span class="comment">// Input Iterators have a cost structure very different from</span>
<a name="l00075"></a>00075   <span class="comment">// pointers, calling for a different coding style.</span>
<a name="l00076"></a>00076   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00077"></a>00077     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InIterator&gt;
<a name="l00078"></a>00078       _CharT*
<a name="l00079"></a>00079       basic_string&lt;_CharT, _Traits, _Alloc&gt;::
<a name="l00080"></a>00080       _S_construct(_InIterator __beg, _InIterator __end, <span class="keyword">const</span> _Alloc&amp; __a,
<a name="l00081"></a>00081            input_iterator_tag)
<a name="l00082"></a>00082       {
<a name="l00083"></a>00083 <span class="preprocessor">#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0</span>
<a name="l00084"></a>00084 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (__beg == __end &amp;&amp; __a == _Alloc())
<a name="l00085"></a>00085       <span class="keywordflow">return</span> _S_empty_rep()._M_refdata();
<a name="l00086"></a>00086 <span class="preprocessor">#endif</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>    <span class="comment">// Avoid reallocation for common case.</span>
<a name="l00088"></a>00088     _CharT __buf[128];
<a name="l00089"></a>00089     size_type __len = 0;
<a name="l00090"></a>00090     <span class="keywordflow">while</span> (__beg != __end &amp;&amp; __len &lt; <span class="keyword">sizeof</span>(__buf) / <span class="keyword">sizeof</span>(_CharT))
<a name="l00091"></a>00091       {
<a name="l00092"></a>00092         __buf[__len++] = *__beg;
<a name="l00093"></a>00093         ++__beg;
<a name="l00094"></a>00094       }
<a name="l00095"></a>00095     _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
<a name="l00096"></a>00096     _M_copy(__r-&gt;_M_refdata(), __buf, __len);
<a name="l00097"></a>00097     __try
<a name="l00098"></a>00098       {
<a name="l00099"></a>00099         <span class="keywordflow">while</span> (__beg != __end)
<a name="l00100"></a>00100           {
<a name="l00101"></a>00101         <span class="keywordflow">if</span> (__len == __r-&gt;_M_capacity)
<a name="l00102"></a>00102           {
<a name="l00103"></a>00103             <span class="comment">// Allocate more space.</span>
<a name="l00104"></a>00104             _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
<a name="l00105"></a>00105             _M_copy(__another-&gt;_M_refdata(), __r-&gt;_M_refdata(), __len);
<a name="l00106"></a>00106             __r-&gt;_M_destroy(__a);
<a name="l00107"></a>00107             __r = __another;
<a name="l00108"></a>00108           }
<a name="l00109"></a>00109         __r-&gt;_M_refdata()[__len++] = *__beg;
<a name="l00110"></a>00110         ++__beg;
<a name="l00111"></a>00111           }
<a name="l00112"></a>00112       }
<a name="l00113"></a>00113     __catch(...)
<a name="l00114"></a>00114       {
<a name="l00115"></a>00115         __r-&gt;_M_destroy(__a);
<a name="l00116"></a>00116         __throw_exception_again;
<a name="l00117"></a>00117       }
<a name="l00118"></a>00118     __r-&gt;_M_set_length_and_sharable(__len);
<a name="l00119"></a>00119     <span class="keywordflow">return</span> __r-&gt;_M_refdata();
<a name="l00120"></a>00120       }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00123"></a>00123     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _InIterator&gt;
<a name="l00124"></a>00124       _CharT*
<a name="l00125"></a>00125       basic_string&lt;_CharT, _Traits, _Alloc&gt;::
<a name="l00126"></a>00126       _S_construct(_InIterator __beg, _InIterator __end, <span class="keyword">const</span> _Alloc&amp; __a,
<a name="l00127"></a>00127            forward_iterator_tag)
<a name="l00128"></a>00128       {
<a name="l00129"></a>00129 <span class="preprocessor">#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (__beg == __end &amp;&amp; __a == _Alloc())
<a name="l00131"></a>00131       <span class="keywordflow">return</span> _S_empty_rep()._M_refdata();
<a name="l00132"></a>00132 <span class="preprocessor">#endif</span>
<a name="l00133"></a>00133 <span class="preprocessor"></span>    <span class="comment">// NB: Not required, but considered best practice.</span>
<a name="l00134"></a>00134     <span class="keywordflow">if</span> (__gnu_cxx::__is_null_pointer(__beg) &amp;&amp; __beg != __end)
<a name="l00135"></a>00135       __throw_logic_error(__N(<span class="stringliteral">&quot;basic_string::_S_construct null not valid&quot;</span>));
<a name="l00136"></a>00136 
<a name="l00137"></a>00137     <span class="keyword">const</span> size_type __dnew = <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(<a class="code" href="a01576.html#a5852ded2c7147a161b33951ef37ecba8" title="A generalization of pointer arithmetic.">std::distance</a>(__beg,
<a name="l00138"></a>00138                                       __end));
<a name="l00139"></a>00139     <span class="comment">// Check for out_of_range and length_error exceptions.</span>
<a name="l00140"></a>00140     _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
<a name="l00141"></a>00141     __try
<a name="l00142"></a>00142       { _S_copy_chars(__r-&gt;_M_refdata(), __beg, __end); }
<a name="l00143"></a>00143     __catch(...)
<a name="l00144"></a>00144       {
<a name="l00145"></a>00145         __r-&gt;_M_destroy(__a);
<a name="l00146"></a>00146         __throw_exception_again;
<a name="l00147"></a>00147       }
<a name="l00148"></a>00148     __r-&gt;_M_set_length_and_sharable(__dnew);
<a name="l00149"></a>00149     <span class="keywordflow">return</span> __r-&gt;_M_refdata();
<a name="l00150"></a>00150       }
<a name="l00151"></a>00151 
<a name="l00152"></a>00152   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00153"></a>00153     _CharT*
<a name="l00154"></a>00154     basic_string&lt;_CharT, _Traits, _Alloc&gt;::
<a name="l00155"></a>00155     _S_construct(size_type __n, _CharT __c, <span class="keyword">const</span> _Alloc&amp; __a)
<a name="l00156"></a>00156     {
<a name="l00157"></a>00157 <span class="preprocessor">#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0</span>
<a name="l00158"></a>00158 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (__n == 0 &amp;&amp; __a == _Alloc())
<a name="l00159"></a>00159     <span class="keywordflow">return</span> _S_empty_rep()._M_refdata();
<a name="l00160"></a>00160 <span class="preprocessor">#endif</span>
<a name="l00161"></a>00161 <span class="preprocessor"></span>      <span class="comment">// Check for out_of_range and length_error exceptions.</span>
<a name="l00162"></a>00162       _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
<a name="l00163"></a>00163       <span class="keywordflow">if</span> (__n)
<a name="l00164"></a>00164     _M_assign(__r-&gt;_M_refdata(), __n, __c);
<a name="l00165"></a>00165 
<a name="l00166"></a>00166       __r-&gt;_M_set_length_and_sharable(__n);
<a name="l00167"></a>00167       <span class="keywordflow">return</span> __r-&gt;_M_refdata();
<a name="l00168"></a>00168     }
<a name="l00169"></a>00169 
<a name="l00170"></a>00170   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00171"></a>00171     <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00172"></a><a class="code" href="a00427.html#a2e170755f18d8f170ea8af7645a9023c">00172</a> <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">    basic_string</a>(<span class="keyword">const</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string</a>&amp; __str)
<a name="l00173"></a>00173     : _M_dataplus(__str._M_rep()-&gt;_M_grab(_Alloc(__str.get_allocator()),
<a name="l00174"></a>00174                       __str.get_allocator()),
<a name="l00175"></a>00175           __str.get_allocator())
<a name="l00176"></a>00176     { }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00179"></a>00179     <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00180"></a><a class="code" href="a00427.html#a1b86aa9be110b05515cb86436ebecd0c">00180</a> <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">    basic_string</a>(<span class="keyword">const</span> _Alloc&amp; __a)
<a name="l00181"></a>00181     : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
<a name="l00182"></a>00182     { }
<a name="l00183"></a>00183 
<a name="l00184"></a>00184   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00185"></a>00185     <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00186"></a><a class="code" href="a00427.html#a3f714f01124d631e1873968d80db3b31">00186</a> <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">    basic_string</a>(<span class="keyword">const</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string</a>&amp; __str, size_type __pos, size_type __n)
<a name="l00187"></a>00187     : _M_dataplus(_S_construct(__str._M_data()
<a name="l00188"></a>00188                    + __str._M_check(__pos,
<a name="l00189"></a>00189                         <span class="stringliteral">&quot;basic_string::basic_string&quot;</span>),
<a name="l00190"></a>00190                    __str._M_data() + __str._M_limit(__pos, __n)
<a name="l00191"></a>00191                    + __pos, _Alloc()), _Alloc())
<a name="l00192"></a>00192     { }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00195"></a>00195     <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00196"></a><a class="code" href="a00427.html#a50b1cd322a3ce4b1a19874996dc68e5d">00196</a> <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">    basic_string</a>(<span class="keyword">const</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string</a>&amp; __str, size_type __pos,
<a name="l00197"></a>00197          size_type __n, <span class="keyword">const</span> _Alloc&amp; __a)
<a name="l00198"></a>00198     : _M_dataplus(_S_construct(__str._M_data()
<a name="l00199"></a>00199                    + __str._M_check(__pos,
<a name="l00200"></a>00200                         <span class="stringliteral">&quot;basic_string::basic_string&quot;</span>),
<a name="l00201"></a>00201                    __str._M_data() + __str._M_limit(__pos, __n)
<a name="l00202"></a>00202                    + __pos, __a), __a)
<a name="l00203"></a>00203     { }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205   <span class="comment">// TBD: DPG annotate</span>
<a name="l00206"></a>00206   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00207"></a>00207     <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00208"></a><a class="code" href="a00427.html#af08d7a344515d8e99fbc1bc495e03ac7">00208</a> <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">    basic_string</a>(<span class="keyword">const</span> _CharT* __s, size_type __n, <span class="keyword">const</span> _Alloc&amp; __a)
<a name="l00209"></a>00209     : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
<a name="l00210"></a>00210     { }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212   <span class="comment">// TBD: DPG annotate</span>
<a name="l00213"></a>00213   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00214"></a>00214     <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00215"></a><a class="code" href="a00427.html#ae8ec7e4ede4ff46c057ccc86c7548112">00215</a> <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">    basic_string</a>(<span class="keyword">const</span> _CharT* __s, <span class="keyword">const</span> _Alloc&amp; __a)
<a name="l00216"></a>00216     : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
<a name="l00217"></a>00217                    __s + npos, __a), __a)
<a name="l00218"></a>00218     { }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00221"></a>00221     <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00222"></a><a class="code" href="a00427.html#a72834c85f7d482aa0edb360d3e63aa47">00222</a> <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">    basic_string</a>(size_type __n, _CharT __c, <span class="keyword">const</span> _Alloc&amp; __a)
<a name="l00223"></a>00223     : _M_dataplus(_S_construct(__n, __c, __a), __a)
<a name="l00224"></a>00224     { }
<a name="l00225"></a>00225 
<a name="l00226"></a>00226   <span class="comment">// TBD: DPG annotate</span>
<a name="l00227"></a>00227   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00228"></a>00228     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;
<a name="l00229"></a>00229     <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00230"></a><a class="code" href="a00427.html#a0b3a0c256b0cade0c276550827e5605c">00230</a> <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">    basic_string</a>(_InputIterator __beg, _InputIterator __end, <span class="keyword">const</span> _Alloc&amp; __a)
<a name="l00231"></a>00231     : _M_dataplus(_S_construct(__beg, __end, __a), __a)
<a name="l00232"></a>00232     { }
<a name="l00233"></a>00233 
<a name="l00234"></a>00234 <span class="preprocessor">#ifdef __GXX_EXPERIMENTAL_CXX0X__</span>
<a name="l00235"></a>00235 <span class="preprocessor"></span>  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00236"></a>00236     <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00237"></a><a class="code" href="a00427.html#a464829dac12de13b7fdd9411d413fca3">00237</a> <a class="code" href="a00427.html#a28efca629663d35f1b46b53716fcb952" title="Default constructor creates an empty string.">    basic_string</a>(<a class="code" href="a00708.html" title="initializer_list">initializer_list&lt;_CharT&gt;</a> __l, <span class="keyword">const</span> _Alloc&amp; __a)
<a name="l00238"></a>00238     : _M_dataplus(_S_construct(__l.<a class="code" href="a01576.html#a549ebac15bcc03ae83f87b89796d89fc" title="Return an iterator pointing to the first element of the initilizer_list.">begin</a>(), __l.<a class="code" href="a01576.html#a579ff3807b61f57bda29d023b3918504" title="Return an iterator pointing to one past the last element of the initilizer_list.">end</a>(), __a), __a)
<a name="l00239"></a>00239     { }
<a name="l00240"></a>00240 <span class="preprocessor">#endif</span>
<a name="l00241"></a>00241 <span class="preprocessor"></span>
<a name="l00242"></a>00242   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00243"></a>00243     <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a>&amp;
<a name="l00244"></a>00244     <a class="code" href="a00427.html#a40c0c4216ddc30d2d77595a0af24e0a6" title="Set value to contents of another string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00245"></a><a class="code" href="a00427.html#a40c0c4216ddc30d2d77595a0af24e0a6">00245</a> <a class="code" href="a00427.html#a40c0c4216ddc30d2d77595a0af24e0a6" title="Set value to contents of another string.">    assign</a>(<span class="keyword">const</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string</a>&amp; __str)
<a name="l00246"></a>00246     {
<a name="l00247"></a>00247       <span class="keywordflow">if</span> (_M_rep() != __str._M_rep())
<a name="l00248"></a>00248     {
<a name="l00249"></a>00249       <span class="comment">// XXX MT</span>
<a name="l00250"></a>00250       <span class="keyword">const</span> allocator_type __a = this-&gt;get_allocator();
<a name="l00251"></a>00251       _CharT* __tmp = __str._M_rep()-&gt;_M_grab(__a, __str.<a class="code" href="a00427.html#a11ed380f750f6392c9dc440e7193ad0e" title="Return copy of allocator used to construct this string.">get_allocator</a>());
<a name="l00252"></a>00252       _M_rep()-&gt;_M_dispose(__a);
<a name="l00253"></a>00253       _M_data(__tmp);
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00256"></a>00256     }
<a name="l00257"></a>00257 
<a name="l00258"></a>00258   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00259"></a>00259     <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a>&amp;
<a name="l00260"></a>00260     <a class="code" href="a00427.html#a40c0c4216ddc30d2d77595a0af24e0a6" title="Set value to contents of another string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00261"></a><a class="code" href="a00427.html#a29921ea06a2addf4f553a0926cee86ed">00261</a> <a class="code" href="a00427.html#a40c0c4216ddc30d2d77595a0af24e0a6" title="Set value to contents of another string.">    assign</a>(<span class="keyword">const</span> _CharT* __s, size_type __n)
<a name="l00262"></a>00262     {
<a name="l00263"></a>00263       __glibcxx_requires_string_len(__s, __n);
<a name="l00264"></a>00264       _M_check_length(this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>(), __n, <span class="stringliteral">&quot;basic_string::assign&quot;</span>);
<a name="l00265"></a>00265       <span class="keywordflow">if</span> (_M_disjunct(__s) || _M_rep()-&gt;_M_is_shared())
<a name="l00266"></a>00266     <span class="keywordflow">return</span> _M_replace_safe(size_type(0), this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>(), __s, __n);
<a name="l00267"></a>00267       <span class="keywordflow">else</span>
<a name="l00268"></a>00268     {
<a name="l00269"></a>00269       <span class="comment">// Work in-place.</span>
<a name="l00270"></a>00270       <span class="keyword">const</span> size_type __pos = __s - _M_data();
<a name="l00271"></a>00271       <span class="keywordflow">if</span> (__pos &gt;= __n)
<a name="l00272"></a>00272         _M_copy(_M_data(), __s, __n);
<a name="l00273"></a>00273       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (__pos)
<a name="l00274"></a>00274         _M_move(_M_data(), __s, __n);
<a name="l00275"></a>00275       _M_rep()-&gt;_M_set_length_and_sharable(__n);
<a name="l00276"></a>00276       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00277"></a>00277     }
<a name="l00278"></a>00278      }
<a name="l00279"></a>00279 
<a name="l00280"></a>00280   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00281"></a>00281     <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a>&amp;
<a name="l00282"></a>00282     <a class="code" href="a00427.html#a93795d6e4ab56974a69099a52726c1e1" title="Append a string to this string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00283"></a><a class="code" href="a00427.html#a41e22e66a2acd2c64d15cabdc9d3820d">00283</a> <a class="code" href="a00427.html#a93795d6e4ab56974a69099a52726c1e1" title="Append a string to this string.">    append</a>(size_type __n, _CharT __c)
<a name="l00284"></a>00284     {
<a name="l00285"></a>00285       <span class="keywordflow">if</span> (__n)
<a name="l00286"></a>00286     {
<a name="l00287"></a>00287       _M_check_length(size_type(0), __n, <span class="stringliteral">&quot;basic_string::append&quot;</span>);     
<a name="l00288"></a>00288       <span class="keyword">const</span> size_type __len = __n + this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>();
<a name="l00289"></a>00289       <span class="keywordflow">if</span> (__len &gt; this-&gt;capacity() || _M_rep()-&gt;_M_is_shared())
<a name="l00290"></a>00290         this-&gt;reserve(__len);
<a name="l00291"></a>00291       _M_assign(_M_data() + this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>(), __n, __c);
<a name="l00292"></a>00292       _M_rep()-&gt;_M_set_length_and_sharable(__len);
<a name="l00293"></a>00293     }
<a name="l00294"></a>00294       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00295"></a>00295     }
<a name="l00296"></a>00296 
<a name="l00297"></a>00297   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00298"></a>00298     <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a>&amp;
<a name="l00299"></a>00299     <a class="code" href="a00427.html#a93795d6e4ab56974a69099a52726c1e1" title="Append a string to this string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00300"></a><a class="code" href="a00427.html#aedb1f587c0c2da80a654e467e0b02103">00300</a> <a class="code" href="a00427.html#a93795d6e4ab56974a69099a52726c1e1" title="Append a string to this string.">    append</a>(<span class="keyword">const</span> _CharT* __s, size_type __n)
<a name="l00301"></a>00301     {
<a name="l00302"></a>00302       __glibcxx_requires_string_len(__s, __n);
<a name="l00303"></a>00303       <span class="keywordflow">if</span> (__n)
<a name="l00304"></a>00304     {
<a name="l00305"></a>00305       _M_check_length(size_type(0), __n, <span class="stringliteral">&quot;basic_string::append&quot;</span>);
<a name="l00306"></a>00306       <span class="keyword">const</span> size_type __len = __n + this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>();
<a name="l00307"></a>00307       <span class="keywordflow">if</span> (__len &gt; this-&gt;capacity() || _M_rep()-&gt;_M_is_shared())
<a name="l00308"></a>00308         {
<a name="l00309"></a>00309           <span class="keywordflow">if</span> (_M_disjunct(__s))
<a name="l00310"></a>00310         this-&gt;reserve(__len);
<a name="l00311"></a>00311           <span class="keywordflow">else</span>
<a name="l00312"></a>00312         {
<a name="l00313"></a>00313           <span class="keyword">const</span> size_type __off = __s - _M_data();
<a name="l00314"></a>00314           this-&gt;reserve(__len);
<a name="l00315"></a>00315           __s = _M_data() + __off;
<a name="l00316"></a>00316         }
<a name="l00317"></a>00317         }
<a name="l00318"></a>00318       _M_copy(_M_data() + this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>(), __s, __n);
<a name="l00319"></a>00319       _M_rep()-&gt;_M_set_length_and_sharable(__len);
<a name="l00320"></a>00320     }
<a name="l00321"></a>00321       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00322"></a>00322     }
<a name="l00323"></a>00323 
<a name="l00324"></a>00324   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00325"></a>00325     <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a>&amp;
<a name="l00326"></a>00326     <a class="code" href="a00427.html#a93795d6e4ab56974a69099a52726c1e1" title="Append a string to this string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00327"></a><a class="code" href="a00427.html#a93795d6e4ab56974a69099a52726c1e1">00327</a> <a class="code" href="a00427.html#a93795d6e4ab56974a69099a52726c1e1" title="Append a string to this string.">    append</a>(<span class="keyword">const</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string</a>&amp; __str)
<a name="l00328"></a>00328     {
<a name="l00329"></a>00329       <span class="keyword">const</span> size_type __size = __str.<a class="code" href="a00427.html#a76116ea8b9ef4566f47a7e264f35fac1" title="Returns the number of characters in the string, not including any null-termination.">size</a>();
<a name="l00330"></a>00330       <span class="keywordflow">if</span> (__size)
<a name="l00331"></a>00331     {
<a name="l00332"></a>00332       <span class="keyword">const</span> size_type __len = __size + this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>();
<a name="l00333"></a>00333       <span class="keywordflow">if</span> (__len &gt; this-&gt;capacity() || _M_rep()-&gt;_M_is_shared())
<a name="l00334"></a>00334         this-&gt;reserve(__len);
<a name="l00335"></a>00335       _M_copy(_M_data() + this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>(), __str._M_data(), __size);
<a name="l00336"></a>00336       _M_rep()-&gt;_M_set_length_and_sharable(__len);
<a name="l00337"></a>00337     }
<a name="l00338"></a>00338       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00339"></a>00339     }    
<a name="l00340"></a>00340 
<a name="l00341"></a>00341   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00342"></a>00342     <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a>&amp;
<a name="l00343"></a>00343     <a class="code" href="a00427.html#a93795d6e4ab56974a69099a52726c1e1" title="Append a string to this string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00344"></a><a class="code" href="a00427.html#a994d19c140f66be9b1b7219e4d64d111">00344</a> <a class="code" href="a00427.html#a93795d6e4ab56974a69099a52726c1e1" title="Append a string to this string.">    append</a>(<span class="keyword">const</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string</a>&amp; __str, size_type __pos, size_type __n)
<a name="l00345"></a>00345     {
<a name="l00346"></a>00346       __str._M_check(__pos, <span class="stringliteral">&quot;basic_string::append&quot;</span>);
<a name="l00347"></a>00347       __n = __str._M_limit(__pos, __n);
<a name="l00348"></a>00348       <span class="keywordflow">if</span> (__n)
<a name="l00349"></a>00349     {
<a name="l00350"></a>00350       <span class="keyword">const</span> size_type __len = __n + this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>();
<a name="l00351"></a>00351       <span class="keywordflow">if</span> (__len &gt; this-&gt;capacity() || _M_rep()-&gt;_M_is_shared())
<a name="l00352"></a>00352         this-&gt;reserve(__len);
<a name="l00353"></a>00353       _M_copy(_M_data() + this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>(), __str._M_data() + __pos, __n);
<a name="l00354"></a>00354       _M_rep()-&gt;_M_set_length_and_sharable(__len);    
<a name="l00355"></a>00355     }
<a name="l00356"></a>00356       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00357"></a>00357     }
<a name="l00358"></a>00358 
<a name="l00359"></a>00359    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00360"></a>00360      <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a>&amp;
<a name="l00361"></a>00361      <a class="code" href="a00427.html#a3e9371291649e0ef913b1db6eca30fe6" title="Insert multiple characters.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00362"></a><a class="code" href="a00427.html#a5ddc3f0696e69ba341e5cbdc78a1a727">00362</a> <a class="code" href="a00427.html#a3e9371291649e0ef913b1db6eca30fe6" title="Insert multiple characters.">     insert</a>(size_type __pos, <span class="keyword">const</span> _CharT* __s, size_type __n)
<a name="l00363"></a>00363      {
<a name="l00364"></a>00364        __glibcxx_requires_string_len(__s, __n);
<a name="l00365"></a>00365        _M_check(__pos, <span class="stringliteral">&quot;basic_string::insert&quot;</span>);
<a name="l00366"></a>00366        _M_check_length(size_type(0), __n, <span class="stringliteral">&quot;basic_string::insert&quot;</span>);
<a name="l00367"></a>00367        <span class="keywordflow">if</span> (_M_disjunct(__s) || _M_rep()-&gt;_M_is_shared())
<a name="l00368"></a>00368          <span class="keywordflow">return</span> _M_replace_safe(__pos, size_type(0), __s, __n);
<a name="l00369"></a>00369        <span class="keywordflow">else</span>
<a name="l00370"></a>00370          {
<a name="l00371"></a>00371            <span class="comment">// Work in-place.</span>
<a name="l00372"></a>00372            <span class="keyword">const</span> size_type __off = __s - _M_data();
<a name="l00373"></a>00373            _M_mutate(__pos, 0, __n);
<a name="l00374"></a>00374            __s = _M_data() + __off;
<a name="l00375"></a>00375            _CharT* __p = _M_data() + __pos;
<a name="l00376"></a>00376            <span class="keywordflow">if</span> (__s  + __n &lt;= __p)
<a name="l00377"></a>00377              _M_copy(__p, __s, __n);
<a name="l00378"></a>00378            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (__s &gt;= __p)
<a name="l00379"></a>00379              _M_copy(__p, __s + __n, __n);
<a name="l00380"></a>00380            <span class="keywordflow">else</span>
<a name="l00381"></a>00381              {
<a name="l00382"></a>00382            <span class="keyword">const</span> size_type __nleft = __p - __s;
<a name="l00383"></a>00383                _M_copy(__p, __s, __nleft);
<a name="l00384"></a>00384                _M_copy(__p + __nleft, __p + __n, __n - __nleft);
<a name="l00385"></a>00385              }
<a name="l00386"></a>00386            <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00387"></a>00387          }
<a name="l00388"></a>00388      }
<a name="l00389"></a>00389 
<a name="l00390"></a>00390    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00391"></a>00391      <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::iterator
<a name="l00392"></a>00392      <a class="code" href="a00427.html#ad0c376cb963e61712842490d44d53a74" title="Remove characters.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00393"></a><a class="code" href="a00427.html#a14043b49e3ab3c8834b1936a8bdf7fd7">00393</a> <a class="code" href="a00427.html#ad0c376cb963e61712842490d44d53a74" title="Remove characters.">     erase</a>(iterator __first, iterator __last)
<a name="l00394"></a>00394      {
<a name="l00395"></a>00395        _GLIBCXX_DEBUG_PEDASSERT(__first &gt;= _M_ibegin() &amp;&amp; __first &lt;= __last
<a name="l00396"></a>00396                 &amp;&amp; __last &lt;= _M_iend());
<a name="l00397"></a>00397 
<a name="l00398"></a>00398        <span class="comment">// NB: This isn&#39;t just an optimization (bail out early when</span>
<a name="l00399"></a>00399        <span class="comment">// there is nothing to do, really), it&#39;s also a correctness</span>
<a name="l00400"></a>00400        <span class="comment">// issue vs MT, see libstdc++/40518.</span>
<a name="l00401"></a>00401        <span class="keyword">const</span> size_type __size = __last - __first;
<a name="l00402"></a>00402        <span class="keywordflow">if</span> (__size)
<a name="l00403"></a>00403      {
<a name="l00404"></a>00404        <span class="keyword">const</span> size_type __pos = __first - _M_ibegin();
<a name="l00405"></a>00405        _M_mutate(__pos, __size, size_type(0));
<a name="l00406"></a>00406        _M_rep()-&gt;_M_set_leaked();
<a name="l00407"></a>00407        <span class="keywordflow">return</span> iterator(_M_data() + __pos);
<a name="l00408"></a>00408      }
<a name="l00409"></a>00409        <span class="keywordflow">else</span>
<a name="l00410"></a>00410      <span class="keywordflow">return</span> __first;
<a name="l00411"></a>00411      }
<a name="l00412"></a>00412 
<a name="l00413"></a>00413    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00414"></a>00414      <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a>&amp;
<a name="l00415"></a>00415      <a class="code" href="a00427.html#a499572a795055fb2b4640aa8fa933a7d" title="Replace characters with value from another string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00416"></a><a class="code" href="a00427.html#a51945801c8054e522d106ead6dbb2f5d">00416</a> <a class="code" href="a00427.html#a499572a795055fb2b4640aa8fa933a7d" title="Replace characters with value from another string.">     replace</a>(size_type __pos, size_type __n1, <span class="keyword">const</span> _CharT* __s,
<a name="l00417"></a>00417          size_type __n2)
<a name="l00418"></a>00418      {
<a name="l00419"></a>00419        __glibcxx_requires_string_len(__s, __n2);
<a name="l00420"></a>00420        _M_check(__pos, <span class="stringliteral">&quot;basic_string::replace&quot;</span>);
<a name="l00421"></a>00421        __n1 = _M_limit(__pos, __n1);
<a name="l00422"></a>00422        _M_check_length(__n1, __n2, <span class="stringliteral">&quot;basic_string::replace&quot;</span>);
<a name="l00423"></a>00423        <span class="keywordtype">bool</span> __left;
<a name="l00424"></a>00424        <span class="keywordflow">if</span> (_M_disjunct(__s) || _M_rep()-&gt;_M_is_shared())
<a name="l00425"></a>00425          <span class="keywordflow">return</span> _M_replace_safe(__pos, __n1, __s, __n2);
<a name="l00426"></a>00426        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((__left = __s + __n2 &lt;= _M_data() + __pos)
<a name="l00427"></a>00427         || _M_data() + __pos + __n1 &lt;= __s)
<a name="l00428"></a>00428      {
<a name="l00429"></a>00429        <span class="comment">// Work in-place: non-overlapping case.</span>
<a name="l00430"></a>00430        size_type __off = __s - _M_data();
<a name="l00431"></a>00431        __left ? __off : (__off += __n2 - __n1);
<a name="l00432"></a>00432        _M_mutate(__pos, __n1, __n2);
<a name="l00433"></a>00433        _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
<a name="l00434"></a>00434        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00435"></a>00435      }
<a name="l00436"></a>00436        <span class="keywordflow">else</span>
<a name="l00437"></a>00437      {
<a name="l00438"></a>00438        <span class="comment">// Todo: overlapping case.</span>
<a name="l00439"></a>00439        <span class="keyword">const</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string</a> __tmp(__s, __n2);
<a name="l00440"></a>00440        <span class="keywordflow">return</span> _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
<a name="l00441"></a>00441      }
<a name="l00442"></a>00442      }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00445"></a>00445     <span class="keywordtype">void</span>
<a name="l00446"></a>00446     <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::_Rep::</a>
<a name="l00447"></a>00447 <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">    _M_destroy</a>(<span class="keyword">const</span> _Alloc&amp; __a) <span class="keywordflow">throw</span> ()
<a name="l00448"></a>00448     {
<a name="l00449"></a>00449       <span class="keyword">const</span> size_type __size = <span class="keyword">sizeof</span>(_Rep_base) +
<a name="l00450"></a>00450                            (this-&gt;_M_capacity + 1) * <span class="keyword">sizeof</span>(_CharT);
<a name="l00451"></a>00451       _Raw_bytes_alloc(__a).deallocate(reinterpret_cast&lt;char*&gt;(<span class="keyword">this</span>), __size);
<a name="l00452"></a>00452     }
<a name="l00453"></a>00453 
<a name="l00454"></a>00454   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00455"></a>00455     <span class="keywordtype">void</span>
<a name="l00456"></a>00456     basic_string&lt;_CharT, _Traits, _Alloc&gt;::
<a name="l00457"></a>00457     _M_leak_hard()
<a name="l00458"></a>00458     {
<a name="l00459"></a>00459 <span class="preprocessor">#if _GLIBCXX_FULLY_DYNAMIC_STRING == 0</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (_M_rep() == &amp;_S_empty_rep())
<a name="l00461"></a>00461     <span class="keywordflow">return</span>;
<a name="l00462"></a>00462 <span class="preprocessor">#endif</span>
<a name="l00463"></a>00463 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (_M_rep()-&gt;_M_is_shared())
<a name="l00464"></a>00464     _M_mutate(0, 0, 0);
<a name="l00465"></a>00465       _M_rep()-&gt;_M_set_leaked();
<a name="l00466"></a>00466     }
<a name="l00467"></a>00467 
<a name="l00468"></a>00468   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00469"></a>00469     <span class="keywordtype">void</span>
<a name="l00470"></a>00470     basic_string&lt;_CharT, _Traits, _Alloc&gt;::
<a name="l00471"></a>00471     _M_mutate(size_type __pos, size_type __len1, size_type __len2)
<a name="l00472"></a>00472     {
<a name="l00473"></a>00473       <span class="keyword">const</span> size_type __old_size = this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>();
<a name="l00474"></a>00474       <span class="keyword">const</span> size_type __new_size = __old_size + __len2 - __len1;
<a name="l00475"></a>00475       <span class="keyword">const</span> size_type __how_much = __old_size - __pos - __len1;
<a name="l00476"></a>00476 
<a name="l00477"></a>00477       <span class="keywordflow">if</span> (__new_size &gt; this-&gt;capacity() || _M_rep()-&gt;_M_is_shared())
<a name="l00478"></a>00478     {
<a name="l00479"></a>00479       <span class="comment">// Must reallocate.</span>
<a name="l00480"></a>00480       <span class="keyword">const</span> allocator_type __a = get_allocator();
<a name="l00481"></a>00481       _Rep* __r = _Rep::_S_create(__new_size, this-&gt;capacity(), __a);
<a name="l00482"></a>00482 
<a name="l00483"></a>00483       <span class="keywordflow">if</span> (__pos)
<a name="l00484"></a>00484         _M_copy(__r-&gt;_M_refdata(), _M_data(), __pos);
<a name="l00485"></a>00485       <span class="keywordflow">if</span> (__how_much)
<a name="l00486"></a>00486         _M_copy(__r-&gt;_M_refdata() + __pos + __len2,
<a name="l00487"></a>00487             _M_data() + __pos + __len1, __how_much);
<a name="l00488"></a>00488 
<a name="l00489"></a>00489       _M_rep()-&gt;_M_dispose(__a);
<a name="l00490"></a>00490       _M_data(__r-&gt;_M_refdata());
<a name="l00491"></a>00491     }
<a name="l00492"></a>00492       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (__how_much &amp;&amp; __len1 != __len2)
<a name="l00493"></a>00493     {
<a name="l00494"></a>00494       <span class="comment">// Work in-place.</span>
<a name="l00495"></a>00495       _M_move(_M_data() + __pos + __len2,
<a name="l00496"></a>00496           _M_data() + __pos + __len1, __how_much);
<a name="l00497"></a>00497     }
<a name="l00498"></a>00498       _M_rep()-&gt;_M_set_length_and_sharable(__new_size);
<a name="l00499"></a>00499     }
<a name="l00500"></a>00500 
<a name="l00501"></a>00501   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00502"></a>00502     <span class="keywordtype">void</span>
<a name="l00503"></a>00503     <a class="code" href="a00427.html#a33d4d3491641d9129f660cb46a9ccac8" title="Attempt to preallocate enough memory for specified number of characters.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00504"></a><a class="code" href="a00427.html#a33d4d3491641d9129f660cb46a9ccac8">00504</a> <a class="code" href="a00427.html#a33d4d3491641d9129f660cb46a9ccac8" title="Attempt to preallocate enough memory for specified number of characters.">    reserve</a>(size_type __res)
<a name="l00505"></a>00505     {
<a name="l00506"></a>00506       <span class="keywordflow">if</span> (__res != this-&gt;capacity() || _M_rep()-&gt;_M_is_shared())
<a name="l00507"></a>00507         {
<a name="l00508"></a>00508       <span class="comment">// Make sure we don&#39;t shrink below the current size</span>
<a name="l00509"></a>00509       <span class="keywordflow">if</span> (__res &lt; this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>())
<a name="l00510"></a>00510         __res = this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>();
<a name="l00511"></a>00511       <span class="keyword">const</span> allocator_type __a = get_allocator();
<a name="l00512"></a>00512       _CharT* __tmp = _M_rep()-&gt;_M_clone(__a, __res - this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>());
<a name="l00513"></a>00513       _M_rep()-&gt;_M_dispose(__a);
<a name="l00514"></a>00514       _M_data(__tmp);
<a name="l00515"></a>00515         }
<a name="l00516"></a>00516     }
<a name="l00517"></a>00517 
<a name="l00518"></a>00518   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00519"></a>00519     <span class="keywordtype">void</span>
<a name="l00520"></a>00520     <a class="code" href="a00427.html#a82c14c3fd8fa3cd5a7ccf1c76fa89b03" title="Swap contents with another string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00521"></a><a class="code" href="a00427.html#a82c14c3fd8fa3cd5a7ccf1c76fa89b03">00521</a> <a class="code" href="a00427.html#a82c14c3fd8fa3cd5a7ccf1c76fa89b03" title="Swap contents with another string.">    swap</a>(<a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string</a>&amp; __s)
<a name="l00522"></a>00522     {
<a name="l00523"></a>00523       <span class="keywordflow">if</span> (_M_rep()-&gt;_M_is_leaked())
<a name="l00524"></a>00524     _M_rep()-&gt;_M_set_sharable();
<a name="l00525"></a>00525       <span class="keywordflow">if</span> (__s._M_rep()-&gt;_M_is_leaked())
<a name="l00526"></a>00526     __s._M_rep()-&gt;_M_set_sharable();
<a name="l00527"></a>00527       <span class="keywordflow">if</span> (this-&gt;get_allocator() == __s.<a class="code" href="a00427.html#a11ed380f750f6392c9dc440e7193ad0e" title="Return copy of allocator used to construct this string.">get_allocator</a>())
<a name="l00528"></a>00528     {
<a name="l00529"></a>00529       _CharT* __tmp = _M_data();
<a name="l00530"></a>00530       _M_data(__s._M_data());
<a name="l00531"></a>00531       __s._M_data(__tmp);
<a name="l00532"></a>00532     }
<a name="l00533"></a>00533       <span class="comment">// The code below can usually be optimized away.</span>
<a name="l00534"></a>00534       <span class="keywordflow">else</span>
<a name="l00535"></a>00535     {
<a name="l00536"></a>00536       <span class="keyword">const</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string</a> __tmp1(_M_ibegin(), _M_iend(),
<a name="l00537"></a>00537                     __s.<a class="code" href="a00427.html#a11ed380f750f6392c9dc440e7193ad0e" title="Return copy of allocator used to construct this string.">get_allocator</a>());
<a name="l00538"></a>00538       <span class="keyword">const</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string</a> __tmp2(__s._M_ibegin(), __s._M_iend(),
<a name="l00539"></a>00539                     this-&gt;get_allocator());
<a name="l00540"></a>00540       *<span class="keyword">this</span> = __tmp2;
<a name="l00541"></a>00541       __s = __tmp1;
<a name="l00542"></a>00542     }
<a name="l00543"></a>00543     }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00546"></a>00546     <span class="keyword">typename</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::_Rep</a>*
<a name="l00547"></a>00547     <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::_Rep::</a>
<a name="l00548"></a>00548 <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">    _S_create</a>(size_type __capacity, size_type __old_capacity,
<a name="l00549"></a>00549           <span class="keyword">const</span> _Alloc&amp; __alloc)
<a name="l00550"></a>00550     {
<a name="l00551"></a>00551       <span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span>
<a name="l00552"></a>00552       <span class="comment">// 83.  String::npos vs. string::max_size()</span>
<a name="l00553"></a>00553       <span class="keywordflow">if</span> (__capacity &gt; _S_max_size)
<a name="l00554"></a>00554     __throw_length_error(__N(<span class="stringliteral">&quot;basic_string::_S_create&quot;</span>));
<a name="l00555"></a>00555 
<a name="l00556"></a>00556       <span class="comment">// The standard places no restriction on allocating more memory</span>
<a name="l00557"></a>00557       <span class="comment">// than is strictly needed within this layer at the moment or as</span>
<a name="l00558"></a>00558       <span class="comment">// requested by an explicit application call to reserve().</span>
<a name="l00559"></a>00559 
<a name="l00560"></a>00560       <span class="comment">// Many malloc implementations perform quite poorly when an</span>
<a name="l00561"></a>00561       <span class="comment">// application attempts to allocate memory in a stepwise fashion</span>
<a name="l00562"></a>00562       <span class="comment">// growing each allocation size by only 1 char.  Additionally,</span>
<a name="l00563"></a>00563       <span class="comment">// it makes little sense to allocate less linear memory than the</span>
<a name="l00564"></a>00564       <span class="comment">// natural blocking size of the malloc implementation.</span>
<a name="l00565"></a>00565       <span class="comment">// Unfortunately, we would need a somewhat low-level calculation</span>
<a name="l00566"></a>00566       <span class="comment">// with tuned parameters to get this perfect for any particular</span>
<a name="l00567"></a>00567       <span class="comment">// malloc implementation.  Fortunately, generalizations about</span>
<a name="l00568"></a>00568       <span class="comment">// common features seen among implementations seems to suffice.</span>
<a name="l00569"></a>00569 
<a name="l00570"></a>00570       <span class="comment">// __pagesize need not match the actual VM page size for good</span>
<a name="l00571"></a>00571       <span class="comment">// results in practice, thus we pick a common value on the low</span>
<a name="l00572"></a>00572       <span class="comment">// side.  __malloc_header_size is an estimate of the amount of</span>
<a name="l00573"></a>00573       <span class="comment">// overhead per memory allocation (in practice seen N * sizeof</span>
<a name="l00574"></a>00574       <span class="comment">// (void*) where N is 0, 2 or 4).  According to folklore,</span>
<a name="l00575"></a>00575       <span class="comment">// picking this value on the high side is better than</span>
<a name="l00576"></a>00576       <span class="comment">// low-balling it (especially when this algorithm is used with</span>
<a name="l00577"></a>00577       <span class="comment">// malloc implementations that allocate memory blocks rounded up</span>
<a name="l00578"></a>00578       <span class="comment">// to a size which is a power of 2).</span>
<a name="l00579"></a>00579       <span class="keyword">const</span> size_type __pagesize = 4096;
<a name="l00580"></a>00580       <span class="keyword">const</span> size_type __malloc_header_size = 4 * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span>*);
<a name="l00581"></a>00581 
<a name="l00582"></a>00582       <span class="comment">// The below implements an exponential growth policy, necessary to</span>
<a name="l00583"></a>00583       <span class="comment">// meet amortized linear time requirements of the library: see</span>
<a name="l00584"></a>00584       <span class="comment">// http://gcc.gnu.org/ml/libstdc++/2001-07/msg00085.html.</span>
<a name="l00585"></a>00585       <span class="comment">// It&#39;s active for allocations requiring an amount of memory above</span>
<a name="l00586"></a>00586       <span class="comment">// system pagesize. This is consistent with the requirements of the</span>
<a name="l00587"></a>00587       <span class="comment">// standard: http://gcc.gnu.org/ml/libstdc++/2001-07/msg00130.html</span>
<a name="l00588"></a>00588       <span class="keywordflow">if</span> (__capacity &gt; __old_capacity &amp;&amp; __capacity &lt; 2 * __old_capacity)
<a name="l00589"></a>00589     __capacity = 2 * __old_capacity;
<a name="l00590"></a>00590 
<a name="l00591"></a>00591       <span class="comment">// NB: Need an array of char_type[__capacity], plus a terminating</span>
<a name="l00592"></a>00592       <span class="comment">// null char_type() element, plus enough for the _Rep data structure.</span>
<a name="l00593"></a>00593       <span class="comment">// Whew. Seemingly so needy, yet so elemental.</span>
<a name="l00594"></a>00594       size_type __size = (__capacity + 1) * <span class="keyword">sizeof</span>(_CharT) + <span class="keyword">sizeof</span>(_Rep);
<a name="l00595"></a>00595 
<a name="l00596"></a>00596       <span class="keyword">const</span> size_type __adj_size = __size + __malloc_header_size;
<a name="l00597"></a>00597       <span class="keywordflow">if</span> (__adj_size &gt; __pagesize &amp;&amp; __capacity &gt; __old_capacity)
<a name="l00598"></a>00598     {
<a name="l00599"></a>00599       <span class="keyword">const</span> size_type __extra = __pagesize - __adj_size % __pagesize;
<a name="l00600"></a>00600       __capacity += __extra / <span class="keyword">sizeof</span>(_CharT);
<a name="l00601"></a>00601       <span class="comment">// Never allocate a string bigger than _S_max_size.</span>
<a name="l00602"></a>00602       <span class="keywordflow">if</span> (__capacity &gt; _S_max_size)
<a name="l00603"></a>00603         __capacity = _S_max_size;
<a name="l00604"></a>00604       __size = (__capacity + 1) * <span class="keyword">sizeof</span>(_CharT) + <span class="keyword">sizeof</span>(_Rep);
<a name="l00605"></a>00605     }
<a name="l00606"></a>00606 
<a name="l00607"></a>00607       <span class="comment">// NB: Might throw, but no worries about a leak, mate: _Rep()</span>
<a name="l00608"></a>00608       <span class="comment">// does not throw.</span>
<a name="l00609"></a>00609       <span class="keywordtype">void</span>* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
<a name="l00610"></a>00610       _Rep *__p = <span class="keyword">new</span> (__place) _Rep;
<a name="l00611"></a>00611       __p-&gt;_M_capacity = __capacity;
<a name="l00612"></a>00612       <span class="comment">// ABI compatibility - 3.4.x set in _S_create both</span>
<a name="l00613"></a>00613       <span class="comment">// _M_refcount and _M_length.  All callers of _S_create</span>
<a name="l00614"></a>00614       <span class="comment">// in basic_string.tcc then set just _M_length.</span>
<a name="l00615"></a>00615       <span class="comment">// In 4.0.x and later both _M_refcount and _M_length</span>
<a name="l00616"></a>00616       <span class="comment">// are initialized in the callers, unfortunately we can</span>
<a name="l00617"></a>00617       <span class="comment">// have 3.4.x compiled code with _S_create callers inlined</span>
<a name="l00618"></a>00618       <span class="comment">// calling 4.0.x+ _S_create.</span>
<a name="l00619"></a>00619       __p-&gt;_M_set_sharable();
<a name="l00620"></a>00620       <span class="keywordflow">return</span> __p;
<a name="l00621"></a>00621     }
<a name="l00622"></a>00622 
<a name="l00623"></a>00623   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00624"></a>00624     _CharT*
<a name="l00625"></a>00625     basic_string&lt;_CharT, _Traits, _Alloc&gt;::_Rep::
<a name="l00626"></a>00626     _M_clone(<span class="keyword">const</span> _Alloc&amp; __alloc, size_type __res)
<a name="l00627"></a>00627     {
<a name="l00628"></a>00628       <span class="comment">// Requested capacity of the clone.</span>
<a name="l00629"></a>00629       <span class="keyword">const</span> size_type __requested_cap = this-&gt;_M_length + __res;
<a name="l00630"></a>00630       _Rep* __r = _Rep::_S_create(__requested_cap, this-&gt;_M_capacity,
<a name="l00631"></a>00631                   __alloc);
<a name="l00632"></a>00632       <span class="keywordflow">if</span> (this-&gt;_M_length)
<a name="l00633"></a>00633     _M_copy(__r-&gt;_M_refdata(), _M_refdata(), this-&gt;_M_length);
<a name="l00634"></a>00634 
<a name="l00635"></a>00635       __r-&gt;_M_set_length_and_sharable(this-&gt;_M_length);
<a name="l00636"></a>00636       <span class="keywordflow">return</span> __r-&gt;_M_refdata();
<a name="l00637"></a>00637     }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00640"></a>00640     <span class="keywordtype">void</span>
<a name="l00641"></a>00641     <a class="code" href="a00427.html#a7530f355537da638911c78ef7925daa9" title="Resizes the string to the specified number of characters.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00642"></a><a class="code" href="a00427.html#a7530f355537da638911c78ef7925daa9">00642</a> <a class="code" href="a00427.html#a7530f355537da638911c78ef7925daa9" title="Resizes the string to the specified number of characters.">    resize</a>(size_type __n, _CharT __c)
<a name="l00643"></a>00643     {
<a name="l00644"></a>00644       <span class="keyword">const</span> size_type __size = this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>();
<a name="l00645"></a>00645       _M_check_length(__size, __n, <span class="stringliteral">&quot;basic_string::resize&quot;</span>);
<a name="l00646"></a>00646       <span class="keywordflow">if</span> (__size &lt; __n)
<a name="l00647"></a>00647     this-&gt;append(__n - __size, __c);
<a name="l00648"></a>00648       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (__n &lt; __size)
<a name="l00649"></a>00649     this-&gt;erase(__n);
<a name="l00650"></a>00650       <span class="comment">// else nothing (in particular, avoid calling _M_mutate() unnecessarily.)</span>
<a name="l00651"></a>00651     }
<a name="l00652"></a>00652 
<a name="l00653"></a>00653   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00654"></a>00654     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;
<a name="l00655"></a>00655       <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a>&amp;
<a name="l00656"></a>00656       <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00657"></a>00657 <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">      _M_replace_dispatch</a>(<a class="code" href="a00438.html" title="Common iterator class.">iterator</a> __i1, <a class="code" href="a00438.html" title="Common iterator class.">iterator</a> __i2, _InputIterator __k1,
<a name="l00658"></a>00658               _InputIterator __k2, __false_type)
<a name="l00659"></a>00659       {
<a name="l00660"></a>00660     <span class="keyword">const</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string</a> __s(__k1, __k2);
<a name="l00661"></a>00661     <span class="keyword">const</span> size_type __n1 = __i2 - __i1;
<a name="l00662"></a>00662     _M_check_length(__n1, __s.size(), <span class="stringliteral">&quot;basic_string::_M_replace_dispatch&quot;</span>);
<a name="l00663"></a>00663     <span class="keywordflow">return</span> _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
<a name="l00664"></a>00664                    __s.size());
<a name="l00665"></a>00665       }
<a name="l00666"></a>00666 
<a name="l00667"></a>00667   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00668"></a>00668     basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp;
<a name="l00669"></a>00669     basic_string&lt;_CharT, _Traits, _Alloc&gt;::
<a name="l00670"></a>00670     _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
<a name="l00671"></a>00671            _CharT __c)
<a name="l00672"></a>00672     {
<a name="l00673"></a>00673       _M_check_length(__n1, __n2, <span class="stringliteral">&quot;basic_string::_M_replace_aux&quot;</span>);
<a name="l00674"></a>00674       _M_mutate(__pos1, __n1, __n2);
<a name="l00675"></a>00675       <span class="keywordflow">if</span> (__n2)
<a name="l00676"></a>00676     _M_assign(_M_data() + __pos1, __n2, __c);
<a name="l00677"></a>00677       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00678"></a>00678     }
<a name="l00679"></a>00679 
<a name="l00680"></a>00680   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00681"></a>00681     basic_string&lt;_CharT, _Traits, _Alloc&gt;&amp;
<a name="l00682"></a>00682     basic_string&lt;_CharT, _Traits, _Alloc&gt;::
<a name="l00683"></a>00683     _M_replace_safe(size_type __pos1, size_type __n1, <span class="keyword">const</span> _CharT* __s,
<a name="l00684"></a>00684             size_type __n2)
<a name="l00685"></a>00685     {
<a name="l00686"></a>00686       _M_mutate(__pos1, __n1, __n2);
<a name="l00687"></a>00687       <span class="keywordflow">if</span> (__n2)
<a name="l00688"></a>00688     _M_copy(_M_data() + __pos1, __s, __n2);
<a name="l00689"></a>00689       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00690"></a>00690     }
<a name="l00691"></a>00691    
<a name="l00692"></a>00692   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00693"></a>00693     basic_string&lt;_CharT, _Traits, _Alloc&gt;
<a name="l00694"></a><a class="code" href="a01576.html#ae220860a64ea80fb9522daf38053aa8f">00694</a>     <a class="code" href="a01604.html#gaf2a59d9d4f1421dcdba7b5ce55ca9358" title="Return new complex value x plus y.">operator+</a>(<span class="keyword">const</span> _CharT* __lhs,
<a name="l00695"></a>00695           <span class="keyword">const</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a>&amp; __rhs)
<a name="l00696"></a>00696     {
<a name="l00697"></a>00697       __glibcxx_requires_string(__lhs);
<a name="l00698"></a>00698       <span class="keyword">typedef</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a> __string_type;
<a name="l00699"></a>00699       <span class="keyword">typedef</span> <span class="keyword">typename</span> __string_type::size_type   __size_type;
<a name="l00700"></a>00700       <span class="keyword">const</span> __size_type __len = _Traits::length(__lhs);
<a name="l00701"></a>00701       __string_type __str;
<a name="l00702"></a>00702       __str.reserve(__len + __rhs.<a class="code" href="a00427.html#a76116ea8b9ef4566f47a7e264f35fac1" title="Returns the number of characters in the string, not including any null-termination.">size</a>());
<a name="l00703"></a>00703       __str.append(__lhs, __len);
<a name="l00704"></a>00704       __str.append(__rhs);
<a name="l00705"></a>00705       <span class="keywordflow">return</span> __str;
<a name="l00706"></a>00706     }
<a name="l00707"></a>00707 
<a name="l00708"></a>00708   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00709"></a>00709     basic_string&lt;_CharT, _Traits, _Alloc&gt;
<a name="l00710"></a><a class="code" href="a01576.html#a952b727c802635e947a9a6b64f2f3ed1">00710</a>     <a class="code" href="a01604.html#gaf2a59d9d4f1421dcdba7b5ce55ca9358" title="Return new complex value x plus y.">operator+</a>(_CharT __lhs, <span class="keyword">const</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a>&amp; __rhs)
<a name="l00711"></a>00711     {
<a name="l00712"></a>00712       <span class="keyword">typedef</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a> __string_type;
<a name="l00713"></a>00713       <span class="keyword">typedef</span> <span class="keyword">typename</span> __string_type::size_type   __size_type;
<a name="l00714"></a>00714       __string_type __str;
<a name="l00715"></a>00715       <span class="keyword">const</span> __size_type __len = __rhs.<a class="code" href="a00427.html#a76116ea8b9ef4566f47a7e264f35fac1" title="Returns the number of characters in the string, not including any null-termination.">size</a>();
<a name="l00716"></a>00716       __str.reserve(__len + 1);
<a name="l00717"></a>00717       __str.append(__size_type(1), __lhs);
<a name="l00718"></a>00718       __str.append(__rhs);
<a name="l00719"></a>00719       <span class="keywordflow">return</span> __str;
<a name="l00720"></a>00720     }
<a name="l00721"></a>00721 
<a name="l00722"></a>00722   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00723"></a>00723     <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type
<a name="l00724"></a>00724     <a class="code" href="a00427.html#a819db7e495b591d2ba440dd97c9711ad" title="Copy substring into C string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00725"></a><a class="code" href="a00427.html#a819db7e495b591d2ba440dd97c9711ad">00725</a> <a class="code" href="a00427.html#a819db7e495b591d2ba440dd97c9711ad" title="Copy substring into C string.">    copy</a>(_CharT* __s, size_type __n, size_type __pos)<span class="keyword"> const</span>
<a name="l00726"></a>00726 <span class="keyword">    </span>{
<a name="l00727"></a>00727       _M_check(__pos, <span class="stringliteral">&quot;basic_string::copy&quot;</span>);
<a name="l00728"></a>00728       __n = _M_limit(__pos, __n);
<a name="l00729"></a>00729       __glibcxx_requires_string_len(__s, __n);
<a name="l00730"></a>00730       <span class="keywordflow">if</span> (__n)
<a name="l00731"></a>00731     _M_copy(__s, _M_data() + __pos, __n);
<a name="l00732"></a>00732       <span class="comment">// 21.3.5.7 par 3: do not append null.  (good.)</span>
<a name="l00733"></a>00733       <span class="keywordflow">return</span> __n;
<a name="l00734"></a>00734     }
<a name="l00735"></a>00735 
<a name="l00736"></a>00736   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00737"></a>00737     <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type
<a name="l00738"></a>00738     <a class="code" href="a00427.html#a1ffe7df30c34a410bd75e7cb5b9e352e" title="Find position of a C substring.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00739"></a><a class="code" href="a00427.html#a1ffe7df30c34a410bd75e7cb5b9e352e">00739</a> <a class="code" href="a00427.html#a1ffe7df30c34a410bd75e7cb5b9e352e" title="Find position of a C substring.">    find</a>(<span class="keyword">const</span> _CharT* __s, size_type __pos, size_type __n)<span class="keyword"> const</span>
<a name="l00740"></a>00740 <span class="keyword">    </span>{
<a name="l00741"></a>00741       __glibcxx_requires_string_len(__s, __n);
<a name="l00742"></a>00742       <span class="keyword">const</span> size_type __size = this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>();
<a name="l00743"></a>00743       <span class="keyword">const</span> _CharT* __data = _M_data();
<a name="l00744"></a>00744 
<a name="l00745"></a>00745       <span class="keywordflow">if</span> (__n == 0)
<a name="l00746"></a>00746     <span class="keywordflow">return</span> __pos &lt;= __size ? __pos : npos;
<a name="l00747"></a>00747 
<a name="l00748"></a>00748       <span class="keywordflow">if</span> (__n &lt;= __size)
<a name="l00749"></a>00749     {
<a name="l00750"></a>00750       <span class="keywordflow">for</span> (; __pos &lt;= __size - __n; ++__pos)
<a name="l00751"></a>00751         <span class="keywordflow">if</span> (traits_type::eq(__data[__pos], __s[0])
<a name="l00752"></a>00752         &amp;&amp; traits_type::compare(__data + __pos + 1,
<a name="l00753"></a>00753                     __s + 1, __n - 1) == 0)
<a name="l00754"></a>00754           <span class="keywordflow">return</span> __pos;
<a name="l00755"></a>00755     }
<a name="l00756"></a>00756       <span class="keywordflow">return</span> npos;
<a name="l00757"></a>00757     }
<a name="l00758"></a>00758 
<a name="l00759"></a>00759   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00760"></a>00760     <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type
<a name="l00761"></a>00761     <a class="code" href="a00427.html#a1ffe7df30c34a410bd75e7cb5b9e352e" title="Find position of a C substring.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00762"></a><a class="code" href="a00427.html#ac66ffc0b14bb47ed2f8fcc8dd242b6de">00762</a> <a class="code" href="a00427.html#a1ffe7df30c34a410bd75e7cb5b9e352e" title="Find position of a C substring.">    find</a>(_CharT __c, size_type __pos) <span class="keyword">const</span> _GLIBCXX_NOEXCEPT
<a name="l00763"></a>00763     {
<a name="l00764"></a>00764       size_type __ret = npos;
<a name="l00765"></a>00765       <span class="keyword">const</span> size_type __size = this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>();
<a name="l00766"></a>00766       <span class="keywordflow">if</span> (__pos &lt; __size)
<a name="l00767"></a>00767     {
<a name="l00768"></a>00768       <span class="keyword">const</span> _CharT* __data = _M_data();
<a name="l00769"></a>00769       <span class="keyword">const</span> size_type __n = __size - __pos;
<a name="l00770"></a>00770       <span class="keyword">const</span> _CharT* __p = traits_type::find(__data + __pos, __n, __c);
<a name="l00771"></a>00771       <span class="keywordflow">if</span> (__p)
<a name="l00772"></a>00772         __ret = __p - __data;
<a name="l00773"></a>00773     }
<a name="l00774"></a>00774       <span class="keywordflow">return</span> __ret;
<a name="l00775"></a>00775     }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00778"></a>00778     <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type
<a name="l00779"></a>00779     <a class="code" href="a00427.html#a14cd1c306c136fe1bda8c4a393451d99" title="Find last position of a string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00780"></a><a class="code" href="a00427.html#ae906f031c7c12f7416202a891552b940">00780</a> <a class="code" href="a00427.html#a14cd1c306c136fe1bda8c4a393451d99" title="Find last position of a string.">    rfind</a>(<span class="keyword">const</span> _CharT* __s, size_type __pos, size_type __n)<span class="keyword"> const</span>
<a name="l00781"></a>00781 <span class="keyword">    </span>{
<a name="l00782"></a>00782       __glibcxx_requires_string_len(__s, __n);
<a name="l00783"></a>00783       <span class="keyword">const</span> size_type __size = this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>();
<a name="l00784"></a>00784       <span class="keywordflow">if</span> (__n &lt;= __size)
<a name="l00785"></a>00785     {
<a name="l00786"></a>00786       __pos = <a class="code" href="a01620.html#ga976d02d45bf6128ae0490642d5961ced" title="This does what you think it does.">std::min</a>(size_type(__size - __n), __pos);
<a name="l00787"></a>00787       <span class="keyword">const</span> _CharT* __data = _M_data();
<a name="l00788"></a>00788       <span class="keywordflow">do</span>
<a name="l00789"></a>00789         {
<a name="l00790"></a>00790           <span class="keywordflow">if</span> (traits_type::compare(__data + __pos, __s, __n) == 0)
<a name="l00791"></a>00791         <span class="keywordflow">return</span> __pos;
<a name="l00792"></a>00792         }
<a name="l00793"></a>00793       <span class="keywordflow">while</span> (__pos-- &gt; 0);
<a name="l00794"></a>00794     }
<a name="l00795"></a>00795       <span class="keywordflow">return</span> npos;
<a name="l00796"></a>00796     }
<a name="l00797"></a>00797 
<a name="l00798"></a>00798   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00799"></a>00799     <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type
<a name="l00800"></a>00800     <a class="code" href="a00427.html#a14cd1c306c136fe1bda8c4a393451d99" title="Find last position of a string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00801"></a><a class="code" href="a00427.html#aac2c92e23a32f0b5d1e27853d3bf2da1">00801</a> <a class="code" href="a00427.html#a14cd1c306c136fe1bda8c4a393451d99" title="Find last position of a string.">    rfind</a>(_CharT __c, size_type __pos) <span class="keyword">const</span> _GLIBCXX_NOEXCEPT
<a name="l00802"></a>00802     {
<a name="l00803"></a>00803       size_type __size = this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>();
<a name="l00804"></a>00804       <span class="keywordflow">if</span> (__size)
<a name="l00805"></a>00805     {
<a name="l00806"></a>00806       <span class="keywordflow">if</span> (--__size &gt; __pos)
<a name="l00807"></a>00807         __size = __pos;
<a name="l00808"></a>00808       <span class="keywordflow">for</span> (++__size; __size-- &gt; 0; )
<a name="l00809"></a>00809         <span class="keywordflow">if</span> (traits_type::eq(_M_data()[__size], __c))
<a name="l00810"></a>00810           <span class="keywordflow">return</span> __size;
<a name="l00811"></a>00811     }
<a name="l00812"></a>00812       <span class="keywordflow">return</span> npos;
<a name="l00813"></a>00813     }
<a name="l00814"></a>00814 
<a name="l00815"></a>00815   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00816"></a>00816     <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type
<a name="l00817"></a>00817     <a class="code" href="a00427.html#a19d47c50ffbafc8460d599bedb3eafeb" title="Find position of a character of string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00818"></a><a class="code" href="a00427.html#a352ce3b3a5031b413eb876f3fed56ec2">00818</a> <a class="code" href="a00427.html#a19d47c50ffbafc8460d599bedb3eafeb" title="Find position of a character of string.">    find_first_of</a>(<span class="keyword">const</span> _CharT* __s, size_type __pos, size_type __n)<span class="keyword"> const</span>
<a name="l00819"></a>00819 <span class="keyword">    </span>{
<a name="l00820"></a>00820       __glibcxx_requires_string_len(__s, __n);
<a name="l00821"></a>00821       <span class="keywordflow">for</span> (; __n &amp;&amp; __pos &lt; this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>(); ++__pos)
<a name="l00822"></a>00822     {
<a name="l00823"></a>00823       <span class="keyword">const</span> _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
<a name="l00824"></a>00824       <span class="keywordflow">if</span> (__p)
<a name="l00825"></a>00825         <span class="keywordflow">return</span> __pos;
<a name="l00826"></a>00826     }
<a name="l00827"></a>00827       <span class="keywordflow">return</span> npos;
<a name="l00828"></a>00828     }
<a name="l00829"></a>00829 
<a name="l00830"></a>00830   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00831"></a>00831     <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type
<a name="l00832"></a>00832     <a class="code" href="a00427.html#a961a660413d0e4574505e3c245244af7" title="Find last position of a character of string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00833"></a><a class="code" href="a00427.html#aebb6de1d7c3b632c69c55b77701d20bc">00833</a> <a class="code" href="a00427.html#a961a660413d0e4574505e3c245244af7" title="Find last position of a character of string.">    find_last_of</a>(<span class="keyword">const</span> _CharT* __s, size_type __pos, size_type __n)<span class="keyword"> const</span>
<a name="l00834"></a>00834 <span class="keyword">    </span>{
<a name="l00835"></a>00835       __glibcxx_requires_string_len(__s, __n);
<a name="l00836"></a>00836       size_type __size = this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>();
<a name="l00837"></a>00837       <span class="keywordflow">if</span> (__size &amp;&amp; __n)
<a name="l00838"></a>00838     {
<a name="l00839"></a>00839       <span class="keywordflow">if</span> (--__size &gt; __pos)
<a name="l00840"></a>00840         __size = __pos;
<a name="l00841"></a>00841       <span class="keywordflow">do</span>
<a name="l00842"></a>00842         {
<a name="l00843"></a>00843           <span class="keywordflow">if</span> (traits_type::find(__s, __n, _M_data()[__size]))
<a name="l00844"></a>00844         <span class="keywordflow">return</span> __size;
<a name="l00845"></a>00845         }
<a name="l00846"></a>00846       <span class="keywordflow">while</span> (__size-- != 0);
<a name="l00847"></a>00847     }
<a name="l00848"></a>00848       <span class="keywordflow">return</span> npos;
<a name="l00849"></a>00849     }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00852"></a>00852     <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type
<a name="l00853"></a>00853     <a class="code" href="a00427.html#a0eee80317268c7f3e9476b2d6f88735e" title="Find position of a character not in string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00854"></a><a class="code" href="a00427.html#a3f012dd02dd7dbb529c896e1a85ed639">00854</a> <a class="code" href="a00427.html#a0eee80317268c7f3e9476b2d6f88735e" title="Find position of a character not in string.">    find_first_not_of</a>(<span class="keyword">const</span> _CharT* __s, size_type __pos, size_type __n)<span class="keyword"> const</span>
<a name="l00855"></a>00855 <span class="keyword">    </span>{
<a name="l00856"></a>00856       __glibcxx_requires_string_len(__s, __n);
<a name="l00857"></a>00857       <span class="keywordflow">for</span> (; __pos &lt; this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>(); ++__pos)
<a name="l00858"></a>00858     <span class="keywordflow">if</span> (!traits_type::find(__s, __n, _M_data()[__pos]))
<a name="l00859"></a>00859       <span class="keywordflow">return</span> __pos;
<a name="l00860"></a>00860       <span class="keywordflow">return</span> npos;
<a name="l00861"></a>00861     }
<a name="l00862"></a>00862 
<a name="l00863"></a>00863   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00864"></a>00864     <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type
<a name="l00865"></a>00865     <a class="code" href="a00427.html#a0eee80317268c7f3e9476b2d6f88735e" title="Find position of a character not in string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00866"></a><a class="code" href="a00427.html#abd6013e7caeb2e46ac6fff67c36b65cc">00866</a> <a class="code" href="a00427.html#a0eee80317268c7f3e9476b2d6f88735e" title="Find position of a character not in string.">    find_first_not_of</a>(_CharT __c, size_type __pos) <span class="keyword">const</span> _GLIBCXX_NOEXCEPT
<a name="l00867"></a>00867     {
<a name="l00868"></a>00868       <span class="keywordflow">for</span> (; __pos &lt; this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>(); ++__pos)
<a name="l00869"></a>00869     <span class="keywordflow">if</span> (!traits_type::eq(_M_data()[__pos], __c))
<a name="l00870"></a>00870       <span class="keywordflow">return</span> __pos;
<a name="l00871"></a>00871       <span class="keywordflow">return</span> npos;
<a name="l00872"></a>00872     }
<a name="l00873"></a>00873 
<a name="l00874"></a>00874   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00875"></a>00875     <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type
<a name="l00876"></a>00876     <a class="code" href="a00427.html#afaf66cf216305c1dec8bb427491ced07" title="Find last position of a character not in string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00877"></a><a class="code" href="a00427.html#a1f4d0fb892d44f4acb10cb624e0c82a8">00877</a> <a class="code" href="a00427.html#afaf66cf216305c1dec8bb427491ced07" title="Find last position of a character not in string.">    find_last_not_of</a>(<span class="keyword">const</span> _CharT* __s, size_type __pos, size_type __n)<span class="keyword"> const</span>
<a name="l00878"></a>00878 <span class="keyword">    </span>{
<a name="l00879"></a>00879       __glibcxx_requires_string_len(__s, __n);
<a name="l00880"></a>00880       size_type __size = this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>();
<a name="l00881"></a>00881       <span class="keywordflow">if</span> (__size)
<a name="l00882"></a>00882     {
<a name="l00883"></a>00883       <span class="keywordflow">if</span> (--__size &gt; __pos)
<a name="l00884"></a>00884         __size = __pos;
<a name="l00885"></a>00885       <span class="keywordflow">do</span>
<a name="l00886"></a>00886         {
<a name="l00887"></a>00887           <span class="keywordflow">if</span> (!traits_type::find(__s, __n, _M_data()[__size]))
<a name="l00888"></a>00888         <span class="keywordflow">return</span> __size;
<a name="l00889"></a>00889         }
<a name="l00890"></a>00890       <span class="keywordflow">while</span> (__size--);
<a name="l00891"></a>00891     }
<a name="l00892"></a>00892       <span class="keywordflow">return</span> npos;
<a name="l00893"></a>00893     }
<a name="l00894"></a>00894 
<a name="l00895"></a>00895   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00896"></a>00896     <span class="keyword">typename</span> basic_string&lt;_CharT, _Traits, _Alloc&gt;::size_type
<a name="l00897"></a>00897     <a class="code" href="a00427.html#afaf66cf216305c1dec8bb427491ced07" title="Find last position of a character not in string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00898"></a><a class="code" href="a00427.html#aed571138bb07392ed48f9c1e68bb321d">00898</a> <a class="code" href="a00427.html#afaf66cf216305c1dec8bb427491ced07" title="Find last position of a character not in string.">    find_last_not_of</a>(_CharT __c, size_type __pos) <span class="keyword">const</span> _GLIBCXX_NOEXCEPT
<a name="l00899"></a>00899     {
<a name="l00900"></a>00900       size_type __size = this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>();
<a name="l00901"></a>00901       <span class="keywordflow">if</span> (__size)
<a name="l00902"></a>00902     {
<a name="l00903"></a>00903       <span class="keywordflow">if</span> (--__size &gt; __pos)
<a name="l00904"></a>00904         __size = __pos;
<a name="l00905"></a>00905       <span class="keywordflow">do</span>
<a name="l00906"></a>00906         {
<a name="l00907"></a>00907           <span class="keywordflow">if</span> (!traits_type::eq(_M_data()[__size], __c))
<a name="l00908"></a>00908         <span class="keywordflow">return</span> __size;
<a name="l00909"></a>00909         }
<a name="l00910"></a>00910       <span class="keywordflow">while</span> (__size--);
<a name="l00911"></a>00911     }
<a name="l00912"></a>00912       <span class="keywordflow">return</span> npos;
<a name="l00913"></a>00913     }
<a name="l00914"></a>00914 
<a name="l00915"></a>00915   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00916"></a>00916     <span class="keywordtype">int</span>
<a name="l00917"></a>00917     <a class="code" href="a00427.html#a206b096f59ca71864c3ad5f80065e582" title="Compare to a string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00918"></a><a class="code" href="a00427.html#a002a19d65e7e25ac94105cd676cbb697">00918</a> <a class="code" href="a00427.html#a206b096f59ca71864c3ad5f80065e582" title="Compare to a string.">    compare</a>(size_type __pos, size_type __n, <span class="keyword">const</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string</a>&amp; __str)<span class="keyword"> const</span>
<a name="l00919"></a>00919 <span class="keyword">    </span>{
<a name="l00920"></a>00920       _M_check(__pos, <span class="stringliteral">&quot;basic_string::compare&quot;</span>);
<a name="l00921"></a>00921       __n = _M_limit(__pos, __n);
<a name="l00922"></a>00922       <span class="keyword">const</span> size_type __osize = __str.<a class="code" href="a00427.html#a76116ea8b9ef4566f47a7e264f35fac1" title="Returns the number of characters in the string, not including any null-termination.">size</a>();
<a name="l00923"></a>00923       <span class="keyword">const</span> size_type __len = <a class="code" href="a01620.html#ga976d02d45bf6128ae0490642d5961ced" title="This does what you think it does.">std::min</a>(__n, __osize);
<a name="l00924"></a>00924       <span class="keywordtype">int</span> __r = traits_type::compare(_M_data() + __pos, __str.<a class="code" href="a00427.html#ab54e9b3927259a9bf169e70196a6606f" title="Return const pointer to contents.">data</a>(), __len);
<a name="l00925"></a>00925       <span class="keywordflow">if</span> (!__r)
<a name="l00926"></a>00926     __r = _S_compare(__n, __osize);
<a name="l00927"></a>00927       <span class="keywordflow">return</span> __r;
<a name="l00928"></a>00928     }
<a name="l00929"></a>00929 
<a name="l00930"></a>00930   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00931"></a>00931     <span class="keywordtype">int</span>
<a name="l00932"></a>00932     <a class="code" href="a00427.html#a206b096f59ca71864c3ad5f80065e582" title="Compare to a string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00933"></a><a class="code" href="a00427.html#afe1b78bc84a4947366d8c18a51a5c701">00933</a> <a class="code" href="a00427.html#a206b096f59ca71864c3ad5f80065e582" title="Compare to a string.">    compare</a>(size_type __pos1, size_type __n1, <span class="keyword">const</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string</a>&amp; __str,
<a name="l00934"></a>00934         size_type __pos2, size_type __n2)<span class="keyword"> const</span>
<a name="l00935"></a>00935 <span class="keyword">    </span>{
<a name="l00936"></a>00936       _M_check(__pos1, <span class="stringliteral">&quot;basic_string::compare&quot;</span>);
<a name="l00937"></a>00937       __str._M_check(__pos2, <span class="stringliteral">&quot;basic_string::compare&quot;</span>);
<a name="l00938"></a>00938       __n1 = _M_limit(__pos1, __n1);
<a name="l00939"></a>00939       __n2 = __str._M_limit(__pos2, __n2);
<a name="l00940"></a>00940       <span class="keyword">const</span> size_type __len = <a class="code" href="a01620.html#ga976d02d45bf6128ae0490642d5961ced" title="This does what you think it does.">std::min</a>(__n1, __n2);
<a name="l00941"></a>00941       <span class="keywordtype">int</span> __r = traits_type::compare(_M_data() + __pos1,
<a name="l00942"></a>00942                      __str.<a class="code" href="a00427.html#ab54e9b3927259a9bf169e70196a6606f" title="Return const pointer to contents.">data</a>() + __pos2, __len);
<a name="l00943"></a>00943       <span class="keywordflow">if</span> (!__r)
<a name="l00944"></a>00944     __r = _S_compare(__n1, __n2);
<a name="l00945"></a>00945       <span class="keywordflow">return</span> __r;
<a name="l00946"></a>00946     }
<a name="l00947"></a>00947 
<a name="l00948"></a>00948   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00949"></a>00949     <span class="keywordtype">int</span>
<a name="l00950"></a>00950     <a class="code" href="a00427.html#a206b096f59ca71864c3ad5f80065e582" title="Compare to a string.">basic_string&lt;_CharT, _Traits, _Alloc&gt;::</a>
<a name="l00951"></a><a class="code" href="a00427.html#a8d6cd99c40dfe562d55a0e001ac4930f">00951</a> <a class="code" href="a00427.html#a206b096f59ca71864c3ad5f80065e582" title="Compare to a string.">    compare</a>(<span class="keyword">const</span> _CharT* __s)<span class="keyword"> const</span>
<a name="l00952"></a>00952 <span class="keyword">    </span>{
<a name="l00953"></a>00953       __glibcxx_requires_string(__s);
<a name="l00954"></a>00954       <span class="keyword">const</span> size_type __size = this-&gt;<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>();
<a name="l00955"></a>00955       <span class="keyword">const</span> size_type __osize = traits_type::length(__s);
<a name="l00956"></a>00956       <span class="keyword">const</span> size_type __len = <a class="code" href="a01620.html#ga976d02d45bf6128ae0490642d5961ced" title="This does what you think it does.">std::min</a>(__size, __osize);
<a name="l00957"></a>00957       <span class="keywordtype">int</span> __r = traits_type::compare(_M_data(), __s, __len);
<a name="l00958"></a>00958       <span class="keywordflow">if</span> (!__r)
<a name="l00959"></a>00959     __r = _S_compare(__size, __osize);
<a name="l00960"></a>00960       <span class="keywordflow">return</span> __r;
<a name="l00961"></a>00961     }
<a name="l00962"></a>00962 
<a name="l00963"></a>00963   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00964"></a>00964     <span class="keywordtype">int</span>
<a name="l00965"></a>00965     <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string &lt;_CharT, _Traits, _Alloc&gt;</a>::
<a name="l00966"></a><a class="code" href="a00427.html#adc959f0d29b0da95643a697f3ca097fd">00966</a>     compare(size_type __pos, size_type __n1, <span class="keyword">const</span> _CharT* __s)<span class="keyword"> const</span>
<a name="l00967"></a>00967 <span class="keyword">    </span>{
<a name="l00968"></a>00968       __glibcxx_requires_string(__s);
<a name="l00969"></a>00969       _M_check(__pos, <span class="stringliteral">&quot;basic_string::compare&quot;</span>);
<a name="l00970"></a>00970       __n1 = _M_limit(__pos, __n1);
<a name="l00971"></a>00971       <span class="keyword">const</span> size_type __osize = traits_type::length(__s);
<a name="l00972"></a>00972       <span class="keyword">const</span> size_type __len = <a class="code" href="a01620.html#ga976d02d45bf6128ae0490642d5961ced" title="This does what you think it does.">std::min</a>(__n1, __osize);
<a name="l00973"></a>00973       <span class="keywordtype">int</span> __r = traits_type::compare(_M_data() + __pos, __s, __len);
<a name="l00974"></a>00974       <span class="keywordflow">if</span> (!__r)
<a name="l00975"></a>00975     __r = _S_compare(__n1, __osize);
<a name="l00976"></a>00976       <span class="keywordflow">return</span> __r;
<a name="l00977"></a>00977     }
<a name="l00978"></a>00978 
<a name="l00979"></a>00979   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00980"></a>00980     <span class="keywordtype">int</span>
<a name="l00981"></a>00981     <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string &lt;_CharT, _Traits, _Alloc&gt;</a>::
<a name="l00982"></a><a class="code" href="a00427.html#ab60ce3cbc0fd1a7dee323f7ef6a47c47">00982</a>     compare(size_type __pos, size_type __n1, <span class="keyword">const</span> _CharT* __s,
<a name="l00983"></a>00983         size_type __n2)<span class="keyword"> const</span>
<a name="l00984"></a>00984 <span class="keyword">    </span>{
<a name="l00985"></a>00985       __glibcxx_requires_string_len(__s, __n2);
<a name="l00986"></a>00986       _M_check(__pos, <span class="stringliteral">&quot;basic_string::compare&quot;</span>);
<a name="l00987"></a>00987       __n1 = _M_limit(__pos, __n1);
<a name="l00988"></a>00988       <span class="keyword">const</span> size_type __len = <a class="code" href="a01620.html#ga976d02d45bf6128ae0490642d5961ced" title="This does what you think it does.">std::min</a>(__n1, __n2);
<a name="l00989"></a>00989       <span class="keywordtype">int</span> __r = traits_type::compare(_M_data() + __pos, __s, __len);
<a name="l00990"></a>00990       <span class="keywordflow">if</span> (!__r)
<a name="l00991"></a>00991     __r = _S_compare(__n1, __n2);
<a name="l00992"></a>00992       <span class="keywordflow">return</span> __r;
<a name="l00993"></a>00993     }
<a name="l00994"></a>00994 
<a name="l00995"></a>00995   <span class="comment">// 21.3.7.9 basic_string::getline and operators</span>
<a name="l00996"></a>00996   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l00997"></a>00997     <a class="code" href="a00424.html" title="Template class basic_istream.This is the base class for all input streams. It provides text formattin...">basic_istream&lt;_CharT, _Traits&gt;</a>&amp;
<a name="l00998"></a><a class="code" href="a01576.html#a6447193cb914c78fb13064c210e26ed8">00998</a>     <a class="code" href="a01576.html#a2688809debdd41b83821f4f09b087047" title="Self-explanatory.">operator&gt;&gt;</a>(<a class="code" href="a00424.html" title="Template class basic_istream.This is the base class for all input streams. It provides text formattin...">basic_istream&lt;_CharT, _Traits&gt;</a>&amp; __in,
<a name="l00999"></a>00999            <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a>&amp; __str)
<a name="l01000"></a>01000     {
<a name="l01001"></a>01001       <span class="keyword">typedef</span> <a class="code" href="a00424.html" title="Template class basic_istream.This is the base class for all input streams. It provides text formattin...">basic_istream&lt;_CharT, _Traits&gt;</a>        __istream_type;
<a name="l01002"></a>01002       <span class="keyword">typedef</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a> __string_type;
<a name="l01003"></a>01003       <span class="keyword">typedef</span> <span class="keyword">typename</span> __istream_type::ios_base         __ios_base;
<a name="l01004"></a>01004       <span class="keyword">typedef</span> <span class="keyword">typename</span> __istream_type::int_type     __int_type;
<a name="l01005"></a>01005       <span class="keyword">typedef</span> <span class="keyword">typename</span> __string_type::size_type     __size_type;
<a name="l01006"></a>01006       <span class="keyword">typedef</span> <a class="code" href="a00614.html" title="Primary class template ctype facet.This template class defines classification and conversion function...">ctype&lt;_CharT&gt;</a>             __ctype_type;
<a name="l01007"></a>01007       <span class="keyword">typedef</span> <span class="keyword">typename</span> __ctype_type::ctype_base         __ctype_base;
<a name="l01008"></a>01008 
<a name="l01009"></a>01009       __size_type __extracted = 0;
<a name="l01010"></a>01010       <span class="keyword">typename</span> __ios_base::iostate __err = __ios_base::goodbit;
<a name="l01011"></a>01011       <span class="keyword">typename</span> __istream_type::sentry __cerb(__in, <span class="keyword">false</span>);
<a name="l01012"></a>01012       <span class="keywordflow">if</span> (__cerb)
<a name="l01013"></a>01013     {
<a name="l01014"></a>01014       __try
<a name="l01015"></a>01015         {
<a name="l01016"></a>01016           <span class="comment">// Avoid reallocation for common case.</span>
<a name="l01017"></a>01017           __str.<a class="code" href="a00427.html#ad0c376cb963e61712842490d44d53a74" title="Remove characters.">erase</a>();
<a name="l01018"></a>01018           _CharT __buf[128];
<a name="l01019"></a>01019           __size_type __len = 0;          
<a name="l01020"></a>01020           <span class="keyword">const</span> <a class="code" href="a01576.html#a05eef5582eb5de62b76db4916f7adb84" title="Integral type for I/O operation counts and buffer sizes.">streamsize</a> __w = __in.<a class="code" href="a00712.html#a2e2a333f56f4b02b164ad4eb0db08221" title="Flags access.">width</a>();
<a name="l01021"></a>01021           <span class="keyword">const</span> __size_type __n = __w &gt; 0 ? <span class="keyword">static_cast&lt;</span>__size_type<span class="keyword">&gt;</span>(__w)
<a name="l01022"></a>01022                                       : __str.<a class="code" href="a00427.html#a0f1f8e2af06947d1bc517a4192766fb9" title="Returns the size() of the largest possible string.">max_size</a>();
<a name="l01023"></a>01023           <span class="keyword">const</span> __ctype_type&amp; __ct = use_facet&lt;__ctype_type&gt;(__in.<a class="code" href="a00712.html#a1efb9c3c7dbd68a2aa13d601c8c81f3b" title="Locale access.">getloc</a>());
<a name="l01024"></a>01024           <span class="keyword">const</span> __int_type __eof = _Traits::eof();
<a name="l01025"></a>01025           __int_type __c = __in.<a class="code" href="a00422.html#a9cd5ec67e6304e384f3884a6f0b38554" title="Accessing the underlying buffer.">rdbuf</a>()-&gt;sgetc();
<a name="l01026"></a>01026 
<a name="l01027"></a>01027           <span class="keywordflow">while</span> (__extracted &lt; __n
<a name="l01028"></a>01028              &amp;&amp; !_Traits::eq_int_type(__c, __eof)
<a name="l01029"></a>01029              &amp;&amp; !__ct.is(__ctype_base::space,
<a name="l01030"></a>01030                  _Traits::to_char_type(__c)))
<a name="l01031"></a>01031         {
<a name="l01032"></a>01032           <span class="keywordflow">if</span> (__len == <span class="keyword">sizeof</span>(__buf) / <span class="keyword">sizeof</span>(_CharT))
<a name="l01033"></a>01033             {
<a name="l01034"></a>01034               __str.<a class="code" href="a00427.html#a93795d6e4ab56974a69099a52726c1e1" title="Append a string to this string.">append</a>(__buf, <span class="keyword">sizeof</span>(__buf) / <span class="keyword">sizeof</span>(_CharT));
<a name="l01035"></a>01035               __len = 0;
<a name="l01036"></a>01036             }
<a name="l01037"></a>01037           __buf[__len++] = _Traits::to_char_type(__c);
<a name="l01038"></a>01038           ++__extracted;
<a name="l01039"></a>01039           __c = __in.<a class="code" href="a00422.html#a9cd5ec67e6304e384f3884a6f0b38554" title="Accessing the underlying buffer.">rdbuf</a>()-&gt;snextc();
<a name="l01040"></a>01040         }
<a name="l01041"></a>01041           __str.<a class="code" href="a00427.html#a93795d6e4ab56974a69099a52726c1e1" title="Append a string to this string.">append</a>(__buf, __len);
<a name="l01042"></a>01042 
<a name="l01043"></a>01043           <span class="keywordflow">if</span> (_Traits::eq_int_type(__c, __eof))
<a name="l01044"></a>01044         __err |= __ios_base::eofbit;
<a name="l01045"></a>01045           __in.<a class="code" href="a00712.html#a2e2a333f56f4b02b164ad4eb0db08221" title="Flags access.">width</a>(0);
<a name="l01046"></a>01046         }
<a name="l01047"></a>01047       __catch(<a class="code" href="a00005.html" title="Thrown as part of forced unwinding.A magic placeholder class that can be caught by reference to recog...">__cxxabiv1::__forced_unwind</a>&amp;)
<a name="l01048"></a>01048         {
<a name="l01049"></a>01049           __in._M_setstate(__ios_base::badbit);
<a name="l01050"></a>01050           __throw_exception_again;
<a name="l01051"></a>01051         }
<a name="l01052"></a>01052       __catch(...)
<a name="l01053"></a>01053         {
<a name="l01054"></a>01054           <span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span>
<a name="l01055"></a>01055           <span class="comment">// 91. Description of operator&gt;&gt; and getline() for string&lt;&gt;</span>
<a name="l01056"></a>01056           <span class="comment">// might cause endless loop</span>
<a name="l01057"></a>01057           __in._M_setstate(__ios_base::badbit);
<a name="l01058"></a>01058         }
<a name="l01059"></a>01059     }
<a name="l01060"></a>01060       <span class="comment">// 211.  operator&gt;&gt;(istream&amp;, string&amp;) doesn&#39;t set failbit</span>
<a name="l01061"></a>01061       <span class="keywordflow">if</span> (!__extracted)
<a name="l01062"></a>01062     __err |= __ios_base::failbit;
<a name="l01063"></a>01063       <span class="keywordflow">if</span> (__err)
<a name="l01064"></a>01064     __in.<a class="code" href="a00422.html#a2da7d3305cba0695b1d1bec916ae64b0" title="Sets additional flags in the error state.">setstate</a>(__err);
<a name="l01065"></a>01065       <span class="keywordflow">return</span> __in;
<a name="l01066"></a>01066     }
<a name="l01067"></a>01067 
<a name="l01068"></a>01068   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _CharT, <span class="keyword">typename</span> _Traits, <span class="keyword">typename</span> _Alloc&gt;
<a name="l01069"></a>01069     basic_istream&lt;_CharT, _Traits&gt;&amp;
<a name="l01070"></a><a class="code" href="a01576.html#a3590b5fa48da4e75fbf0054287e3a46b">01070</a>     <a class="code" href="a01576.html#a3590b5fa48da4e75fbf0054287e3a46b" title="Read a line from stream into a string.">getline</a>(<a class="code" href="a00424.html" title="Template class basic_istream.This is the base class for all input streams. It provides text formattin...">basic_istream&lt;_CharT, _Traits&gt;</a>&amp; __in,
<a name="l01071"></a>01071         <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a>&amp; __str, _CharT __delim)
<a name="l01072"></a>01072     {
<a name="l01073"></a>01073       <span class="keyword">typedef</span> <a class="code" href="a00424.html" title="Template class basic_istream.This is the base class for all input streams. It provides text formattin...">basic_istream&lt;_CharT, _Traits&gt;</a>        __istream_type;
<a name="l01074"></a>01074       <span class="keyword">typedef</span> <a class="code" href="a00427.html" title="Managing sequences of characters and character-like objects.">basic_string&lt;_CharT, _Traits, _Alloc&gt;</a> __string_type;
<a name="l01075"></a>01075       <span class="keyword">typedef</span> <span class="keyword">typename</span> __istream_type::ios_base         __ios_base;
<a name="l01076"></a>01076       <span class="keyword">typedef</span> <span class="keyword">typename</span> __istream_type::int_type     __int_type;
<a name="l01077"></a>01077       <span class="keyword">typedef</span> <span class="keyword">typename</span> __string_type::size_type     __size_type;
<a name="l01078"></a>01078 
<a name="l01079"></a>01079       __size_type __extracted = 0;
<a name="l01080"></a>01080       <span class="keyword">const</span> __size_type __n = __str.<a class="code" href="a00427.html#a0f1f8e2af06947d1bc517a4192766fb9" title="Returns the size() of the largest possible string.">max_size</a>();
<a name="l01081"></a>01081       <span class="keyword">typename</span> __ios_base::iostate __err = __ios_base::goodbit;
<a name="l01082"></a>01082       <span class="keyword">typename</span> __istream_type::sentry __cerb(__in, <span class="keyword">true</span>);
<a name="l01083"></a>01083       <span class="keywordflow">if</span> (__cerb)
<a name="l01084"></a>01084     {
<a name="l01085"></a>01085       __try
<a name="l01086"></a>01086         {
<a name="l01087"></a>01087           __str.<a class="code" href="a00427.html#ad0c376cb963e61712842490d44d53a74" title="Remove characters.">erase</a>();
<a name="l01088"></a>01088           <span class="keyword">const</span> __int_type __idelim = _Traits::to_int_type(__delim);
<a name="l01089"></a>01089           <span class="keyword">const</span> __int_type __eof = _Traits::eof();
<a name="l01090"></a>01090           __int_type __c = __in.<a class="code" href="a00422.html#a9cd5ec67e6304e384f3884a6f0b38554" title="Accessing the underlying buffer.">rdbuf</a>()-&gt;sgetc();
<a name="l01091"></a>01091 
<a name="l01092"></a>01092           <span class="keywordflow">while</span> (__extracted &lt; __n
<a name="l01093"></a>01093              &amp;&amp; !_Traits::eq_int_type(__c, __eof)
<a name="l01094"></a>01094              &amp;&amp; !_Traits::eq_int_type(__c, __idelim))
<a name="l01095"></a>01095         {
<a name="l01096"></a>01096           __str += _Traits::to_char_type(__c);
<a name="l01097"></a>01097           ++__extracted;
<a name="l01098"></a>01098           __c = __in.<a class="code" href="a00422.html#a9cd5ec67e6304e384f3884a6f0b38554" title="Accessing the underlying buffer.">rdbuf</a>()-&gt;snextc();
<a name="l01099"></a>01099         }
<a name="l01100"></a>01100 
<a name="l01101"></a>01101           <span class="keywordflow">if</span> (_Traits::eq_int_type(__c, __eof))
<a name="l01102"></a>01102         __err |= __ios_base::eofbit;
<a name="l01103"></a>01103           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_Traits::eq_int_type(__c, __idelim))
<a name="l01104"></a>01104         {
<a name="l01105"></a>01105           ++__extracted;          
<a name="l01106"></a>01106           __in.<a class="code" href="a00422.html#a9cd5ec67e6304e384f3884a6f0b38554" title="Accessing the underlying buffer.">rdbuf</a>()-&gt;sbumpc();
<a name="l01107"></a>01107         }
<a name="l01108"></a>01108           <span class="keywordflow">else</span>
<a name="l01109"></a>01109         __err |= __ios_base::failbit;
<a name="l01110"></a>01110         }
<a name="l01111"></a>01111       __catch(<a class="code" href="a00005.html" title="Thrown as part of forced unwinding.A magic placeholder class that can be caught by reference to recog...">__cxxabiv1::__forced_unwind</a>&amp;)
<a name="l01112"></a>01112         {
<a name="l01113"></a>01113           __in._M_setstate(__ios_base::badbit);
<a name="l01114"></a>01114           __throw_exception_again;
<a name="l01115"></a>01115         }
<a name="l01116"></a>01116       __catch(...)
<a name="l01117"></a>01117         {
<a name="l01118"></a>01118           <span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span>
<a name="l01119"></a>01119           <span class="comment">// 91. Description of operator&gt;&gt; and getline() for string&lt;&gt;</span>
<a name="l01120"></a>01120           <span class="comment">// might cause endless loop</span>
<a name="l01121"></a>01121           __in._M_setstate(__ios_base::badbit);
<a name="l01122"></a>01122         }
<a name="l01123"></a>01123     }
<a name="l01124"></a>01124       <span class="keywordflow">if</span> (!__extracted)
<a name="l01125"></a>01125     __err |= __ios_base::failbit;
<a name="l01126"></a>01126       <span class="keywordflow">if</span> (__err)
<a name="l01127"></a>01127     __in.<a class="code" href="a00422.html#a2da7d3305cba0695b1d1bec916ae64b0" title="Sets additional flags in the error state.">setstate</a>(__err);
<a name="l01128"></a>01128       <span class="keywordflow">return</span> __in;
<a name="l01129"></a>01129     }
<a name="l01130"></a>01130 
<a name="l01131"></a>01131   <span class="comment">// Inhibit implicit instantiations for required instantiations,</span>
<a name="l01132"></a>01132   <span class="comment">// which are defined via explicit instantiations elsewhere.</span>
<a name="l01133"></a>01133 <span class="preprocessor">#if _GLIBCXX_EXTERN_TEMPLATE &gt; 0</span>
<a name="l01134"></a>01134 <span class="preprocessor"></span>  <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>basic_string&lt;char&gt;;
<a name="l01135"></a>01135   <span class="keyword">extern</span> <span class="keyword">template</span>
<a name="l01136"></a>01136     basic_istream&lt;char&gt;&amp;
<a name="l01137"></a>01137     <a class="code" href="a01576.html#a2688809debdd41b83821f4f09b087047" title="Self-explanatory.">operator&gt;&gt;</a>(basic_istream&lt;char&gt;&amp;, <span class="keywordtype">string</span>&amp;);
<a name="l01138"></a>01138   <span class="keyword">extern</span> <span class="keyword">template</span>
<a name="l01139"></a>01139     basic_ostream&lt;char&gt;&amp;
<a name="l01140"></a>01140     operator&lt;&lt;(basic_ostream&lt;char&gt;&amp;, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp;);
<a name="l01141"></a>01141   <span class="keyword">extern</span> <span class="keyword">template</span>
<a name="l01142"></a>01142     basic_istream&lt;char&gt;&amp;
<a name="l01143"></a>01143     <a class="code" href="a01576.html#a3590b5fa48da4e75fbf0054287e3a46b" title="Read a line from stream into a string.">getline</a>(basic_istream&lt;char&gt;&amp;, <span class="keywordtype">string</span>&amp;, <span class="keywordtype">char</span>);
<a name="l01144"></a>01144   <span class="keyword">extern</span> <span class="keyword">template</span>
<a name="l01145"></a>01145     basic_istream&lt;char&gt;&amp;
<a name="l01146"></a>01146     <a class="code" href="a01576.html#a3590b5fa48da4e75fbf0054287e3a46b" title="Read a line from stream into a string.">getline</a>(basic_istream&lt;char&gt;&amp;, <span class="keywordtype">string</span>&amp;);
<a name="l01147"></a>01147 
<a name="l01148"></a>01148 <span class="preprocessor">#ifdef _GLIBCXX_USE_WCHAR_T</span>
<a name="l01149"></a>01149 <span class="preprocessor"></span>  <span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">class </span>basic_string&lt;wchar_t&gt;;
<a name="l01150"></a>01150   <span class="keyword">extern</span> <span class="keyword">template</span>
<a name="l01151"></a>01151     basic_istream&lt;wchar_t&gt;&amp;
<a name="l01152"></a>01152     <a class="code" href="a01576.html#a2688809debdd41b83821f4f09b087047" title="Self-explanatory.">operator&gt;&gt;</a>(basic_istream&lt;wchar_t&gt;&amp;, wstring&amp;);
<a name="l01153"></a>01153   <span class="keyword">extern</span> <span class="keyword">template</span>
<a name="l01154"></a>01154     basic_ostream&lt;wchar_t&gt;&amp;
<a name="l01155"></a>01155     operator&lt;&lt;(basic_ostream&lt;wchar_t&gt;&amp;, <span class="keyword">const</span> wstring&amp;);
<a name="l01156"></a>01156   <span class="keyword">extern</span> <span class="keyword">template</span>
<a name="l01157"></a>01157     basic_istream&lt;wchar_t&gt;&amp;
<a name="l01158"></a>01158     <a class="code" href="a01576.html#a3590b5fa48da4e75fbf0054287e3a46b" title="Read a line from stream into a string.">getline</a>(basic_istream&lt;wchar_t&gt;&amp;, wstring&amp;, <span class="keywordtype">wchar_t</span>);
<a name="l01159"></a>01159   <span class="keyword">extern</span> <span class="keyword">template</span>
<a name="l01160"></a>01160     basic_istream&lt;wchar_t&gt;&amp;
<a name="l01161"></a>01161     <a class="code" href="a01576.html#a3590b5fa48da4e75fbf0054287e3a46b" title="Read a line from stream into a string.">getline</a>(basic_istream&lt;wchar_t&gt;&amp;, wstring&amp;);
<a name="l01162"></a>01162 <span class="preprocessor">#endif</span>
<a name="l01163"></a>01163 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01164"></a>01164 <span class="preprocessor"></span>
<a name="l01165"></a>01165 _GLIBCXX_END_NAMESPACE_VERSION
<a name="l01166"></a>01166 } <span class="comment">// namespace std</span>
<a name="l01167"></a>01167 
<a name="l01168"></a>01168 <span class="preprocessor">#endif</span>
</pre></div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a00971.html">basic_string.tcc</a>      </li>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
