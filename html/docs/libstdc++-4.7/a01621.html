<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libstdc++: Set Operation</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a01621.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Set Operation</div>  </div>
<div class="ingroups"><a class="el" href="a01620.html">Sorting</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Set Operation:</div>
<div class="dyncontent">
<center><table><tr><td><img src="a01621.png" border="0" alt="" usemap="#a01621"/>
<map name="a01621" id="a01621">
<area shape="rect" id="node2" href="a01620.html" title="Sorting" alt="" coords="5,5,72,33"/></map>
</td></tr></table></center>
</div>
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li>template&lt;typename _InputIterator1 , typename _InputIterator2 &gt; bool <a class="el" href="a01621.html#ga67c9386f01daa7763952b9096ab94c96">std::includes</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)
<li>template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _Compare &gt; bool <a class="el" href="a01621.html#gaeffeb80fabc63883a4d5e907ca922913">std::includes</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)
<li>template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; _OutputIterator <a class="el" href="a01621.html#ga35787a357982adc415c29c036f7aada7">std::set_difference</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
<li>template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; _OutputIterator <a class="el" href="a01621.html#ga7cbebc70e1550ea9939c9269d7c7c289">std::set_difference</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
<li>template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; _OutputIterator <a class="el" href="a01621.html#gad7a7b81513c68b856c0a2699c29532d0">std::set_intersection</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
<li>template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; _OutputIterator <a class="el" href="a01621.html#ga63b5280a2c5009456a51d38084ce1062">std::set_intersection</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
<li>template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; _OutputIterator <a class="el" href="a01621.html#ga3b7e12cbdb1a0d4e7691e9730e1924c5">std::set_symmetric_difference</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
<li>template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; _OutputIterator <a class="el" href="a01621.html#gabd18017e018c3090eacd4509e28cc432">std::set_symmetric_difference</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
<li>template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; _OutputIterator <a class="el" href="a01621.html#ga45c2e77ca73dabf6b1ccabbecf0291a6">std::set_union</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
<li>template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; _OutputIterator <a class="el" href="a01621.html#ga3d54d31bc70a0ff4596f5171ec728906">std::set_union</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>These algorithms are common set operations performed on sequences that are already sorted. The number of comparisons will be linear. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga67c9386f01daa7763952b9096ab94c96"></a><!-- doxytag: member="std::includes" ref="ga67c9386f01daa7763952b9096ab94c96" args="(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::includes </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether all elements of a sequence exists in a range. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of search range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of search range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if each element in [__first2,__last2) is contained in order within [__first1,__last1). False otherwise.</dd></dl>
<p>This operation expects both [__first1,__last1) and [__first2,__last2) to be sorted. Searches for the presence of each element in [__first2,__last2) within [__first1,__last1). The iterators over each range only move forward, so this is a linear algorithm. If an element in [__first2,__last2) is not found before the search iterator reaches <code>__last2</code>, false is returned. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l03574">3574</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaeffeb80fabc63883a4d5e907ca922913"></a><!-- doxytag: member="std::includes" ref="gaeffeb80fabc63883a4d5e907ca922913" args="(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::includes </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether all elements of a sequence exists in a range using comparison. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of search range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of search range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of sequence </td></tr>
    <tr><td class="paramname">__last2</td><td>End of sequence. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison function to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if each element in [__first2,__last2) is contained in order within [__first1,__last1) according to comp. False otherwise.</dd></dl>
<p>This operation expects both [__first1,__last1) and [__first2,__last2) to be sorted. Searches for the presence of each element in [__first2,__last2) within [__first1,__last1), using comp to decide. The iterators over each range only move forward, so this is a linear algorithm. If an element in [__first2,__last2) is not found before the search iterator reaches <code>__last2</code>, false is returned. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l03625">3625</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga35787a357982adc415c29c036f7aada7"></a><!-- doxytag: member="std::set_difference" ref="ga35787a357982adc415c29c036f7aada7" args="(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_difference </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the difference of two sorted ranges. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range. Iterators increment for each range. When the current element of the first range is less than the second, that element is copied and the iterator advances. If the current element of the second range is less, the iterator advances, but no element is copied. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l06003">6003</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7cbebc70e1550ea9939c9269d7c7c289"></a><!-- doxytag: member="std::set_difference" ref="ga7cbebc70e1550ea9939c9269d7c7c289" args="(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_difference </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the difference of two sorted ranges using comparison functor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in the first range but not the second in order to the output range. Iterators increment for each range. When the current element of the first range is less than the second according to <code>__comp</code>, that element is copied and the iterator advances. If the current element of the second range is less, no element is copied and the iterator advances. If an element is contained in both ranges according to <code>__comp</code>, no elements are copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l06064">6064</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gad7a7b81513c68b856c0a2699c29532d0"></a><!-- doxytag: member="std::set_intersection" ref="gad7a7b81513c68b856c0a2699c29532d0" args="(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_intersection </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the intersection of two sorted ranges. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that iterator advances. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05888">5888</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga63b5280a2c5009456a51d38084ce1062"></a><!-- doxytag: member="std::set_intersection" ref="ga63b5280a2c5009456a51d38084ce1062" args="(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_intersection </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the intersection of two sorted ranges using comparison functor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in both ranges in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to <code>__comp</code>, that iterator advances. If an element is contained in both ranges according to <code>__comp</code>, the element from the first range is copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05945">5945</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3b7e12cbdb1a0d4e7691e9730e1924c5"></a><!-- doxytag: member="std::set_symmetric_difference" ref="ga3b7e12cbdb1a0d4e7691e9730e1924c5" args="(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the symmetric difference of two sorted ranges. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advances. If an element is contained in both ranges, no elements are copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l06122">6122</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gabd18017e018c3090eacd4509e28cc432"></a><!-- doxytag: member="std::set_symmetric_difference" ref="gabd18017e018c3090eacd4509e28cc432" args="(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_symmetric_difference </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the symmetric difference of two sorted ranges using comparison functor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in one range but not the other in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to <code>comp</code>, that element is copied and the iterator advances. If an element is contained in both ranges according to <code>__comp</code>, no elements are copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l06188">6188</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga45c2e77ca73dabf6b1ccabbecf0291a6"></a><!-- doxytag: member="std::set_union" ref="ga45c2e77ca73dabf6b1ccabbecf0291a6" args="(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_union </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the union of two sorted ranges. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other, that element is copied and the iterator advanced. If an element is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05754">5754</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3d54d31bc70a0ff4596f5171ec728906"></a><!-- doxytag: member="std::set_union" ref="ga3d54d31bc70a0ff4596f5171ec728906" args="(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::set_union </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the union of two sorted ranges using a comparison functor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>Start of first range. </td></tr>
    <tr><td class="paramname">__last1</td><td>End of first range. </td></tr>
    <tr><td class="paramname">__first2</td><td>Start of second range. </td></tr>
    <tr><td class="paramname">__last2</td><td>End of second range. </td></tr>
    <tr><td class="paramname">__comp</td><td>The comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>End of the output range.</dd></dl>
<p>This operation iterates over both ranges, copying elements present in each range in order to the output range. Iterators increment for each range. When the current element of one range is less than the other according to <code>__comp</code>, that element is copied and the iterator advanced. If an equivalent element according to <code>__comp</code> is contained in both ranges, the element from the first range is copied and both ranges advance. The output range may not overlap either input range. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05821">5821</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
