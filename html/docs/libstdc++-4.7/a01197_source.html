<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libstdc++: hashtable.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a01197.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">bits/hashtable.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="a01197.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// hashtable.h header -*- C++ -*-</span>
<a name="l00002"></a>00002 
<a name="l00003"></a>00003 <span class="comment">// Copyright (C) 2007, 2008, 2009, 2010, 2011, 2012, 2013</span>
<a name="l00004"></a>00004 <span class="comment">// Free Software Foundation, Inc.</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment">// This file is part of the GNU ISO C++ Library.  This library is free</span>
<a name="l00007"></a>00007 <span class="comment">// software; you can redistribute it and/or modify it under the</span>
<a name="l00008"></a>00008 <span class="comment">// terms of the GNU General Public License as published by the</span>
<a name="l00009"></a>00009 <span class="comment">// Free Software Foundation; either version 3, or (at your option)</span>
<a name="l00010"></a>00010 <span class="comment">// any later version.</span>
<a name="l00011"></a>00011 
<a name="l00012"></a>00012 <span class="comment">// This library is distributed in the hope that it will be useful,</span>
<a name="l00013"></a>00013 <span class="comment">// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<a name="l00014"></a>00014 <span class="comment">// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<a name="l00015"></a>00015 <span class="comment">// GNU General Public License for more details.</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="comment">// Under Section 7 of GPL version 3, you are granted additional</span>
<a name="l00018"></a>00018 <span class="comment">// permissions described in the GCC Runtime Library Exception, version</span>
<a name="l00019"></a>00019 <span class="comment">// 3.1, as published by the Free Software Foundation.</span>
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="comment">// You should have received a copy of the GNU General Public License and</span>
<a name="l00022"></a>00022 <span class="comment">// a copy of the GCC Runtime Library Exception along with this program;</span>
<a name="l00023"></a>00023 <span class="comment">// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see</span>
<a name="l00024"></a>00024 <span class="comment">// &lt;http://www.gnu.org/licenses/&gt;.</span>
<a name="l00025"></a>00025 <span class="comment"></span>
<a name="l00026"></a>00026 <span class="comment">/** @file bits/hashtable.h</span>
<a name="l00027"></a>00027 <span class="comment"> *  This is an internal header file, included by other library headers.</span>
<a name="l00028"></a>00028 <span class="comment"> *  Do not attempt to use it directly. @headername{unordered_map, unordered_set}</span>
<a name="l00029"></a>00029 <span class="comment"> */</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#ifndef _HASHTABLE_H</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#define _HASHTABLE_H 1</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span>
<a name="l00034"></a>00034 <span class="preprocessor">#pragma GCC system_header</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;<a class="code" href="a01199.html">bits/hashtable_policy.h</a>&gt;</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="keyword">namespace </span>std _GLIBCXX_VISIBILITY(default)
<a name="l00039"></a>00039 {
<a name="l00040"></a>00040 _GLIBCXX_BEGIN_NAMESPACE_VERSION
<a name="l00041"></a>00041 
<a name="l00042"></a>00042   <span class="comment">// Class template _Hashtable, class definition.</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044   <span class="comment">// Meaning of class template _Hashtable&#39;s template parameters</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046   <span class="comment">// _Key and _Value: arbitrary CopyConstructible types.</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048   <span class="comment">// _Allocator: an allocator type ([lib.allocator.requirements]) whose</span>
<a name="l00049"></a>00049   <span class="comment">// value type is Value.  As a conforming extension, we allow for</span>
<a name="l00050"></a>00050   <span class="comment">// value type != Value.</span>
<a name="l00051"></a>00051 
<a name="l00052"></a>00052   <span class="comment">// _ExtractKey: function object that takes an object of type Value</span>
<a name="l00053"></a>00053   <span class="comment">// and returns a value of type _Key.</span>
<a name="l00054"></a>00054 
<a name="l00055"></a>00055   <span class="comment">// _Equal: function object that takes two objects of type k and returns</span>
<a name="l00056"></a>00056   <span class="comment">// a bool-like value that is true if the two objects are considered equal.</span>
<a name="l00057"></a>00057 
<a name="l00058"></a>00058   <span class="comment">// _H1: the hash function.  A unary function object with argument type</span>
<a name="l00059"></a>00059   <span class="comment">// Key and result type size_t.  Return values should be distributed</span>
<a name="l00060"></a>00060   <span class="comment">// over the entire range [0, numeric_limits&lt;size_t&gt;:::max()].</span>
<a name="l00061"></a>00061 
<a name="l00062"></a>00062   <span class="comment">// _H2: the range-hashing function (in the terminology of Tavori and</span>
<a name="l00063"></a>00063   <span class="comment">// Dreizin).  A binary function object whose argument types and result</span>
<a name="l00064"></a>00064   <span class="comment">// type are all size_t.  Given arguments r and N, the return value is</span>
<a name="l00065"></a>00065   <span class="comment">// in the range [0, N).</span>
<a name="l00066"></a>00066 
<a name="l00067"></a>00067   <span class="comment">// _Hash: the ranged hash function (Tavori and Dreizin). A binary function</span>
<a name="l00068"></a>00068   <span class="comment">// whose argument types are _Key and size_t and whose result type is</span>
<a name="l00069"></a>00069   <span class="comment">// size_t.  Given arguments k and N, the return value is in the range</span>
<a name="l00070"></a>00070   <span class="comment">// [0, N).  Default: hash(k, N) = h2(h1(k), N).  If _Hash is anything other</span>
<a name="l00071"></a>00071   <span class="comment">// than the default, _H1 and _H2 are ignored.</span>
<a name="l00072"></a>00072 
<a name="l00073"></a>00073   <span class="comment">// _RehashPolicy: Policy class with three members, all of which govern</span>
<a name="l00074"></a>00074   <span class="comment">// the bucket count. _M_next_bkt(n) returns a bucket count no smaller</span>
<a name="l00075"></a>00075   <span class="comment">// than n.  _M_bkt_for_elements(n) returns a bucket count appropriate</span>
<a name="l00076"></a>00076   <span class="comment">// for an element count of n.  _M_need_rehash(n_bkt, n_elt, n_ins)</span>
<a name="l00077"></a>00077   <span class="comment">// determines whether, if the current bucket count is n_bkt and the</span>
<a name="l00078"></a>00078   <span class="comment">// current element count is n_elt, we need to increase the bucket</span>
<a name="l00079"></a>00079   <span class="comment">// count.  If so, returns make_pair(true, n), where n is the new</span>
<a name="l00080"></a>00080   <span class="comment">// bucket count.  If not, returns make_pair(false, &lt;anything&gt;).</span>
<a name="l00081"></a>00081 
<a name="l00082"></a>00082   <span class="comment">// __cache_hash_code: bool.  true if we store the value of the hash</span>
<a name="l00083"></a>00083   <span class="comment">// function along with the value.  This is a time-space tradeoff.</span>
<a name="l00084"></a>00084   <span class="comment">// Storing it may improve lookup speed by reducing the number of times</span>
<a name="l00085"></a>00085   <span class="comment">// we need to call the Equal function.</span>
<a name="l00086"></a>00086 
<a name="l00087"></a>00087   <span class="comment">// __constant_iterators: bool.  true if iterator and const_iterator are</span>
<a name="l00088"></a>00088   <span class="comment">// both constant iterator types.  This is true for unordered_set and</span>
<a name="l00089"></a>00089   <span class="comment">// unordered_multiset, false for unordered_map and unordered_multimap.</span>
<a name="l00090"></a>00090 
<a name="l00091"></a>00091   <span class="comment">// __unique_keys: bool.  true if the return value of _Hashtable::count(k)</span>
<a name="l00092"></a>00092   <span class="comment">// is always at most one, false if it may be an arbitrary number.  This</span>
<a name="l00093"></a>00093   <span class="comment">// true for unordered_set and unordered_map, false for unordered_multiset</span>
<a name="l00094"></a>00094   <span class="comment">// and unordered_multimap.</span><span class="comment"></span>
<a name="l00095"></a>00095 <span class="comment">  /**</span>
<a name="l00096"></a>00096 <span class="comment">   * Here&#39;s _Hashtable data structure, each _Hashtable has:</span>
<a name="l00097"></a>00097 <span class="comment">   * - _Bucket[]       _M_buckets</span>
<a name="l00098"></a>00098 <span class="comment">   * - _Hash_node_base _M_before_begin</span>
<a name="l00099"></a>00099 <span class="comment">   * - size_type       _M_bucket_count</span>
<a name="l00100"></a>00100 <span class="comment">   * - size_type       _M_element_count</span>
<a name="l00101"></a>00101 <span class="comment">   *</span>
<a name="l00102"></a>00102 <span class="comment">   * with _Bucket being _Hash_node* and _Hash_node containing:</span>
<a name="l00103"></a>00103 <span class="comment">   * - _Hash_node*   _M_next</span>
<a name="l00104"></a>00104 <span class="comment">   * - Tp            _M_value</span>
<a name="l00105"></a>00105 <span class="comment">   * - size_t        _M_hash_code if cache_hash_code is true</span>
<a name="l00106"></a>00106 <span class="comment">   *</span>
<a name="l00107"></a>00107 <span class="comment">   * In terms of Standard containers the hashtable is like the aggregation of:</span>
<a name="l00108"></a>00108 <span class="comment">   * - std::forward_list&lt;_Node&gt; containing the elements</span>
<a name="l00109"></a>00109 <span class="comment">   * - std::vector&lt;std::forward_list&lt;_Node&gt;::iterator&gt; representing the buckets</span>
<a name="l00110"></a>00110 <span class="comment">   *</span>
<a name="l00111"></a>00111 <span class="comment">   * The non-empty buckets contain the node before the first node in the</span>
<a name="l00112"></a>00112 <span class="comment">   * bucket. This design makes it possible to implement something like a</span>
<a name="l00113"></a>00113 <span class="comment">   * std::forward_list::insert_after on container insertion and</span>
<a name="l00114"></a>00114 <span class="comment">   * std::forward_list::erase_after on container erase calls.</span>
<a name="l00115"></a>00115 <span class="comment">   * _M_before_begin is equivalent to std::foward_list::before_begin.</span>
<a name="l00116"></a>00116 <span class="comment">   * Empty buckets contain nullptr.</span>
<a name="l00117"></a>00117 <span class="comment">   * Note that one of the non-empty buckets contains &amp;_M_before_begin which is</span>
<a name="l00118"></a>00118 <span class="comment">   * not a dereferenceable node so the node pointer in a bucket shall never be</span>
<a name="l00119"></a>00119 <span class="comment">   * dereferenced, only its next node can be.</span>
<a name="l00120"></a>00120 <span class="comment">   * </span>
<a name="l00121"></a>00121 <span class="comment">   * Walking through a bucket&#39;s nodes requires a check on the hash code to see</span>
<a name="l00122"></a>00122 <span class="comment">   * if each node is still in the bucket. Such a design assumes a quite</span>
<a name="l00123"></a>00123 <span class="comment">   * efficient hash functor and is one of the reasons it is</span>
<a name="l00124"></a>00124 <span class="comment">   * highly advisable to set __cache_hash_code to true.</span>
<a name="l00125"></a>00125 <span class="comment">   *</span>
<a name="l00126"></a>00126 <span class="comment">   * The container iterators are simply built from nodes. This way incrementing</span>
<a name="l00127"></a>00127 <span class="comment">   * the iterator is perfectly efficient independent of how many empty buckets</span>
<a name="l00128"></a>00128 <span class="comment">   * there are in the container.</span>
<a name="l00129"></a>00129 <span class="comment">   *</span>
<a name="l00130"></a>00130 <span class="comment">   * On insert we compute the element&#39;s hash code and use it to it find the</span>
<a name="l00131"></a>00131 <span class="comment">   * bucket index. If the element must be inserted in an empty bucket we add</span>
<a name="l00132"></a>00132 <span class="comment">   * it at the beginning of the singly linked list and make the bucket point to</span>
<a name="l00133"></a>00133 <span class="comment">   * _M_before_begin. The bucket that used to point to _M_before_begin, if any,</span>
<a name="l00134"></a>00134 <span class="comment">   * is updated to point to its new before begin node.</span>
<a name="l00135"></a>00135 <span class="comment">   *</span>
<a name="l00136"></a>00136 <span class="comment">   * On erase, the simple iterator design requires using the hash functor to</span>
<a name="l00137"></a>00137 <span class="comment">   * get the index of the bucket to update. For this reason, when</span>
<a name="l00138"></a>00138 <span class="comment">   * __cache_hash_code is set to false, the hash functor must not throw</span>
<a name="l00139"></a>00139 <span class="comment">   * and this is enforced by a statied assertion.</span>
<a name="l00140"></a>00140 <span class="comment">   */</span>
<a name="l00141"></a>00141 
<a name="l00142"></a>00142   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value, <span class="keyword">typename</span> _Allocator,
<a name="l00143"></a>00143        <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00144"></a>00144        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash,
<a name="l00145"></a>00145        <span class="keyword">typename</span> _RehashPolicy,
<a name="l00146"></a>00146        <span class="keywordtype">bool</span> __cache_hash_code,
<a name="l00147"></a>00147        <span class="keywordtype">bool</span> __constant_iterators,
<a name="l00148"></a>00148        <span class="keywordtype">bool</span> __unique_keys&gt;
<a name="l00149"></a><a class="code" href="a00409.html">00149</a>     <span class="keyword">class </span><a class="code" href="a00409.html">_Hashtable</a>
<a name="l00150"></a>00150     : <span class="keyword">public</span> __detail::_Rehash_base&lt;_RehashPolicy,
<a name="l00151"></a>00151                     _Hashtable&lt;_Key, _Value, _Allocator,
<a name="l00152"></a>00152                            _ExtractKey,
<a name="l00153"></a>00153                            _Equal, _H1, _H2, _Hash,
<a name="l00154"></a>00154                            _RehashPolicy,
<a name="l00155"></a>00155                            __cache_hash_code,
<a name="l00156"></a>00156                            __constant_iterators,
<a name="l00157"></a>00157                            __unique_keys&gt; &gt;,
<a name="l00158"></a>00158       <span class="keyword">public</span> __detail::_Hashtable_base&lt;_Key, _Value, _ExtractKey, _Equal,
<a name="l00159"></a>00159                        _H1, _H2, _Hash, __cache_hash_code&gt;,
<a name="l00160"></a>00160       <span class="keyword">public</span> __detail::_Map_base&lt;_Key, _Value, _ExtractKey, __unique_keys,
<a name="l00161"></a>00161                  _Hashtable&lt;_Key, _Value, _Allocator,
<a name="l00162"></a>00162                         _ExtractKey,
<a name="l00163"></a>00163                         _Equal, _H1, _H2, _Hash,
<a name="l00164"></a>00164                         _RehashPolicy,
<a name="l00165"></a>00165                         __cache_hash_code,
<a name="l00166"></a>00166                         __constant_iterators,
<a name="l00167"></a>00167                         __unique_keys&gt; &gt;,
<a name="l00168"></a>00168       <span class="keyword">public</span> __detail::_Equality_base&lt;_ExtractKey, __unique_keys,
<a name="l00169"></a>00169                       _Hashtable&lt;_Key, _Value, _Allocator,
<a name="l00170"></a>00170                          _ExtractKey,
<a name="l00171"></a>00171                          _Equal, _H1, _H2, _Hash,
<a name="l00172"></a>00172                          _RehashPolicy,
<a name="l00173"></a>00173                          __cache_hash_code,
<a name="l00174"></a>00174                          __constant_iterators,
<a name="l00175"></a>00175                          __unique_keys&gt; &gt;
<a name="l00176"></a>00176     {
<a name="l00177"></a>00177       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Cond&gt;
<a name="l00178"></a>00178     <span class="keyword">using</span> __if_hash_code_cached
<a name="l00179"></a>00179       = __or_&lt;__not_&lt;integral_constant&lt;bool, __cache_hash_code&gt;&gt;, _Cond&gt;;
<a name="l00180"></a>00180 
<a name="l00181"></a>00181       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Cond&gt;
<a name="l00182"></a>00182     <span class="keyword">using</span> __if_hash_code_not_cached
<a name="l00183"></a>00183       = __or_&lt;integral_constant&lt;bool, __cache_hash_code&gt;, _Cond&gt;;
<a name="l00184"></a>00184 
<a name="l00185"></a>00185       <span class="comment">// When hash codes are not cached the hash functor shall not throw</span>
<a name="l00186"></a>00186       <span class="comment">// because it is used in methods (erase, swap...) that shall not throw.</span>
<a name="l00187"></a>00187       static_assert(__if_hash_code_not_cached&lt;__detail::__is_noexcept_hash&lt;_Key,
<a name="l00188"></a>00188                                 _H1&gt;&gt;::value,
<a name="l00189"></a>00189             <span class="stringliteral">&quot;Cache the hash code or qualify your hash functor with noexcept&quot;</span>);
<a name="l00190"></a>00190 
<a name="l00191"></a>00191       <span class="comment">// Following two static assertions are necessary to guarantee that</span>
<a name="l00192"></a>00192       <span class="comment">// swapping two hashtable instances won&#39;t invalidate associated local</span>
<a name="l00193"></a>00193       <span class="comment">// iterators.</span>
<a name="l00194"></a>00194 
<a name="l00195"></a>00195       <span class="comment">// When hash codes are cached local iterator only uses H2 which must then</span>
<a name="l00196"></a>00196       <span class="comment">// be empty.</span>
<a name="l00197"></a>00197       static_assert(__if_hash_code_cached&lt;<a class="code" href="a00735.html" title="is_empty">is_empty&lt;_H2&gt;</a>&gt;::value,
<a name="l00198"></a>00198         <span class="stringliteral">&quot;Functor used to map hash code to bucket index must be empty&quot;</span>);
<a name="l00199"></a>00199 
<a name="l00200"></a>00200       <span class="keyword">typedef</span> __detail::_Hash_code_base&lt;_Key, _Value, _ExtractKey,
<a name="l00201"></a>00201                     _H1, _H2, _Hash,
<a name="l00202"></a>00202                         __cache_hash_code&gt; _HCBase;
<a name="l00203"></a>00203 
<a name="l00204"></a>00204       <span class="comment">// When hash codes are not cached local iterator is going to use _HCBase</span>
<a name="l00205"></a>00205       <span class="comment">// above to compute node bucket index so it has to be empty.</span>
<a name="l00206"></a>00206       static_assert(__if_hash_code_not_cached&lt;<a class="code" href="a00735.html" title="is_empty">is_empty&lt;_HCBase&gt;</a>&gt;::value,
<a name="l00207"></a>00207         <span class="stringliteral">&quot;Cache the hash code or make functors involved in hash code&quot;</span>
<a name="l00208"></a>00208         <span class="stringliteral">&quot; and bucket index computation empty&quot;</span>);
<a name="l00209"></a>00209 
<a name="l00210"></a>00210     <span class="keyword">public</span>:
<a name="l00211"></a>00211       <span class="keyword">typedef</span> _Allocator                                  allocator_type;
<a name="l00212"></a>00212       <span class="keyword">typedef</span> _Value                                      value_type;
<a name="l00213"></a>00213       <span class="keyword">typedef</span> _Key                                        key_type;
<a name="l00214"></a>00214       <span class="keyword">typedef</span> _Equal                                      key_equal;
<a name="l00215"></a>00215       <span class="comment">// mapped_type, if present, comes from _Map_base.</span>
<a name="l00216"></a>00216       <span class="comment">// hasher, if present, comes from _Hash_code_base.</span>
<a name="l00217"></a>00217       <span class="keyword">typedef</span> <span class="keyword">typename</span> _Allocator::pointer                pointer;
<a name="l00218"></a>00218       <span class="keyword">typedef</span> <span class="keyword">typename</span> _Allocator::const_pointer          const_pointer;
<a name="l00219"></a>00219       <span class="keyword">typedef</span> <span class="keyword">typename</span> _Allocator::reference              reference;
<a name="l00220"></a>00220       <span class="keyword">typedef</span> <span class="keyword">typename</span> _Allocator::const_reference        const_reference;
<a name="l00221"></a>00221 
<a name="l00222"></a>00222       <span class="keyword">typedef</span> std::size_t                                 size_type;
<a name="l00223"></a>00223       <span class="keyword">typedef</span> std::ptrdiff_t                              difference_type;
<a name="l00224"></a>00224       <span class="keyword">typedef</span> __detail::_Local_iterator&lt;key_type, value_type, _ExtractKey,
<a name="l00225"></a>00225                     _H1, _H2, _Hash,
<a name="l00226"></a>00226                     __constant_iterators,
<a name="l00227"></a>00227                     __cache_hash_code&gt;
<a name="l00228"></a>00228                               local_iterator;
<a name="l00229"></a>00229       <span class="keyword">typedef</span> __detail::_Local_const_iterator&lt;key_type, value_type, _ExtractKey,
<a name="l00230"></a>00230                           _H1, _H2, _Hash,
<a name="l00231"></a>00231                           __constant_iterators,
<a name="l00232"></a>00232                           __cache_hash_code&gt;
<a name="l00233"></a>00233                               const_local_iterator;
<a name="l00234"></a>00234       <span class="keyword">typedef</span> __detail::_Node_iterator&lt;value_type, __constant_iterators,
<a name="l00235"></a>00235                        __cache_hash_code&gt;
<a name="l00236"></a>00236                               iterator;
<a name="l00237"></a>00237       <span class="keyword">typedef</span> __detail::_Node_const_iterator&lt;value_type,
<a name="l00238"></a>00238                          __constant_iterators,
<a name="l00239"></a>00239                          __cache_hash_code&gt;
<a name="l00240"></a>00240                               const_iterator;
<a name="l00241"></a>00241 
<a name="l00242"></a>00242       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key2, <span class="keyword">typename</span> _Value2, <span class="keyword">typename</span> _Ex2, <span class="keywordtype">bool</span> __unique2,
<a name="l00243"></a>00243            <span class="keyword">typename</span> _Hashtable2&gt;
<a name="l00244"></a>00244     <span class="keyword">friend</span> <span class="keyword">struct </span>__detail::_Map_base;
<a name="l00245"></a>00245 
<a name="l00246"></a>00246     <span class="keyword">private</span>:
<a name="l00247"></a>00247       <span class="keyword">typedef</span> <span class="keyword">typename</span> _RehashPolicy::_State _RehashPolicyState;
<a name="l00248"></a>00248       <span class="keyword">typedef</span> __detail::_Hash_node&lt;_Value, __cache_hash_code&gt; _Node;
<a name="l00249"></a>00249       <span class="keyword">typedef</span> <span class="keyword">typename</span> _Allocator::template rebind&lt;_Node&gt;::other
<a name="l00250"></a>00250                             _Node_allocator_type;
<a name="l00251"></a>00251       <span class="keyword">typedef</span> __detail::_Hash_node_base _BaseNode;
<a name="l00252"></a>00252       <span class="keyword">typedef</span> _BaseNode* _Bucket;
<a name="l00253"></a>00253       <span class="keyword">typedef</span> <span class="keyword">typename</span> _Allocator::template rebind&lt;_Bucket&gt;::other
<a name="l00254"></a>00254                             _Bucket_allocator_type;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256       <span class="keyword">typedef</span> <span class="keyword">typename</span> _Allocator::template rebind&lt;_Value&gt;::other
<a name="l00257"></a>00257                             _Value_allocator_type;
<a name="l00258"></a>00258 
<a name="l00259"></a>00259       _Node_allocator_type  _M_node_allocator;
<a name="l00260"></a>00260       _Bucket*          _M_buckets;
<a name="l00261"></a>00261       size_type         _M_bucket_count;
<a name="l00262"></a>00262       _BaseNode         _M_before_begin;
<a name="l00263"></a>00263       size_type         _M_element_count;
<a name="l00264"></a>00264       _RehashPolicy     _M_rehash_policy;
<a name="l00265"></a>00265 
<a name="l00266"></a>00266       <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;
<a name="l00267"></a>00267     _Node*
<a name="l00268"></a>00268     _M_allocate_node(_Args&amp;&amp;... __args);
<a name="l00269"></a>00269 
<a name="l00270"></a>00270       <span class="keywordtype">void</span>
<a name="l00271"></a>00271       _M_deallocate_node(_Node* __n);
<a name="l00272"></a>00272 
<a name="l00273"></a>00273       <span class="comment">// Deallocate the linked list of nodes pointed to by __n</span>
<a name="l00274"></a>00274       <span class="keywordtype">void</span>
<a name="l00275"></a>00275       _M_deallocate_nodes(_Node* __n);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277       _Bucket*
<a name="l00278"></a>00278       _M_allocate_buckets(size_type __n);
<a name="l00279"></a>00279 
<a name="l00280"></a>00280       <span class="keywordtype">void</span>
<a name="l00281"></a>00281       _M_deallocate_buckets(_Bucket*, size_type __n);
<a name="l00282"></a>00282 
<a name="l00283"></a>00283       <span class="comment">// Gets bucket begin, deals with the fact that non-empty buckets contain</span>
<a name="l00284"></a>00284       <span class="comment">// their before begin node.</span>
<a name="l00285"></a>00285       _Node*
<a name="l00286"></a>00286       _M_bucket_begin(size_type __bkt) <span class="keyword">const</span>;
<a name="l00287"></a>00287 
<a name="l00288"></a>00288       _Node*
<a name="l00289"></a>00289       _M_begin()<span class="keyword"> const</span>
<a name="l00290"></a>00290 <span class="keyword">      </span>{ <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>_Node*<span class="keyword">&gt;</span>(_M_before_begin._M_nxt); }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292     <span class="keyword">public</span>:
<a name="l00293"></a>00293       <span class="comment">// Constructor, destructor, assignment, swap</span>
<a name="l00294"></a>00294       <a class="code" href="a00409.html">_Hashtable</a>(size_type __bucket_hint,
<a name="l00295"></a>00295          <span class="keyword">const</span> _H1&amp;, <span class="keyword">const</span> _H2&amp;, <span class="keyword">const</span> _Hash&amp;,
<a name="l00296"></a>00296          <span class="keyword">const</span> _Equal&amp;, <span class="keyword">const</span> _ExtractKey&amp;,
<a name="l00297"></a>00297          <span class="keyword">const</span> allocator_type&amp;);
<a name="l00298"></a>00298 
<a name="l00299"></a>00299       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;
<a name="l00300"></a>00300     <a class="code" href="a00409.html">_Hashtable</a>(_InputIterator __first, _InputIterator __last,
<a name="l00301"></a>00301            size_type __bucket_hint,
<a name="l00302"></a>00302            <span class="keyword">const</span> _H1&amp;, <span class="keyword">const</span> _H2&amp;, <span class="keyword">const</span> _Hash&amp;,
<a name="l00303"></a>00303            <span class="keyword">const</span> _Equal&amp;, <span class="keyword">const</span> _ExtractKey&amp;,
<a name="l00304"></a>00304            <span class="keyword">const</span> allocator_type&amp;);
<a name="l00305"></a>00305 
<a name="l00306"></a>00306       <a class="code" href="a00409.html">_Hashtable</a>(<span class="keyword">const</span> <a class="code" href="a00409.html">_Hashtable</a>&amp;);
<a name="l00307"></a>00307 
<a name="l00308"></a>00308       <a class="code" href="a00409.html">_Hashtable</a>(<a class="code" href="a00409.html">_Hashtable</a>&amp;&amp;);
<a name="l00309"></a>00309 
<a name="l00310"></a>00310       <a class="code" href="a00409.html">_Hashtable</a>&amp;
<a name="l00311"></a>00311       operator=(<span class="keyword">const</span> <a class="code" href="a00409.html">_Hashtable</a>&amp; __ht)
<a name="l00312"></a>00312       {
<a name="l00313"></a>00313     <a class="code" href="a00409.html">_Hashtable</a> __tmp(__ht);
<a name="l00314"></a>00314     this-&gt;swap(__tmp);
<a name="l00315"></a>00315     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00316"></a>00316       }
<a name="l00317"></a>00317 
<a name="l00318"></a>00318       <a class="code" href="a00409.html">_Hashtable</a>&amp;
<a name="l00319"></a>00319       operator=(<a class="code" href="a00409.html">_Hashtable</a>&amp;&amp; __ht)
<a name="l00320"></a>00320       {
<a name="l00321"></a>00321     <span class="comment">// NB: DR 1204.</span>
<a name="l00322"></a>00322     <span class="comment">// NB: DR 675.</span>
<a name="l00323"></a>00323     this-&gt;clear();
<a name="l00324"></a>00324     this-&gt;swap(__ht);
<a name="l00325"></a>00325     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00326"></a>00326       }
<a name="l00327"></a>00327 
<a name="l00328"></a>00328       ~<a class="code" href="a00409.html">_Hashtable</a>() noexcept;
<a name="l00329"></a>00329 
<a name="l00330"></a>00330       <span class="keywordtype">void</span> swap(<a class="code" href="a00409.html">_Hashtable</a>&amp;);
<a name="l00331"></a>00331 
<a name="l00332"></a>00332       <span class="comment">// Basic container operations</span>
<a name="l00333"></a>00333       iterator
<a name="l00334"></a>00334       <a class="code" href="a01576.html#a549ebac15bcc03ae83f87b89796d89fc" title="Return an iterator pointing to the first element of the initilizer_list.">begin</a>() noexcept
<a name="l00335"></a>00335       { <span class="keywordflow">return</span> iterator(_M_begin()); }
<a name="l00336"></a>00336 
<a name="l00337"></a>00337       const_iterator
<a name="l00338"></a>00338       <a class="code" href="a01576.html#a549ebac15bcc03ae83f87b89796d89fc" title="Return an iterator pointing to the first element of the initilizer_list.">begin</a>() <span class="keyword">const</span> noexcept
<a name="l00339"></a>00339       { <span class="keywordflow">return</span> const_iterator(_M_begin()); }
<a name="l00340"></a>00340 
<a name="l00341"></a>00341       iterator
<a name="l00342"></a>00342       <a class="code" href="a01576.html#a579ff3807b61f57bda29d023b3918504" title="Return an iterator pointing to one past the last element of the initilizer_list.">end</a>() noexcept
<a name="l00343"></a>00343       { <span class="keywordflow">return</span> iterator(<span class="keyword">nullptr</span>); }
<a name="l00344"></a>00344 
<a name="l00345"></a>00345       const_iterator
<a name="l00346"></a>00346       <a class="code" href="a01576.html#a579ff3807b61f57bda29d023b3918504" title="Return an iterator pointing to one past the last element of the initilizer_list.">end</a>() <span class="keyword">const</span> noexcept
<a name="l00347"></a>00347       { <span class="keywordflow">return</span> const_iterator(<span class="keyword">nullptr</span>); }
<a name="l00348"></a>00348 
<a name="l00349"></a>00349       const_iterator
<a name="l00350"></a>00350       cbegin() <span class="keyword">const</span> noexcept
<a name="l00351"></a>00351       { <span class="keywordflow">return</span> const_iterator(_M_begin()); }
<a name="l00352"></a>00352 
<a name="l00353"></a>00353       const_iterator
<a name="l00354"></a>00354       cend() <span class="keyword">const</span> noexcept
<a name="l00355"></a>00355       { <span class="keywordflow">return</span> const_iterator(<span class="keyword">nullptr</span>); }
<a name="l00356"></a>00356 
<a name="l00357"></a>00357       size_type
<a name="l00358"></a>00358       <a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>() <span class="keyword">const</span> noexcept
<a name="l00359"></a>00359       { <span class="keywordflow">return</span> _M_element_count; }
<a name="l00360"></a>00360 
<a name="l00361"></a>00361       <span class="keywordtype">bool</span>
<a name="l00362"></a>00362       empty() <span class="keyword">const</span> noexcept
<a name="l00363"></a>00363       { <span class="keywordflow">return</span> <a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>() == 0; }
<a name="l00364"></a>00364 
<a name="l00365"></a>00365       allocator_type
<a name="l00366"></a>00366       get_allocator() <span class="keyword">const</span> noexcept
<a name="l00367"></a>00367       { <span class="keywordflow">return</span> allocator_type(_M_node_allocator); }
<a name="l00368"></a>00368 
<a name="l00369"></a>00369       size_type
<a name="l00370"></a>00370       max_size() <span class="keyword">const</span> noexcept
<a name="l00371"></a>00371       { <span class="keywordflow">return</span> _M_node_allocator.max_size(); }
<a name="l00372"></a>00372 
<a name="l00373"></a>00373       <span class="comment">// Observers</span>
<a name="l00374"></a>00374       key_equal
<a name="l00375"></a>00375       key_eq()<span class="keyword"> const</span>
<a name="l00376"></a>00376 <span class="keyword">      </span>{ <span class="keywordflow">return</span> this-&gt;_M_eq(); }
<a name="l00377"></a>00377 
<a name="l00378"></a>00378       <span class="comment">// hash_function, if present, comes from _Hash_code_base.</span>
<a name="l00379"></a>00379 
<a name="l00380"></a>00380       <span class="comment">// Bucket operations</span>
<a name="l00381"></a>00381       size_type
<a name="l00382"></a>00382       bucket_count() <span class="keyword">const</span> noexcept
<a name="l00383"></a>00383       { <span class="keywordflow">return</span> _M_bucket_count; }
<a name="l00384"></a>00384 
<a name="l00385"></a>00385       size_type
<a name="l00386"></a>00386       max_bucket_count() <span class="keyword">const</span> noexcept
<a name="l00387"></a>00387       { <span class="keywordflow">return</span> max_size(); }
<a name="l00388"></a>00388 
<a name="l00389"></a>00389       size_type
<a name="l00390"></a>00390       bucket_size(size_type __n)<span class="keyword"> const</span>
<a name="l00391"></a>00391 <span class="keyword">      </span>{ <span class="keywordflow">return</span> <a class="code" href="a01576.html#a5852ded2c7147a161b33951ef37ecba8" title="A generalization of pointer arithmetic.">std::distance</a>(<a class="code" href="a01576.html#a549ebac15bcc03ae83f87b89796d89fc" title="Return an iterator pointing to the first element of the initilizer_list.">begin</a>(__n), <a class="code" href="a01576.html#a579ff3807b61f57bda29d023b3918504" title="Return an iterator pointing to one past the last element of the initilizer_list.">end</a>(__n)); }
<a name="l00392"></a>00392 
<a name="l00393"></a>00393       size_type
<a name="l00394"></a>00394       bucket(<span class="keyword">const</span> key_type&amp; __k)<span class="keyword"> const</span>
<a name="l00395"></a>00395 <span class="keyword">      </span>{ <span class="keywordflow">return</span> _M_bucket_index(__k, this-&gt;_M_hash_code(__k)); }
<a name="l00396"></a>00396 
<a name="l00397"></a>00397       local_iterator
<a name="l00398"></a>00398       <a class="code" href="a01576.html#a549ebac15bcc03ae83f87b89796d89fc" title="Return an iterator pointing to the first element of the initilizer_list.">begin</a>(size_type __n)
<a name="l00399"></a>00399       { <span class="keywordflow">return</span> local_iterator(_M_bucket_begin(__n), __n,
<a name="l00400"></a>00400                   _M_bucket_count); }
<a name="l00401"></a>00401 
<a name="l00402"></a>00402       local_iterator
<a name="l00403"></a>00403       <a class="code" href="a01576.html#a579ff3807b61f57bda29d023b3918504" title="Return an iterator pointing to one past the last element of the initilizer_list.">end</a>(size_type __n)
<a name="l00404"></a>00404       { <span class="keywordflow">return</span> local_iterator(<span class="keyword">nullptr</span>, __n, _M_bucket_count); }
<a name="l00405"></a>00405 
<a name="l00406"></a>00406       const_local_iterator
<a name="l00407"></a>00407       <a class="code" href="a01576.html#a549ebac15bcc03ae83f87b89796d89fc" title="Return an iterator pointing to the first element of the initilizer_list.">begin</a>(size_type __n)<span class="keyword"> const</span>
<a name="l00408"></a>00408 <span class="keyword">      </span>{ <span class="keywordflow">return</span> const_local_iterator(_M_bucket_begin(__n), __n,
<a name="l00409"></a>00409                     _M_bucket_count); }
<a name="l00410"></a>00410 
<a name="l00411"></a>00411       const_local_iterator
<a name="l00412"></a>00412       <a class="code" href="a01576.html#a579ff3807b61f57bda29d023b3918504" title="Return an iterator pointing to one past the last element of the initilizer_list.">end</a>(size_type __n)<span class="keyword"> const</span>
<a name="l00413"></a>00413 <span class="keyword">      </span>{ <span class="keywordflow">return</span> const_local_iterator(<span class="keyword">nullptr</span>, __n, _M_bucket_count); }
<a name="l00414"></a>00414 
<a name="l00415"></a>00415       <span class="comment">// DR 691.</span>
<a name="l00416"></a>00416       const_local_iterator
<a name="l00417"></a>00417       cbegin(size_type __n)<span class="keyword"> const</span>
<a name="l00418"></a>00418 <span class="keyword">      </span>{ <span class="keywordflow">return</span> const_local_iterator(_M_bucket_begin(__n), __n,
<a name="l00419"></a>00419                     _M_bucket_count); }
<a name="l00420"></a>00420 
<a name="l00421"></a>00421       const_local_iterator
<a name="l00422"></a>00422       cend(size_type __n)<span class="keyword"> const</span>
<a name="l00423"></a>00423 <span class="keyword">      </span>{ <span class="keywordflow">return</span> const_local_iterator(<span class="keyword">nullptr</span>, __n, _M_bucket_count); }
<a name="l00424"></a>00424 
<a name="l00425"></a>00425       <span class="keywordtype">float</span>
<a name="l00426"></a>00426       load_factor() <span class="keyword">const</span> noexcept
<a name="l00427"></a>00427       {
<a name="l00428"></a>00428     <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">float</span><span class="keyword">&gt;</span>(<a class="code" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">size</a>()) / static_cast&lt;float&gt;(bucket_count());
<a name="l00429"></a>00429       }
<a name="l00430"></a>00430 
<a name="l00431"></a>00431       <span class="comment">// max_load_factor, if present, comes from _Rehash_base.</span>
<a name="l00432"></a>00432 
<a name="l00433"></a>00433       <span class="comment">// Generalization of max_load_factor.  Extension, not found in TR1.  Only</span>
<a name="l00434"></a>00434       <span class="comment">// useful if _RehashPolicy is something other than the default.</span>
<a name="l00435"></a>00435       <span class="keyword">const</span> _RehashPolicy&amp;
<a name="l00436"></a>00436       __rehash_policy()<span class="keyword"> const</span>
<a name="l00437"></a>00437 <span class="keyword">      </span>{ <span class="keywordflow">return</span> _M_rehash_policy; }
<a name="l00438"></a>00438 
<a name="l00439"></a>00439       <span class="keywordtype">void</span>
<a name="l00440"></a>00440       __rehash_policy(<span class="keyword">const</span> _RehashPolicy&amp;);
<a name="l00441"></a>00441 
<a name="l00442"></a>00442       <span class="comment">// Lookup.</span>
<a name="l00443"></a>00443       iterator
<a name="l00444"></a>00444       find(<span class="keyword">const</span> key_type&amp; __k);
<a name="l00445"></a>00445 
<a name="l00446"></a>00446       const_iterator
<a name="l00447"></a>00447       find(<span class="keyword">const</span> key_type&amp; __k) <span class="keyword">const</span>;
<a name="l00448"></a>00448 
<a name="l00449"></a>00449       size_type
<a name="l00450"></a>00450       <a class="code" href="a01576.html#ac58e3291b25d9f423330a8983004a8f6" title="Returns the number of bits which are set.">count</a>(<span class="keyword">const</span> key_type&amp; __k) <span class="keyword">const</span>;
<a name="l00451"></a>00451 
<a name="l00452"></a>00452       <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">std::pair&lt;iterator, iterator&gt;</a>
<a name="l00453"></a>00453       equal_range(<span class="keyword">const</span> key_type&amp; __k);
<a name="l00454"></a>00454 
<a name="l00455"></a>00455       <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">std::pair&lt;const_iterator, const_iterator&gt;</a>
<a name="l00456"></a>00456       equal_range(<span class="keyword">const</span> key_type&amp; __k) <span class="keyword">const</span>;
<a name="l00457"></a>00457 
<a name="l00458"></a>00458     <span class="keyword">private</span>:
<a name="l00459"></a>00459       <span class="comment">// Bucket index computation helpers.</span>
<a name="l00460"></a>00460       size_type
<a name="l00461"></a>00461       _M_bucket_index(_Node* __n)<span class="keyword"> const</span>
<a name="l00462"></a>00462 <span class="keyword">      </span>{ <span class="keywordflow">return</span> _HCBase::_M_bucket_index(__n, _M_bucket_count); }
<a name="l00463"></a>00463 
<a name="l00464"></a>00464       size_type
<a name="l00465"></a>00465       _M_bucket_index(<span class="keyword">const</span> key_type&amp; __k,
<a name="l00466"></a>00466               <span class="keyword">typename</span> _Hashtable::_Hash_code_type __c)<span class="keyword"> const</span>
<a name="l00467"></a>00467 <span class="keyword">      </span>{ <span class="keywordflow">return</span> _HCBase::_M_bucket_index(__k, __c, _M_bucket_count); }
<a name="l00468"></a>00468 
<a name="l00469"></a>00469       <span class="comment">// Find and insert helper functions and types</span>
<a name="l00470"></a>00470       <span class="comment">// Find the node before the one matching the criteria.</span>
<a name="l00471"></a>00471       _BaseNode*
<a name="l00472"></a>00472       _M_find_before_node(size_type, <span class="keyword">const</span> key_type&amp;,
<a name="l00473"></a>00473               <span class="keyword">typename</span> _Hashtable::_Hash_code_type) <span class="keyword">const</span>;
<a name="l00474"></a>00474 
<a name="l00475"></a>00475       _Node*
<a name="l00476"></a>00476       _M_find_node(size_type __bkt, <span class="keyword">const</span> key_type&amp; __key,
<a name="l00477"></a>00477            <span class="keyword">typename</span> _Hashtable::_Hash_code_type __c)<span class="keyword"> const</span>
<a name="l00478"></a>00478 <span class="keyword">      </span>{
<a name="l00479"></a>00479     _BaseNode* __before_n = _M_find_before_node(__bkt, __key, __c);
<a name="l00480"></a>00480     <span class="keywordflow">if</span> (__before_n)
<a name="l00481"></a>00481       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>_Node*<span class="keyword">&gt;</span>(__before_n-&gt;_M_nxt);
<a name="l00482"></a>00482     <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;
<a name="l00483"></a>00483       }
<a name="l00484"></a>00484 
<a name="l00485"></a>00485       <span class="comment">// Insert a node at the beginning of a bucket.</span>
<a name="l00486"></a>00486       <span class="keywordtype">void</span>
<a name="l00487"></a>00487       _M_insert_bucket_begin(size_type, _Node*);
<a name="l00488"></a>00488 
<a name="l00489"></a>00489       <span class="comment">// Remove the bucket first node</span>
<a name="l00490"></a>00490       <span class="keywordtype">void</span>
<a name="l00491"></a>00491       _M_remove_bucket_begin(size_type __bkt, _Node* __next_n,
<a name="l00492"></a>00492                  size_type __next_bkt);
<a name="l00493"></a>00493 
<a name="l00494"></a>00494       <span class="comment">// Get the node before __n in the bucket __bkt</span>
<a name="l00495"></a>00495       _BaseNode*
<a name="l00496"></a>00496       _M_get_previous_node(size_type __bkt, _BaseNode* __n);
<a name="l00497"></a>00497 
<a name="l00498"></a>00498       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Arg&gt;
<a name="l00499"></a>00499     iterator
<a name="l00500"></a>00500     _M_insert_bucket(_Arg&amp;&amp;, size_type,
<a name="l00501"></a>00501              <span class="keyword">typename</span> _Hashtable::_Hash_code_type);
<a name="l00502"></a>00502 
<a name="l00503"></a>00503       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00609.html" title="Define a member typedef type to one of two argument types.">std::conditional</a>&lt;__unique_keys,
<a name="l00504"></a>00504                     <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">std::pair&lt;iterator, bool&gt;</a>,
<a name="l00505"></a>00505                     iterator&gt;::type
<a name="l00506"></a>00506     <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">_Insert_Return_Type</a>;
<a name="l00507"></a>00507 
<a name="l00508"></a>00508       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="a00609.html" title="Define a member typedef type to one of two argument types.">std::conditional</a>&lt;__unique_keys,
<a name="l00509"></a>00509                     std::_Select1st&lt;_Insert_Return_Type&gt;,
<a name="l00510"></a>00510                     std::_Identity&lt;_Insert_Return_Type&gt;
<a name="l00511"></a>00511                    &gt;::type
<a name="l00512"></a>00512     <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">_Insert_Conv_Type</a>;
<a name="l00513"></a>00513 
<a name="l00514"></a>00514     <span class="keyword">protected</span>:
<a name="l00515"></a>00515       <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;
<a name="l00516"></a>00516     <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">std::pair&lt;iterator, bool&gt;</a>
<a name="l00517"></a>00517     _M_emplace(<a class="code" href="a00432.html" title="integral_constant">std::true_type</a>, _Args&amp;&amp;... __args);
<a name="l00518"></a>00518 
<a name="l00519"></a>00519       <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;
<a name="l00520"></a>00520     iterator
<a name="l00521"></a>00521     _M_emplace(<a class="code" href="a00432.html" title="integral_constant">std::false_type</a>, _Args&amp;&amp;... __args);
<a name="l00522"></a>00522 
<a name="l00523"></a>00523       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Arg&gt;
<a name="l00524"></a>00524     <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">std::pair&lt;iterator, bool&gt;</a>
<a name="l00525"></a>00525     _M_insert(_Arg&amp;&amp;, <a class="code" href="a00432.html" title="integral_constant">std::true_type</a>);
<a name="l00526"></a>00526 
<a name="l00527"></a>00527       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Arg&gt;
<a name="l00528"></a>00528     iterator
<a name="l00529"></a>00529     _M_insert(_Arg&amp;&amp;, <a class="code" href="a00432.html" title="integral_constant">std::false_type</a>);
<a name="l00530"></a>00530 
<a name="l00531"></a>00531     <span class="keyword">public</span>:
<a name="l00532"></a>00532       <span class="comment">// Emplace, insert and erase</span>
<a name="l00533"></a>00533       <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;
<a name="l00534"></a>00534     <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">_Insert_Return_Type</a>
<a name="l00535"></a>00535     emplace(_Args&amp;&amp;... __args)
<a name="l00536"></a>00536     { <span class="keywordflow">return</span> _M_emplace(<a class="code" href="a00432.html" title="integral_constant">integral_constant&lt;bool, __unique_keys&gt;</a>(),
<a name="l00537"></a>00537                 std::forward&lt;_Args&gt;(__args)...); }
<a name="l00538"></a>00538 
<a name="l00539"></a>00539       <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;
<a name="l00540"></a>00540     iterator
<a name="l00541"></a>00541     emplace_hint(const_iterator, _Args&amp;&amp;... __args)
<a name="l00542"></a>00542     { <span class="keywordflow">return</span> <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">_Insert_Conv_Type</a>()(emplace(std::forward&lt;_Args&gt;(__args)...)); }
<a name="l00543"></a>00543 
<a name="l00544"></a>00544       <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">_Insert_Return_Type</a>
<a name="l00545"></a>00545       insert(<span class="keyword">const</span> value_type&amp; __v)
<a name="l00546"></a>00546       { <span class="keywordflow">return</span> _M_insert(__v, <a class="code" href="a00432.html" title="integral_constant">integral_constant&lt;bool, __unique_keys&gt;</a>()); }
<a name="l00547"></a>00547 
<a name="l00548"></a>00548       iterator
<a name="l00549"></a>00549       insert(const_iterator, <span class="keyword">const</span> value_type&amp; __v)
<a name="l00550"></a>00550       { <span class="keywordflow">return</span> <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">_Insert_Conv_Type</a>()(insert(__v)); }
<a name="l00551"></a>00551 
<a name="l00552"></a>00552       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Pair, <span class="keyword">typename</span> = <span class="keyword">typename</span>
<a name="l00553"></a>00553     <a class="code" href="a00430.html" title="Define a member typedef type only if a boolean constant is true.">std::enable_if&lt;__and_&lt;integral_constant&lt;bool, !__constant_iterators&gt;</a>,
<a name="l00554"></a>00554                   <a class="code" href="a00434.html" title="is_constructible">std::is_constructible</a>&lt;value_type,
<a name="l00555"></a>00555                             _Pair&amp;&amp;&gt;&gt;::value&gt;::type&gt;
<a name="l00556"></a>00556     <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">_Insert_Return_Type</a>
<a name="l00557"></a>00557     insert(_Pair&amp;&amp; __v)
<a name="l00558"></a>00558     { <span class="keywordflow">return</span> _M_insert(std::forward&lt;_Pair&gt;(__v),
<a name="l00559"></a>00559                <a class="code" href="a00432.html" title="integral_constant">integral_constant&lt;bool, __unique_keys&gt;</a>()); }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Pair, <span class="keyword">typename</span> = <span class="keyword">typename</span>
<a name="l00562"></a>00562         <a class="code" href="a00430.html" title="Define a member typedef type only if a boolean constant is true.">std::enable_if&lt;__and_&lt;integral_constant&lt;bool, !__constant_iterators&gt;</a>,
<a name="l00563"></a>00563                   <a class="code" href="a00434.html" title="is_constructible">std::is_constructible</a>&lt;value_type,
<a name="l00564"></a>00564                             _Pair&amp;&amp;&gt;&gt;::value&gt;::type&gt;
<a name="l00565"></a>00565     iterator
<a name="l00566"></a>00566     insert(const_iterator, _Pair&amp;&amp; __v)
<a name="l00567"></a>00567     { <span class="keywordflow">return</span> <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">_Insert_Conv_Type</a>()(insert(std::forward&lt;_Pair&gt;(__v))); }
<a name="l00568"></a>00568 
<a name="l00569"></a>00569       <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;
<a name="l00570"></a>00570     <span class="keywordtype">void</span>
<a name="l00571"></a>00571     insert(_InputIterator __first, _InputIterator __last);
<a name="l00572"></a>00572 
<a name="l00573"></a>00573       <span class="keywordtype">void</span>
<a name="l00574"></a>00574       insert(<a class="code" href="a00708.html" title="initializer_list">initializer_list&lt;value_type&gt;</a> __l)
<a name="l00575"></a>00575       { this-&gt;insert(__l.begin(), __l.end()); }
<a name="l00576"></a>00576 
<a name="l00577"></a>00577       iterator
<a name="l00578"></a>00578       erase(const_iterator);
<a name="l00579"></a>00579 
<a name="l00580"></a>00580       <span class="comment">// LWG 2059.</span>
<a name="l00581"></a>00581       iterator
<a name="l00582"></a>00582       erase(iterator __it)
<a name="l00583"></a>00583       { <span class="keywordflow">return</span> erase(const_iterator(__it)); }
<a name="l00584"></a>00584 
<a name="l00585"></a>00585       size_type
<a name="l00586"></a>00586       erase(<span class="keyword">const</span> key_type&amp;);
<a name="l00587"></a>00587 
<a name="l00588"></a>00588       iterator
<a name="l00589"></a>00589       erase(const_iterator, const_iterator);
<a name="l00590"></a>00590 
<a name="l00591"></a>00591       <span class="keywordtype">void</span>
<a name="l00592"></a>00592       clear() noexcept;
<a name="l00593"></a>00593 
<a name="l00594"></a>00594       <span class="comment">// Set number of buckets to be appropriate for container of n element.</span>
<a name="l00595"></a>00595       <span class="keywordtype">void</span> rehash(size_type __n);
<a name="l00596"></a>00596 
<a name="l00597"></a>00597       <span class="comment">// DR 1189.</span>
<a name="l00598"></a>00598       <span class="comment">// reserve, if present, comes from _Rehash_base.</span>
<a name="l00599"></a>00599 
<a name="l00600"></a>00600     <span class="keyword">private</span>:
<a name="l00601"></a>00601       <span class="comment">// Helper rehash method used when keys are unique.</span>
<a name="l00602"></a>00602       <span class="keywordtype">void</span> _M_rehash_aux(size_type __n, <a class="code" href="a00432.html" title="integral_constant">std::true_type</a>);
<a name="l00603"></a>00603 
<a name="l00604"></a>00604       <span class="comment">// Helper rehash method used when keys can be non-unique.</span>
<a name="l00605"></a>00605       <span class="keywordtype">void</span> _M_rehash_aux(size_type __n, <a class="code" href="a00432.html" title="integral_constant">std::false_type</a>);
<a name="l00606"></a>00606 
<a name="l00607"></a>00607       <span class="comment">// Unconditionally change size of bucket array to n, restore hash policy</span>
<a name="l00608"></a>00608       <span class="comment">// state to __state on exception.</span>
<a name="l00609"></a>00609       <span class="keywordtype">void</span> _M_rehash(size_type __n, <span class="keyword">const</span> _RehashPolicyState&amp; __state);
<a name="l00610"></a>00610     };
<a name="l00611"></a>00611 
<a name="l00612"></a>00612 
<a name="l00613"></a>00613   <span class="comment">// Definitions of class template _Hashtable&#39;s out-of-line member functions.</span>
<a name="l00614"></a>00614   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00615"></a>00615        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00616"></a>00616        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00617"></a>00617        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00618"></a>00618     <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;
<a name="l00619"></a>00619       <span class="keyword">typename</span> <a class="code" href="a00409.html">_Hashtable</a>&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00620"></a>00620               _H1, _H2, _Hash, _RehashPolicy,
<a name="l00621"></a>00621               __chc, __cit, __uk&gt;::_Node*
<a name="l00622"></a>00622       <a class="code" href="a00409.html">_Hashtable</a>&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00623"></a>00623          _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l00624"></a>00624       _M_allocate_node(_Args&amp;&amp;... __args)
<a name="l00625"></a>00625       {
<a name="l00626"></a>00626     _Node* __n = _M_node_allocator.allocate(1);
<a name="l00627"></a>00627     __try
<a name="l00628"></a>00628       {
<a name="l00629"></a>00629         _M_node_allocator.construct(__n, std::forward&lt;_Args&gt;(__args)...);
<a name="l00630"></a>00630         <span class="keywordflow">return</span> __n;
<a name="l00631"></a>00631       }
<a name="l00632"></a>00632     __catch(...)
<a name="l00633"></a>00633       {
<a name="l00634"></a>00634         _M_node_allocator.deallocate(__n, 1);
<a name="l00635"></a>00635         __throw_exception_again;
<a name="l00636"></a>00636       }
<a name="l00637"></a>00637       }
<a name="l00638"></a>00638 
<a name="l00639"></a>00639   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00640"></a>00640        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00641"></a>00641        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00642"></a>00642        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00643"></a>00643     <span class="keywordtype">void</span>
<a name="l00644"></a>00644     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00645"></a>00645            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l00646"></a>00646     _M_deallocate_node(_Node* __n)
<a name="l00647"></a>00647     {
<a name="l00648"></a>00648       _M_node_allocator.destroy(__n);
<a name="l00649"></a>00649       _M_node_allocator.deallocate(__n, 1);
<a name="l00650"></a>00650     }
<a name="l00651"></a>00651 
<a name="l00652"></a>00652   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00653"></a>00653        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00654"></a>00654        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00655"></a>00655        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00656"></a>00656     <span class="keywordtype">void</span>
<a name="l00657"></a>00657     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00658"></a>00658            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l00659"></a>00659     _M_deallocate_nodes(_Node* __n)
<a name="l00660"></a>00660     {
<a name="l00661"></a>00661       <span class="keywordflow">while</span> (__n)
<a name="l00662"></a>00662     {
<a name="l00663"></a>00663       _Node* __tmp = __n;
<a name="l00664"></a>00664       __n = __n-&gt;_M_next();
<a name="l00665"></a>00665       _M_deallocate_node(__tmp);
<a name="l00666"></a>00666     }
<a name="l00667"></a>00667     }
<a name="l00668"></a>00668 
<a name="l00669"></a>00669   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00670"></a>00670        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00671"></a>00671        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00672"></a>00672        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00673"></a>00673     <span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00674"></a>00674             _H1, _H2, _Hash, _RehashPolicy,
<a name="l00675"></a>00675             __chc, __cit, __uk&gt;::_Bucket*
<a name="l00676"></a>00676     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00677"></a>00677            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l00678"></a>00678     _M_allocate_buckets(size_type __n)
<a name="l00679"></a>00679     {
<a name="l00680"></a>00680       _Bucket_allocator_type __alloc(_M_node_allocator);
<a name="l00681"></a>00681 
<a name="l00682"></a>00682       _Bucket* __p = __alloc.allocate(__n);
<a name="l00683"></a>00683       __builtin_memset(__p, 0, __n * <span class="keyword">sizeof</span>(_Bucket));
<a name="l00684"></a>00684       <span class="keywordflow">return</span> __p;
<a name="l00685"></a>00685     }
<a name="l00686"></a>00686 
<a name="l00687"></a>00687   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00688"></a>00688        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00689"></a>00689        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00690"></a>00690        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00691"></a>00691     <span class="keywordtype">void</span>
<a name="l00692"></a>00692     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00693"></a>00693            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l00694"></a>00694     _M_deallocate_buckets(_Bucket* __p, size_type __n)
<a name="l00695"></a>00695     {
<a name="l00696"></a>00696       _Bucket_allocator_type __alloc(_M_node_allocator);
<a name="l00697"></a>00697       __alloc.deallocate(__p, __n);
<a name="l00698"></a>00698     }
<a name="l00699"></a>00699 
<a name="l00700"></a>00700   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00701"></a>00701        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00702"></a>00702        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00703"></a>00703        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00704"></a>00704     <span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey,
<a name="l00705"></a>00705             _Equal, _H1, _H2, _Hash, _RehashPolicy,
<a name="l00706"></a>00706             __chc, __cit, __uk&gt;::_Node*
<a name="l00707"></a>00707     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00708"></a>00708            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l00709"></a>00709     _M_bucket_begin(size_type __bkt)<span class="keyword"> const</span>
<a name="l00710"></a>00710 <span class="keyword">    </span>{
<a name="l00711"></a>00711       _BaseNode* __n = _M_buckets[__bkt];
<a name="l00712"></a>00712       <span class="keywordflow">return</span> __n ? <span class="keyword">static_cast&lt;</span>_Node*<span class="keyword">&gt;</span>(__n-&gt;_M_nxt) : <span class="keyword">nullptr</span>;
<a name="l00713"></a>00713     }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00716"></a>00716        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00717"></a>00717        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00718"></a>00718        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00719"></a>00719     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00720"></a>00720            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l00721"></a>00721     _Hashtable(size_type __bucket_hint,
<a name="l00722"></a>00722            <span class="keyword">const</span> _H1&amp; __h1, <span class="keyword">const</span> _H2&amp; __h2, <span class="keyword">const</span> _Hash&amp; __h,
<a name="l00723"></a>00723            <span class="keyword">const</span> _Equal&amp; __eq, <span class="keyword">const</span> _ExtractKey&amp; __exk,
<a name="l00724"></a>00724            <span class="keyword">const</span> allocator_type&amp; __a)
<a name="l00725"></a>00725     : __detail::_Rehash_base&lt;_RehashPolicy, _Hashtable&gt;(),
<a name="l00726"></a>00726       __detail::_Hashtable_base&lt;_Key, _Value, _ExtractKey, _Equal,
<a name="l00727"></a>00727                 _H1, _H2, _Hash, __chc&gt;(__exk, __h1, __h2, __h,
<a name="l00728"></a>00728                             __eq),
<a name="l00729"></a>00729       __detail::_Map_base&lt;_Key, _Value, _ExtractKey, __uk, _Hashtable&gt;(),
<a name="l00730"></a>00730       _M_node_allocator(__a),
<a name="l00731"></a>00731       _M_bucket_count(0),
<a name="l00732"></a>00732       _M_element_count(0),
<a name="l00733"></a>00733       _M_rehash_policy()
<a name="l00734"></a>00734     {
<a name="l00735"></a>00735       _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);
<a name="l00736"></a>00736       <span class="comment">// We don&#39;t want the rehash policy to ask for the hashtable to shrink</span>
<a name="l00737"></a>00737       <span class="comment">// on the first insertion so we need to reset its previous resize level.</span>
<a name="l00738"></a>00738       _M_rehash_policy._M_prev_resize = 0;
<a name="l00739"></a>00739       _M_buckets = _M_allocate_buckets(_M_bucket_count);
<a name="l00740"></a>00740     }
<a name="l00741"></a>00741 
<a name="l00742"></a>00742   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00743"></a>00743        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00744"></a>00744        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00745"></a>00745        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00746"></a>00746     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;
<a name="l00747"></a>00747       _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00748"></a>00748          _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l00749"></a>00749       _Hashtable(_InputIterator __f, _InputIterator __l,
<a name="l00750"></a>00750          size_type __bucket_hint,
<a name="l00751"></a>00751          <span class="keyword">const</span> _H1&amp; __h1, <span class="keyword">const</span> _H2&amp; __h2, <span class="keyword">const</span> _Hash&amp; __h,
<a name="l00752"></a>00752          <span class="keyword">const</span> _Equal&amp; __eq, <span class="keyword">const</span> _ExtractKey&amp; __exk,
<a name="l00753"></a>00753          <span class="keyword">const</span> allocator_type&amp; __a)
<a name="l00754"></a>00754       : __detail::_Rehash_base&lt;_RehashPolicy, _Hashtable&gt;(),
<a name="l00755"></a>00755     __detail::_Hashtable_base&lt;_Key, _Value, _ExtractKey, _Equal,
<a name="l00756"></a>00756                   _H1, _H2, _Hash, __chc&gt;(__exk, __h1, __h2, __h,
<a name="l00757"></a>00757                               __eq),
<a name="l00758"></a>00758     __detail::_Map_base&lt;_Key, _Value, _ExtractKey, __uk, _Hashtable&gt;(),
<a name="l00759"></a>00759     _M_node_allocator(__a),
<a name="l00760"></a>00760     _M_bucket_count(0),
<a name="l00761"></a>00761     _M_element_count(0),
<a name="l00762"></a>00762     _M_rehash_policy()
<a name="l00763"></a>00763       {
<a name="l00764"></a>00764     _M_bucket_count =
<a name="l00765"></a>00765       _M_rehash_policy._M_bkt_for_elements(__detail::__distance_fw(__f,
<a name="l00766"></a>00766                                        __l));
<a name="l00767"></a>00767     <span class="keywordflow">if</span> (_M_bucket_count &lt;= __bucket_hint)
<a name="l00768"></a>00768       _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);
<a name="l00769"></a>00769 
<a name="l00770"></a>00770         <span class="comment">// We don&#39;t want the rehash policy to ask for the hashtable to shrink</span>
<a name="l00771"></a>00771         <span class="comment">// on the first insertion so we need to reset its previous resize</span>
<a name="l00772"></a>00772     <span class="comment">// level.</span>
<a name="l00773"></a>00773     _M_rehash_policy._M_prev_resize = 0;
<a name="l00774"></a>00774     _M_buckets = _M_allocate_buckets(_M_bucket_count);
<a name="l00775"></a>00775     __try
<a name="l00776"></a>00776       {
<a name="l00777"></a>00777         <span class="keywordflow">for</span> (; __f != __l; ++__f)
<a name="l00778"></a>00778           this-&gt;insert(*__f);
<a name="l00779"></a>00779       }
<a name="l00780"></a>00780     __catch(...)
<a name="l00781"></a>00781       {
<a name="l00782"></a>00782         clear();
<a name="l00783"></a>00783         _M_deallocate_buckets(_M_buckets, _M_bucket_count);
<a name="l00784"></a>00784         __throw_exception_again;
<a name="l00785"></a>00785       }
<a name="l00786"></a>00786       }
<a name="l00787"></a>00787 
<a name="l00788"></a>00788   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00789"></a>00789        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00790"></a>00790        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00791"></a>00791        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00792"></a>00792     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00793"></a>00793            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l00794"></a>00794     _Hashtable(<span class="keyword">const</span> _Hashtable&amp; __ht)
<a name="l00795"></a>00795     : __detail::_Rehash_base&lt;_RehashPolicy, _Hashtable&gt;(__ht),
<a name="l00796"></a>00796       __detail::_Hashtable_base&lt;_Key, _Value, _ExtractKey, _Equal,
<a name="l00797"></a>00797                 _H1, _H2, _Hash, __chc&gt;(__ht),
<a name="l00798"></a>00798       __detail::_Map_base&lt;_Key, _Value, _ExtractKey, __uk, _Hashtable&gt;(__ht),
<a name="l00799"></a>00799       _M_node_allocator(__ht._M_node_allocator),
<a name="l00800"></a>00800       _M_bucket_count(__ht._M_bucket_count),
<a name="l00801"></a>00801       _M_element_count(__ht._M_element_count),
<a name="l00802"></a>00802       _M_rehash_policy(__ht._M_rehash_policy)
<a name="l00803"></a>00803     {
<a name="l00804"></a>00804       _M_buckets = _M_allocate_buckets(_M_bucket_count);
<a name="l00805"></a>00805       __try
<a name="l00806"></a>00806     {
<a name="l00807"></a>00807       <span class="keywordflow">if</span> (!__ht._M_before_begin._M_nxt)
<a name="l00808"></a>00808         <span class="keywordflow">return</span>;
<a name="l00809"></a>00809 
<a name="l00810"></a>00810       <span class="comment">// First deal with the special first node pointed to by</span>
<a name="l00811"></a>00811       <span class="comment">// _M_before_begin.</span>
<a name="l00812"></a>00812       <span class="keyword">const</span> _Node* __ht_n = __ht._M_begin();
<a name="l00813"></a>00813       _Node* __this_n = _M_allocate_node(__ht_n-&gt;_M_v);
<a name="l00814"></a>00814       this-&gt;_M_copy_code(__this_n, __ht_n);
<a name="l00815"></a>00815       _M_before_begin._M_nxt = __this_n;
<a name="l00816"></a>00816       _M_buckets[_M_bucket_index(__this_n)] = &amp;_M_before_begin;
<a name="l00817"></a>00817 
<a name="l00818"></a>00818       <span class="comment">// Then deal with other nodes.</span>
<a name="l00819"></a>00819       _BaseNode* __prev_n = __this_n;
<a name="l00820"></a>00820       <span class="keywordflow">for</span> (__ht_n = __ht_n-&gt;_M_next(); __ht_n; __ht_n = __ht_n-&gt;_M_next())
<a name="l00821"></a>00821         {
<a name="l00822"></a>00822           __this_n = _M_allocate_node(__ht_n-&gt;_M_v);
<a name="l00823"></a>00823           __prev_n-&gt;_M_nxt = __this_n;
<a name="l00824"></a>00824           this-&gt;_M_copy_code(__this_n, __ht_n);
<a name="l00825"></a>00825           size_type __bkt = _M_bucket_index(__this_n);
<a name="l00826"></a>00826           <span class="keywordflow">if</span> (!_M_buckets[__bkt])
<a name="l00827"></a>00827         _M_buckets[__bkt] = __prev_n;
<a name="l00828"></a>00828           __prev_n = __this_n;
<a name="l00829"></a>00829         }
<a name="l00830"></a>00830     }
<a name="l00831"></a>00831       __catch(...)
<a name="l00832"></a>00832     {
<a name="l00833"></a>00833       clear();
<a name="l00834"></a>00834       _M_deallocate_buckets(_M_buckets, _M_bucket_count);
<a name="l00835"></a>00835       __throw_exception_again;
<a name="l00836"></a>00836     }
<a name="l00837"></a>00837     }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00840"></a>00840        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00841"></a>00841        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00842"></a>00842        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00843"></a>00843     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00844"></a>00844            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l00845"></a>00845     _Hashtable(_Hashtable&amp;&amp; __ht)
<a name="l00846"></a>00846     : __detail::_Rehash_base&lt;_RehashPolicy, _Hashtable&gt;(__ht),
<a name="l00847"></a>00847       __detail::_Hashtable_base&lt;_Key, _Value, _ExtractKey, _Equal,
<a name="l00848"></a>00848                 _H1, _H2, _Hash, __chc&gt;(__ht),
<a name="l00849"></a>00849       __detail::_Map_base&lt;_Key, _Value, _ExtractKey, __uk, _Hashtable&gt;(__ht),
<a name="l00850"></a>00850       _M_node_allocator(std::move(__ht._M_node_allocator)),
<a name="l00851"></a>00851       _M_buckets(__ht._M_buckets),
<a name="l00852"></a>00852       _M_bucket_count(__ht._M_bucket_count),
<a name="l00853"></a>00853       _M_before_begin(__ht._M_before_begin._M_nxt),
<a name="l00854"></a>00854       _M_element_count(__ht._M_element_count),
<a name="l00855"></a>00855       _M_rehash_policy(__ht._M_rehash_policy)
<a name="l00856"></a>00856     {
<a name="l00857"></a>00857       <span class="comment">// Update, if necessary, bucket pointing to before begin that hasn&#39;t move.</span>
<a name="l00858"></a>00858       <span class="keywordflow">if</span> (_M_begin())
<a name="l00859"></a>00859     _M_buckets[_M_bucket_index(_M_begin())] = &amp;_M_before_begin;
<a name="l00860"></a>00860       __ht._M_rehash_policy = _RehashPolicy();
<a name="l00861"></a>00861       __ht._M_bucket_count = __ht._M_rehash_policy._M_next_bkt(0);
<a name="l00862"></a>00862       __ht._M_buckets = __ht._M_allocate_buckets(__ht._M_bucket_count);
<a name="l00863"></a>00863       __ht._M_before_begin._M_nxt = <span class="keyword">nullptr</span>;
<a name="l00864"></a>00864       __ht._M_element_count = 0;
<a name="l00865"></a>00865     }
<a name="l00866"></a>00866 
<a name="l00867"></a>00867   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00868"></a>00868        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00869"></a>00869        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00870"></a>00870        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00871"></a>00871     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00872"></a>00872            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l00873"></a>00873     ~_Hashtable() noexcept
<a name="l00874"></a>00874     {
<a name="l00875"></a>00875       clear();
<a name="l00876"></a>00876       _M_deallocate_buckets(_M_buckets, _M_bucket_count);
<a name="l00877"></a>00877     }
<a name="l00878"></a>00878 
<a name="l00879"></a>00879   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00880"></a>00880        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00881"></a>00881        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00882"></a>00882        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00883"></a>00883     <span class="keywordtype">void</span>
<a name="l00884"></a>00884     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00885"></a>00885            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l00886"></a>00886     swap(_Hashtable&amp; __x)
<a name="l00887"></a>00887     {
<a name="l00888"></a>00888       <span class="comment">// The only base class with member variables is hash_code_base.  We</span>
<a name="l00889"></a>00889       <span class="comment">// define _Hash_code_base::_M_swap because different specializations</span>
<a name="l00890"></a>00890       <span class="comment">// have different members.</span>
<a name="l00891"></a>00891       this-&gt;_M_swap(__x);
<a name="l00892"></a>00892 
<a name="l00893"></a>00893       <span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span>
<a name="l00894"></a>00894       <span class="comment">// 431. Swapping containers with unequal allocators.</span>
<a name="l00895"></a>00895       std::__alloc_swap&lt;_Node_allocator_type&gt;::_S_do_it(_M_node_allocator,
<a name="l00896"></a>00896                             __x._M_node_allocator);
<a name="l00897"></a>00897 
<a name="l00898"></a>00898       std::swap(_M_rehash_policy, __x._M_rehash_policy);
<a name="l00899"></a>00899       std::swap(_M_buckets, __x._M_buckets);
<a name="l00900"></a>00900       std::swap(_M_bucket_count, __x._M_bucket_count);
<a name="l00901"></a>00901       std::swap(_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);
<a name="l00902"></a>00902       std::swap(_M_element_count, __x._M_element_count);
<a name="l00903"></a>00903       <span class="comment">// Fix buckets containing the _M_before_begin pointers that can&#39;t be</span>
<a name="l00904"></a>00904       <span class="comment">// swapped.</span>
<a name="l00905"></a>00905       <span class="keywordflow">if</span> (_M_begin())
<a name="l00906"></a>00906     _M_buckets[_M_bucket_index(_M_begin())] = &amp;_M_before_begin;
<a name="l00907"></a>00907       <span class="keywordflow">if</span> (__x._M_begin())
<a name="l00908"></a>00908     __x._M_buckets[__x._M_bucket_index(__x._M_begin())]
<a name="l00909"></a>00909       = &amp;(__x._M_before_begin);
<a name="l00910"></a>00910     }
<a name="l00911"></a>00911 
<a name="l00912"></a>00912   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00913"></a>00913        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00914"></a>00914        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00915"></a>00915        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00916"></a>00916     <span class="keywordtype">void</span>
<a name="l00917"></a>00917     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00918"></a>00918            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l00919"></a>00919     __rehash_policy(<span class="keyword">const</span> _RehashPolicy&amp; __pol)
<a name="l00920"></a>00920     {
<a name="l00921"></a>00921       size_type __n_bkt = __pol._M_bkt_for_elements(_M_element_count);
<a name="l00922"></a>00922       <span class="keywordflow">if</span> (__n_bkt != _M_bucket_count)
<a name="l00923"></a>00923     _M_rehash(__n_bkt, _M_rehash_policy._M_state());
<a name="l00924"></a>00924       _M_rehash_policy = __pol;
<a name="l00925"></a>00925     }
<a name="l00926"></a>00926 
<a name="l00927"></a>00927   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00928"></a>00928        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00929"></a>00929        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00930"></a>00930        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00931"></a>00931     <span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00932"></a>00932             _H1, _H2, _Hash, _RehashPolicy,
<a name="l00933"></a>00933             __chc, __cit, __uk&gt;::iterator
<a name="l00934"></a>00934     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00935"></a>00935            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l00936"></a>00936     find(<span class="keyword">const</span> key_type&amp; __k)
<a name="l00937"></a>00937     {
<a name="l00938"></a>00938       <span class="keyword">typename</span> _Hashtable::_Hash_code_type __code = this-&gt;_M_hash_code(__k);
<a name="l00939"></a>00939       std::size_t __n = _M_bucket_index(__k, __code);
<a name="l00940"></a>00940       _Node* __p = _M_find_node(__n, __k, __code);
<a name="l00941"></a>00941       <span class="keywordflow">return</span> __p ? iterator(__p) : this-&gt;<a class="code" href="a01576.html#a579ff3807b61f57bda29d023b3918504" title="Return an iterator pointing to one past the last element of the initilizer_list.">end</a>();
<a name="l00942"></a>00942     }
<a name="l00943"></a>00943 
<a name="l00944"></a>00944   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00945"></a>00945        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00946"></a>00946        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00947"></a>00947        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00948"></a>00948     <span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00949"></a>00949             _H1, _H2, _Hash, _RehashPolicy,
<a name="l00950"></a>00950             __chc, __cit, __uk&gt;::const_iterator
<a name="l00951"></a>00951     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00952"></a>00952            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l00953"></a>00953     find(<span class="keyword">const</span> key_type&amp; __k)<span class="keyword"> const</span>
<a name="l00954"></a>00954 <span class="keyword">    </span>{
<a name="l00955"></a>00955       <span class="keyword">typename</span> _Hashtable::_Hash_code_type __code = this-&gt;_M_hash_code(__k);
<a name="l00956"></a>00956       std::size_t __n = _M_bucket_index(__k, __code);
<a name="l00957"></a>00957       _Node* __p = _M_find_node(__n, __k, __code);
<a name="l00958"></a>00958       <span class="keywordflow">return</span> __p ? const_iterator(__p) : this-&gt;<a class="code" href="a01576.html#a579ff3807b61f57bda29d023b3918504" title="Return an iterator pointing to one past the last element of the initilizer_list.">end</a>();
<a name="l00959"></a>00959     }
<a name="l00960"></a>00960 
<a name="l00961"></a>00961   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00962"></a>00962        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00963"></a>00963        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00964"></a>00964        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00965"></a>00965     <span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00966"></a>00966             _H1, _H2, _Hash, _RehashPolicy,
<a name="l00967"></a>00967             __chc, __cit, __uk&gt;::size_type
<a name="l00968"></a>00968     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l00969"></a>00969            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;<a class="code" href="a01576.html#ac58e3291b25d9f423330a8983004a8f6" title="Returns the number of bits which are set.">::</a>
<a name="l00970"></a>00970 <a class="code" href="a01576.html#ac58e3291b25d9f423330a8983004a8f6" title="Returns the number of bits which are set.">    count</a>(<span class="keyword">const</span> key_type&amp; __k)<span class="keyword"> const</span>
<a name="l00971"></a>00971 <span class="keyword">    </span>{
<a name="l00972"></a>00972       <span class="keyword">typename</span> _Hashtable::_Hash_code_type __code = this-&gt;_M_hash_code(__k);
<a name="l00973"></a>00973       std::size_t __n = _M_bucket_index(__k, __code);
<a name="l00974"></a>00974       _Node* __p = _M_bucket_begin(__n);
<a name="l00975"></a>00975       <span class="keywordflow">if</span> (!__p)
<a name="l00976"></a>00976     <span class="keywordflow">return</span> 0;
<a name="l00977"></a>00977 
<a name="l00978"></a>00978       std::size_t __result = 0;
<a name="l00979"></a>00979       <span class="keywordflow">for</span> (;; __p = __p-&gt;_M_next())
<a name="l00980"></a>00980     {
<a name="l00981"></a>00981       <span class="keywordflow">if</span> (this-&gt;_M_equals(__k, __code, __p))
<a name="l00982"></a>00982         ++__result;
<a name="l00983"></a>00983       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (__result)
<a name="l00984"></a>00984         <span class="comment">// All equivalent values are next to each other, if we found a not</span>
<a name="l00985"></a>00985         <span class="comment">// equivalent value after an equivalent one it means that we won&#39;t</span>
<a name="l00986"></a>00986         <span class="comment">// find any more equivalent values.</span>
<a name="l00987"></a>00987         <span class="keywordflow">break</span>;
<a name="l00988"></a>00988       <span class="keywordflow">if</span> (!__p-&gt;_M_nxt || _M_bucket_index(__p-&gt;_M_next()) != __n)
<a name="l00989"></a>00989         <span class="keywordflow">break</span>;
<a name="l00990"></a>00990     }
<a name="l00991"></a>00991       <span class="keywordflow">return</span> __result;
<a name="l00992"></a>00992     }
<a name="l00993"></a>00993 
<a name="l00994"></a>00994   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l00995"></a>00995        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l00996"></a>00996        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l00997"></a>00997        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l00998"></a>00998     <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">std::pair</a>&lt;<span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator,
<a name="l00999"></a>00999                   _ExtractKey, _Equal, _H1,
<a name="l01000"></a>01000                   _H2, _Hash, _RehashPolicy,
<a name="l01001"></a>01001                   __chc, __cit, __uk&gt;::iterator,
<a name="l01002"></a>01002           <span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator,
<a name="l01003"></a>01003                   _ExtractKey, _Equal, _H1,
<a name="l01004"></a>01004                   _H2, _Hash, _RehashPolicy,
<a name="l01005"></a>01005                   __chc, __cit, __uk&gt;::iterator&gt;
<a name="l01006"></a>01006     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01007"></a>01007            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01008"></a>01008     equal_range(<span class="keyword">const</span> key_type&amp; __k)
<a name="l01009"></a>01009     {
<a name="l01010"></a>01010       <span class="keyword">typename</span> _Hashtable::_Hash_code_type __code = this-&gt;_M_hash_code(__k);
<a name="l01011"></a>01011       std::size_t __n = _M_bucket_index(__k, __code);
<a name="l01012"></a>01012       _Node* __p = _M_find_node(__n, __k, __code);
<a name="l01013"></a>01013 
<a name="l01014"></a>01014       <span class="keywordflow">if</span> (__p)
<a name="l01015"></a>01015     {
<a name="l01016"></a>01016       _Node* __p1 = __p-&gt;_M_next();
<a name="l01017"></a>01017       <span class="keywordflow">while</span> (__p1 &amp;&amp; _M_bucket_index(__p1) == __n
<a name="l01018"></a>01018          &amp;&amp; this-&gt;_M_equals(__k, __code, __p1))
<a name="l01019"></a>01019         __p1 = __p1-&gt;_M_next();
<a name="l01020"></a>01020 
<a name="l01021"></a>01021       <span class="keywordflow">return</span> <a class="code" href="a01576.html#a0409e288f07b697cb6885d1002df0bd6" title="A convenience wrapper for creating a pair from two objects.">std::make_pair</a>(iterator(__p), iterator(__p1));
<a name="l01022"></a>01022     }
<a name="l01023"></a>01023       <span class="keywordflow">else</span>
<a name="l01024"></a>01024     <span class="keywordflow">return</span> <a class="code" href="a01576.html#a0409e288f07b697cb6885d1002df0bd6" title="A convenience wrapper for creating a pair from two objects.">std::make_pair</a>(this-&gt;<a class="code" href="a01576.html#a579ff3807b61f57bda29d023b3918504" title="Return an iterator pointing to one past the last element of the initilizer_list.">end</a>(), this-&gt;<a class="code" href="a01576.html#a579ff3807b61f57bda29d023b3918504" title="Return an iterator pointing to one past the last element of the initilizer_list.">end</a>());
<a name="l01025"></a>01025     }
<a name="l01026"></a>01026 
<a name="l01027"></a>01027   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01028"></a>01028        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01029"></a>01029        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01030"></a>01030        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01031"></a>01031     <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">std::pair</a>&lt;<span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator,
<a name="l01032"></a>01032                   _ExtractKey, _Equal, _H1,
<a name="l01033"></a>01033                   _H2, _Hash, _RehashPolicy,
<a name="l01034"></a>01034                   __chc, __cit, __uk&gt;::const_iterator,
<a name="l01035"></a>01035           <span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator,
<a name="l01036"></a>01036                   _ExtractKey, _Equal, _H1,
<a name="l01037"></a>01037                   _H2, _Hash, _RehashPolicy,
<a name="l01038"></a>01038                   __chc, __cit, __uk&gt;::const_iterator&gt;
<a name="l01039"></a>01039     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01040"></a>01040            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01041"></a>01041     equal_range(<span class="keyword">const</span> key_type&amp; __k)<span class="keyword"> const</span>
<a name="l01042"></a>01042 <span class="keyword">    </span>{
<a name="l01043"></a>01043       <span class="keyword">typename</span> _Hashtable::_Hash_code_type __code = this-&gt;_M_hash_code(__k);
<a name="l01044"></a>01044       std::size_t __n = _M_bucket_index(__k, __code);
<a name="l01045"></a>01045       _Node* __p = _M_find_node(__n, __k, __code);
<a name="l01046"></a>01046 
<a name="l01047"></a>01047       <span class="keywordflow">if</span> (__p)
<a name="l01048"></a>01048     {
<a name="l01049"></a>01049       _Node* __p1 = __p-&gt;_M_next();
<a name="l01050"></a>01050       <span class="keywordflow">while</span> (__p1 &amp;&amp; _M_bucket_index(__p1) == __n
<a name="l01051"></a>01051          &amp;&amp; this-&gt;_M_equals(__k, __code, __p1))
<a name="l01052"></a>01052         __p1 = __p1-&gt;_M_next();
<a name="l01053"></a>01053 
<a name="l01054"></a>01054       <span class="keywordflow">return</span> <a class="code" href="a01576.html#a0409e288f07b697cb6885d1002df0bd6" title="A convenience wrapper for creating a pair from two objects.">std::make_pair</a>(const_iterator(__p), const_iterator(__p1));
<a name="l01055"></a>01055     }
<a name="l01056"></a>01056       <span class="keywordflow">else</span>
<a name="l01057"></a>01057     <span class="keywordflow">return</span> <a class="code" href="a01576.html#a0409e288f07b697cb6885d1002df0bd6" title="A convenience wrapper for creating a pair from two objects.">std::make_pair</a>(this-&gt;<a class="code" href="a01576.html#a579ff3807b61f57bda29d023b3918504" title="Return an iterator pointing to one past the last element of the initilizer_list.">end</a>(), this-&gt;<a class="code" href="a01576.html#a579ff3807b61f57bda29d023b3918504" title="Return an iterator pointing to one past the last element of the initilizer_list.">end</a>());
<a name="l01058"></a>01058     }
<a name="l01059"></a>01059 
<a name="l01060"></a>01060   <span class="comment">// Find the node whose key compares equal to k in the bucket n. Return nullptr</span>
<a name="l01061"></a>01061   <span class="comment">// if no node is found.</span>
<a name="l01062"></a>01062   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01063"></a>01063        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01064"></a>01064        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01065"></a>01065        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01066"></a>01066     <span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey,
<a name="l01067"></a>01067             _Equal, _H1, _H2, _Hash, _RehashPolicy,
<a name="l01068"></a>01068             __chc, __cit, __uk&gt;::_BaseNode*
<a name="l01069"></a>01069     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01070"></a>01070            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01071"></a>01071     _M_find_before_node(size_type __n, <span class="keyword">const</span> key_type&amp; __k,
<a name="l01072"></a>01072             <span class="keyword">typename</span> _Hashtable::_Hash_code_type __code)<span class="keyword"> const</span>
<a name="l01073"></a>01073 <span class="keyword">    </span>{
<a name="l01074"></a>01074       _BaseNode* __prev_p = _M_buckets[__n];
<a name="l01075"></a>01075       <span class="keywordflow">if</span> (!__prev_p)
<a name="l01076"></a>01076     <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;
<a name="l01077"></a>01077       _Node* __p = <span class="keyword">static_cast&lt;</span>_Node*<span class="keyword">&gt;</span>(__prev_p-&gt;_M_nxt);
<a name="l01078"></a>01078       <span class="keywordflow">for</span> (;; __p = __p-&gt;_M_next())
<a name="l01079"></a>01079     {
<a name="l01080"></a>01080       <span class="keywordflow">if</span> (this-&gt;_M_equals(__k, __code, __p))
<a name="l01081"></a>01081         <span class="keywordflow">return</span> __prev_p;
<a name="l01082"></a>01082       <span class="keywordflow">if</span> (!(__p-&gt;_M_nxt) || _M_bucket_index(__p-&gt;_M_next()) != __n)
<a name="l01083"></a>01083         <span class="keywordflow">break</span>;
<a name="l01084"></a>01084       __prev_p = __p;
<a name="l01085"></a>01085     }
<a name="l01086"></a>01086       <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;
<a name="l01087"></a>01087     }
<a name="l01088"></a>01088 
<a name="l01089"></a>01089   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01090"></a>01090        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01091"></a>01091        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01092"></a>01092        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01093"></a>01093     <span class="keywordtype">void</span>
<a name="l01094"></a>01094     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01095"></a>01095            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01096"></a>01096     _M_insert_bucket_begin(size_type __bkt, _Node* __new_node)
<a name="l01097"></a>01097     {
<a name="l01098"></a>01098       <span class="keywordflow">if</span> (_M_buckets[__bkt])
<a name="l01099"></a>01099     {
<a name="l01100"></a>01100       <span class="comment">// Bucket is not empty, we just need to insert the new node after the</span>
<a name="l01101"></a>01101       <span class="comment">// bucket before begin.</span>
<a name="l01102"></a>01102       __new_node-&gt;_M_nxt = _M_buckets[__bkt]-&gt;_M_nxt;
<a name="l01103"></a>01103       _M_buckets[__bkt]-&gt;_M_nxt = __new_node;
<a name="l01104"></a>01104     }
<a name="l01105"></a>01105       <span class="keywordflow">else</span>
<a name="l01106"></a>01106     {
<a name="l01107"></a>01107       <span class="comment">// The bucket is empty, the new node is inserted at the beginning of</span>
<a name="l01108"></a>01108       <span class="comment">// the singly-linked list and the bucket will contain _M_before_begin</span>
<a name="l01109"></a>01109       <span class="comment">// pointer.</span>
<a name="l01110"></a>01110       __new_node-&gt;_M_nxt = _M_before_begin._M_nxt;
<a name="l01111"></a>01111       _M_before_begin._M_nxt = __new_node;
<a name="l01112"></a>01112       <span class="keywordflow">if</span> (__new_node-&gt;_M_nxt)
<a name="l01113"></a>01113         <span class="comment">// We must update former begin bucket that is pointing to</span>
<a name="l01114"></a>01114         <span class="comment">// _M_before_begin.</span>
<a name="l01115"></a>01115         _M_buckets[_M_bucket_index(__new_node-&gt;_M_next())] = __new_node;
<a name="l01116"></a>01116       _M_buckets[__bkt] = &amp;_M_before_begin;
<a name="l01117"></a>01117     }
<a name="l01118"></a>01118     }
<a name="l01119"></a>01119 
<a name="l01120"></a>01120   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01121"></a>01121        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01122"></a>01122        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01123"></a>01123        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01124"></a>01124     <span class="keywordtype">void</span>
<a name="l01125"></a>01125     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01126"></a>01126            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01127"></a>01127     _M_remove_bucket_begin(size_type __bkt, _Node* __next, size_type __next_bkt)
<a name="l01128"></a>01128     {
<a name="l01129"></a>01129       <span class="keywordflow">if</span> (!__next || __next_bkt != __bkt)
<a name="l01130"></a>01130     {
<a name="l01131"></a>01131       <span class="comment">// Bucket is now empty</span>
<a name="l01132"></a>01132       <span class="comment">// First update next bucket if any</span>
<a name="l01133"></a>01133       <span class="keywordflow">if</span> (__next)
<a name="l01134"></a>01134         _M_buckets[__next_bkt] = _M_buckets[__bkt];
<a name="l01135"></a>01135       <span class="comment">// Second update before begin node if necessary</span>
<a name="l01136"></a>01136       <span class="keywordflow">if</span> (&amp;_M_before_begin == _M_buckets[__bkt])
<a name="l01137"></a>01137         _M_before_begin._M_nxt = __next;
<a name="l01138"></a>01138       _M_buckets[__bkt] = <span class="keyword">nullptr</span>;
<a name="l01139"></a>01139     }
<a name="l01140"></a>01140     }
<a name="l01141"></a>01141 
<a name="l01142"></a>01142   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01143"></a>01143        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01144"></a>01144        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01145"></a>01145        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01146"></a>01146     <span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey,
<a name="l01147"></a>01147             _Equal, _H1, _H2, _Hash, _RehashPolicy,
<a name="l01148"></a>01148             __chc, __cit, __uk&gt;::_BaseNode*
<a name="l01149"></a>01149     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01150"></a>01150            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01151"></a>01151     _M_get_previous_node(size_type __bkt, _BaseNode* __n)
<a name="l01152"></a>01152     {
<a name="l01153"></a>01153       _BaseNode* __prev_n = _M_buckets[__bkt];
<a name="l01154"></a>01154       <span class="keywordflow">while</span> (__prev_n-&gt;_M_nxt != __n)
<a name="l01155"></a>01155     __prev_n = __prev_n-&gt;_M_nxt;
<a name="l01156"></a>01156       <span class="keywordflow">return</span> __prev_n;
<a name="l01157"></a>01157     }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01160"></a>01160        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01161"></a>01161        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01162"></a>01162        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01163"></a>01163     <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;
<a name="l01164"></a>01164       <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">std::pair</a>&lt;<span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator,
<a name="l01165"></a>01165                     _ExtractKey, _Equal, _H1,
<a name="l01166"></a>01166                     _H2, _Hash, _RehashPolicy,
<a name="l01167"></a>01167                     __chc, __cit, __uk&gt;::iterator, <span class="keywordtype">bool</span>&gt;
<a name="l01168"></a>01168       _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01169"></a>01169          _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01170"></a>01170       _M_emplace(<a class="code" href="a00432.html" title="integral_constant">std::true_type</a>, _Args&amp;&amp;... __args)
<a name="l01171"></a>01171       {
<a name="l01172"></a>01172     <span class="comment">// First build the node to get access to the hash code</span>
<a name="l01173"></a>01173     _Node* __new_node = _M_allocate_node(std::forward&lt;_Args&gt;(__args)...);
<a name="l01174"></a>01174     __try
<a name="l01175"></a>01175       {
<a name="l01176"></a>01176         <span class="keyword">const</span> key_type&amp; __k = this-&gt;_M_extract()(__new_node-&gt;_M_v);
<a name="l01177"></a>01177         <span class="keyword">typename</span> _Hashtable::_Hash_code_type __code
<a name="l01178"></a>01178           = this-&gt;_M_hash_code(__k);
<a name="l01179"></a>01179         size_type __bkt = _M_bucket_index(__k, __code);
<a name="l01180"></a>01180 
<a name="l01181"></a>01181         <span class="keywordflow">if</span> (_Node* __p = _M_find_node(__bkt, __k, __code))
<a name="l01182"></a>01182           {
<a name="l01183"></a>01183         <span class="comment">// There is already an equivalent node, no insertion</span>
<a name="l01184"></a>01184         _M_deallocate_node(__new_node);
<a name="l01185"></a>01185         <span class="keywordflow">return</span> <a class="code" href="a01576.html#a0409e288f07b697cb6885d1002df0bd6" title="A convenience wrapper for creating a pair from two objects.">std::make_pair</a>(iterator(__p), <span class="keyword">false</span>);
<a name="l01186"></a>01186           }
<a name="l01187"></a>01187 
<a name="l01188"></a>01188         <span class="comment">// We are going to insert this node</span>
<a name="l01189"></a>01189         this-&gt;_M_store_code(__new_node, __code);
<a name="l01190"></a>01190         <span class="keyword">const</span> _RehashPolicyState&amp; __saved_state
<a name="l01191"></a>01191           = _M_rehash_policy._M_state();
<a name="l01192"></a>01192         <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">std::pair&lt;bool, std::size_t&gt;</a> __do_rehash
<a name="l01193"></a>01193           = _M_rehash_policy._M_need_rehash(_M_bucket_count,
<a name="l01194"></a>01194                         _M_element_count, 1);
<a name="l01195"></a>01195 
<a name="l01196"></a>01196         <span class="keywordflow">if</span> (__do_rehash.<a class="code" href="a00444.html#a198b03cffc037835dc1dc01c926ce251" title="second_type is the second bound type">first</a>)
<a name="l01197"></a>01197           {
<a name="l01198"></a>01198         _M_rehash(__do_rehash.<a class="code" href="a00444.html#a91179413226db12e66346d3673b7835f" title="first is a copy of the first object">second</a>, __saved_state);
<a name="l01199"></a>01199         __bkt = _M_bucket_index(__k, __code);
<a name="l01200"></a>01200           }
<a name="l01201"></a>01201 
<a name="l01202"></a>01202         _M_insert_bucket_begin(__bkt, __new_node);
<a name="l01203"></a>01203         ++_M_element_count;
<a name="l01204"></a>01204         <span class="keywordflow">return</span> <a class="code" href="a01576.html#a0409e288f07b697cb6885d1002df0bd6" title="A convenience wrapper for creating a pair from two objects.">std::make_pair</a>(iterator(__new_node), <span class="keyword">true</span>);
<a name="l01205"></a>01205       }
<a name="l01206"></a>01206     __catch(...)
<a name="l01207"></a>01207       {
<a name="l01208"></a>01208         _M_deallocate_node(__new_node);
<a name="l01209"></a>01209         __throw_exception_again;
<a name="l01210"></a>01210       }
<a name="l01211"></a>01211       }
<a name="l01212"></a>01212 
<a name="l01213"></a>01213   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01214"></a>01214        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01215"></a>01215        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01216"></a>01216        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01217"></a>01217     <span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Args&gt;
<a name="l01218"></a>01218       <span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01219"></a>01219               _H1, _H2, _Hash, _RehashPolicy,
<a name="l01220"></a>01220               __chc, __cit, __uk&gt;::iterator
<a name="l01221"></a>01221       _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01222"></a>01222          _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01223"></a>01223       _M_emplace(<a class="code" href="a00432.html" title="integral_constant">std::false_type</a>, _Args&amp;&amp;... __args)
<a name="l01224"></a>01224       {
<a name="l01225"></a>01225     <span class="keyword">const</span> _RehashPolicyState&amp; __saved_state = _M_rehash_policy._M_state();
<a name="l01226"></a>01226     <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">std::pair&lt;bool, std::size_t&gt;</a> __do_rehash
<a name="l01227"></a>01227       = _M_rehash_policy._M_need_rehash(_M_bucket_count,
<a name="l01228"></a>01228                         _M_element_count, 1);
<a name="l01229"></a>01229 
<a name="l01230"></a>01230     <span class="comment">// First build the node to get its hash code.</span>
<a name="l01231"></a>01231     _Node* __new_node = _M_allocate_node(std::forward&lt;_Args&gt;(__args)...);
<a name="l01232"></a>01232     __try
<a name="l01233"></a>01233       {
<a name="l01234"></a>01234         <span class="keyword">const</span> key_type&amp; __k = this-&gt;_M_extract()(__new_node-&gt;_M_v);
<a name="l01235"></a>01235         <span class="keyword">typename</span> _Hashtable::_Hash_code_type __code
<a name="l01236"></a>01236           = this-&gt;_M_hash_code(__k);
<a name="l01237"></a>01237         this-&gt;_M_store_code(__new_node, __code);
<a name="l01238"></a>01238 
<a name="l01239"></a>01239         <span class="comment">// Second, do rehash if necessary.</span>
<a name="l01240"></a>01240         <span class="keywordflow">if</span> (__do_rehash.<a class="code" href="a00444.html#a198b03cffc037835dc1dc01c926ce251" title="second_type is the second bound type">first</a>)
<a name="l01241"></a>01241         _M_rehash(__do_rehash.<a class="code" href="a00444.html#a91179413226db12e66346d3673b7835f" title="first is a copy of the first object">second</a>, __saved_state);
<a name="l01242"></a>01242 
<a name="l01243"></a>01243         <span class="comment">// Third, find the node before an equivalent one.</span>
<a name="l01244"></a>01244         size_type __bkt = _M_bucket_index(__k, __code);
<a name="l01245"></a>01245         _BaseNode* __prev = _M_find_before_node(__bkt, __k, __code);
<a name="l01246"></a>01246         
<a name="l01247"></a>01247         <span class="keywordflow">if</span> (__prev)
<a name="l01248"></a>01248           {
<a name="l01249"></a>01249         <span class="comment">// Insert after the node before the equivalent one.</span>
<a name="l01250"></a>01250         __new_node-&gt;_M_nxt = __prev-&gt;_M_nxt;
<a name="l01251"></a>01251         __prev-&gt;_M_nxt = __new_node;
<a name="l01252"></a>01252           }
<a name="l01253"></a>01253         <span class="keywordflow">else</span>
<a name="l01254"></a>01254           <span class="comment">// The inserted node has no equivalent in the hashtable. We must</span>
<a name="l01255"></a>01255           <span class="comment">// insert the new node at the beginning of the bucket to preserve</span>
<a name="l01256"></a>01256           <span class="comment">// equivalent elements&#39; relative positions.</span>
<a name="l01257"></a>01257           _M_insert_bucket_begin(__bkt, __new_node);
<a name="l01258"></a>01258         ++_M_element_count;
<a name="l01259"></a>01259         <span class="keywordflow">return</span> iterator(__new_node);
<a name="l01260"></a>01260       }
<a name="l01261"></a>01261     __catch(...)
<a name="l01262"></a>01262       {
<a name="l01263"></a>01263         _M_deallocate_node(__new_node);
<a name="l01264"></a>01264         __throw_exception_again;
<a name="l01265"></a>01265       }
<a name="l01266"></a>01266       }
<a name="l01267"></a>01267 
<a name="l01268"></a>01268   <span class="comment">// Insert v in bucket n (assumes no element with its key already present).</span>
<a name="l01269"></a>01269   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01270"></a>01270        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01271"></a>01271        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01272"></a>01272        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01273"></a>01273     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Arg&gt;
<a name="l01274"></a>01274       <span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01275"></a>01275               _H1, _H2, _Hash, _RehashPolicy,
<a name="l01276"></a>01276               __chc, __cit, __uk&gt;::iterator
<a name="l01277"></a>01277       _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01278"></a>01278          _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01279"></a>01279       _M_insert_bucket(_Arg&amp;&amp; __v, size_type __n,
<a name="l01280"></a>01280                <span class="keyword">typename</span> _Hashtable::_Hash_code_type __code)
<a name="l01281"></a>01281       {
<a name="l01282"></a>01282     <span class="keyword">const</span> _RehashPolicyState&amp; __saved_state = _M_rehash_policy._M_state();
<a name="l01283"></a>01283     <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">std::pair&lt;bool, std::size_t&gt;</a> __do_rehash
<a name="l01284"></a>01284       = _M_rehash_policy._M_need_rehash(_M_bucket_count,
<a name="l01285"></a>01285                         _M_element_count, 1);
<a name="l01286"></a>01286 
<a name="l01287"></a>01287     <span class="keywordflow">if</span> (__do_rehash.<a class="code" href="a00444.html#a198b03cffc037835dc1dc01c926ce251" title="second_type is the second bound type">first</a>)
<a name="l01288"></a>01288       {
<a name="l01289"></a>01289         <span class="keyword">const</span> key_type&amp; __k = this-&gt;_M_extract()(__v);
<a name="l01290"></a>01290         __n = _HCBase::_M_bucket_index(__k, __code, __do_rehash.<a class="code" href="a00444.html#a91179413226db12e66346d3673b7835f" title="first is a copy of the first object">second</a>);
<a name="l01291"></a>01291       }
<a name="l01292"></a>01292 
<a name="l01293"></a>01293     _Node* __new_node = <span class="keyword">nullptr</span>;
<a name="l01294"></a>01294     __try
<a name="l01295"></a>01295       {
<a name="l01296"></a>01296         <span class="comment">// Allocate the new node before doing the rehash so that we</span>
<a name="l01297"></a>01297         <span class="comment">// don&#39;t do a rehash if the allocation throws.</span>
<a name="l01298"></a>01298         __new_node = _M_allocate_node(std::forward&lt;_Arg&gt;(__v));
<a name="l01299"></a>01299         this-&gt;_M_store_code(__new_node, __code);
<a name="l01300"></a>01300         <span class="keywordflow">if</span> (__do_rehash.<a class="code" href="a00444.html#a198b03cffc037835dc1dc01c926ce251" title="second_type is the second bound type">first</a>)
<a name="l01301"></a>01301           _M_rehash(__do_rehash.<a class="code" href="a00444.html#a91179413226db12e66346d3673b7835f" title="first is a copy of the first object">second</a>, __saved_state);
<a name="l01302"></a>01302 
<a name="l01303"></a>01303         _M_insert_bucket_begin(__n, __new_node);
<a name="l01304"></a>01304         ++_M_element_count;
<a name="l01305"></a>01305         <span class="keywordflow">return</span> iterator(__new_node);
<a name="l01306"></a>01306       }
<a name="l01307"></a>01307     __catch(...)
<a name="l01308"></a>01308       {
<a name="l01309"></a>01309         <span class="keywordflow">if</span> (!__new_node)
<a name="l01310"></a>01310           _M_rehash_policy._M_reset(__saved_state);
<a name="l01311"></a>01311         <span class="keywordflow">else</span>
<a name="l01312"></a>01312           _M_deallocate_node(__new_node);
<a name="l01313"></a>01313         __throw_exception_again;
<a name="l01314"></a>01314       }
<a name="l01315"></a>01315       }
<a name="l01316"></a>01316 
<a name="l01317"></a>01317   <span class="comment">// Insert v if no element with its key is already present.</span>
<a name="l01318"></a>01318   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01319"></a>01319        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01320"></a>01320        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01321"></a>01321        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01322"></a>01322     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Arg&gt;
<a name="l01323"></a>01323       <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">std::pair</a>&lt;<span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator,
<a name="l01324"></a>01324                     _ExtractKey, _Equal, _H1,
<a name="l01325"></a>01325                     _H2, _Hash, _RehashPolicy,
<a name="l01326"></a>01326                     __chc, __cit, __uk&gt;::iterator, <span class="keywordtype">bool</span>&gt;
<a name="l01327"></a>01327       _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01328"></a>01328          _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01329"></a>01329       _M_insert(_Arg&amp;&amp; __v, <a class="code" href="a00432.html" title="integral_constant">std::true_type</a>)
<a name="l01330"></a>01330       {
<a name="l01331"></a>01331     <span class="keyword">const</span> key_type&amp; __k = this-&gt;_M_extract()(__v);
<a name="l01332"></a>01332     <span class="keyword">typename</span> _Hashtable::_Hash_code_type __code = this-&gt;_M_hash_code(__k);
<a name="l01333"></a>01333     size_type __n = _M_bucket_index(__k, __code);
<a name="l01334"></a>01334 
<a name="l01335"></a>01335     <span class="keywordflow">if</span> (_Node* __p = _M_find_node(__n, __k, __code))
<a name="l01336"></a>01336       <span class="keywordflow">return</span> <a class="code" href="a01576.html#a0409e288f07b697cb6885d1002df0bd6" title="A convenience wrapper for creating a pair from two objects.">std::make_pair</a>(iterator(__p), <span class="keyword">false</span>);
<a name="l01337"></a>01337     <span class="keywordflow">return</span> <a class="code" href="a01576.html#a0409e288f07b697cb6885d1002df0bd6" title="A convenience wrapper for creating a pair from two objects.">std::make_pair</a>(_M_insert_bucket(std::forward&lt;_Arg&gt;(__v),
<a name="l01338"></a>01338                   __n, __code), <span class="keyword">true</span>);
<a name="l01339"></a>01339       }
<a name="l01340"></a>01340 
<a name="l01341"></a>01341   <span class="comment">// Insert v unconditionally.</span>
<a name="l01342"></a>01342   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01343"></a>01343        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01344"></a>01344        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01345"></a>01345        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01346"></a>01346     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Arg&gt;
<a name="l01347"></a>01347       <span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01348"></a>01348               _H1, _H2, _Hash, _RehashPolicy,
<a name="l01349"></a>01349               __chc, __cit, __uk&gt;::iterator
<a name="l01350"></a>01350       _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01351"></a>01351          _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01352"></a>01352       _M_insert(_Arg&amp;&amp; __v, <a class="code" href="a00432.html" title="integral_constant">std::false_type</a>)
<a name="l01353"></a>01353       {
<a name="l01354"></a>01354     <span class="keyword">const</span> _RehashPolicyState&amp; __saved_state = _M_rehash_policy._M_state();
<a name="l01355"></a>01355     <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">std::pair&lt;bool, std::size_t&gt;</a> __do_rehash
<a name="l01356"></a>01356       = _M_rehash_policy._M_need_rehash(_M_bucket_count,
<a name="l01357"></a>01357                         _M_element_count, 1);
<a name="l01358"></a>01358 
<a name="l01359"></a>01359     <span class="comment">// First compute the hash code so that we don&#39;t do anything if it throws.</span>
<a name="l01360"></a>01360     <span class="keyword">typename</span> _Hashtable::_Hash_code_type __code
<a name="l01361"></a>01361       = this-&gt;_M_hash_code(this-&gt;_M_extract()(__v));
<a name="l01362"></a>01362 
<a name="l01363"></a>01363     _Node* __new_node = <span class="keyword">nullptr</span>;
<a name="l01364"></a>01364     __try
<a name="l01365"></a>01365       {
<a name="l01366"></a>01366         <span class="comment">// Second allocate new node so that we don&#39;t rehash if it throws.</span>
<a name="l01367"></a>01367         __new_node = _M_allocate_node(std::forward&lt;_Arg&gt;(__v));
<a name="l01368"></a>01368         this-&gt;_M_store_code(__new_node, __code);
<a name="l01369"></a>01369         <span class="keywordflow">if</span> (__do_rehash.<a class="code" href="a00444.html#a198b03cffc037835dc1dc01c926ce251" title="second_type is the second bound type">first</a>)
<a name="l01370"></a>01370         _M_rehash(__do_rehash.<a class="code" href="a00444.html#a91179413226db12e66346d3673b7835f" title="first is a copy of the first object">second</a>, __saved_state);
<a name="l01371"></a>01371 
<a name="l01372"></a>01372         <span class="comment">// Third, find the node before an equivalent one.</span>
<a name="l01373"></a>01373         size_type __bkt = _M_bucket_index(__new_node);
<a name="l01374"></a>01374         _BaseNode* __prev
<a name="l01375"></a>01375           = _M_find_before_node(__bkt, this-&gt;_M_extract()(__new_node-&gt;_M_v),
<a name="l01376"></a>01376                     __code);
<a name="l01377"></a>01377         <span class="keywordflow">if</span> (__prev)
<a name="l01378"></a>01378           {
<a name="l01379"></a>01379         <span class="comment">// Insert after the node before the equivalent one.</span>
<a name="l01380"></a>01380         __new_node-&gt;_M_nxt = __prev-&gt;_M_nxt;
<a name="l01381"></a>01381         __prev-&gt;_M_nxt = __new_node;
<a name="l01382"></a>01382           }
<a name="l01383"></a>01383         <span class="keywordflow">else</span>
<a name="l01384"></a>01384           <span class="comment">// The inserted node has no equivalent in the hashtable. We must</span>
<a name="l01385"></a>01385           <span class="comment">// insert the new node at the beginning of the bucket to preserve</span>
<a name="l01386"></a>01386           <span class="comment">// equivalent elements relative positions.</span>
<a name="l01387"></a>01387           _M_insert_bucket_begin(__bkt, __new_node);
<a name="l01388"></a>01388         ++_M_element_count;
<a name="l01389"></a>01389         <span class="keywordflow">return</span> iterator(__new_node);
<a name="l01390"></a>01390       }
<a name="l01391"></a>01391     __catch(...)
<a name="l01392"></a>01392       {
<a name="l01393"></a>01393         <span class="keywordflow">if</span> (!__new_node)
<a name="l01394"></a>01394           _M_rehash_policy._M_reset(__saved_state);
<a name="l01395"></a>01395         <span class="keywordflow">else</span>
<a name="l01396"></a>01396           _M_deallocate_node(__new_node);
<a name="l01397"></a>01397         __throw_exception_again;
<a name="l01398"></a>01398       }
<a name="l01399"></a>01399       }
<a name="l01400"></a>01400 
<a name="l01401"></a>01401   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01402"></a>01402        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01403"></a>01403        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01404"></a>01404        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01405"></a>01405     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _InputIterator&gt;
<a name="l01406"></a>01406       <span class="keywordtype">void</span>
<a name="l01407"></a>01407       _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01408"></a>01408          _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01409"></a>01409       insert(_InputIterator __first, _InputIterator __last)
<a name="l01410"></a>01410       {
<a name="l01411"></a>01411     size_type __n_elt = __detail::__distance_fw(__first, __last);
<a name="l01412"></a>01412     <span class="keyword">const</span> _RehashPolicyState&amp; __saved_state = _M_rehash_policy._M_state();
<a name="l01413"></a>01413     <a class="code" href="a00444.html" title="Struct holding two objects of arbitrary type.">std::pair&lt;bool, std::size_t&gt;</a> __do_rehash
<a name="l01414"></a>01414       = _M_rehash_policy._M_need_rehash(_M_bucket_count,
<a name="l01415"></a>01415                         _M_element_count, __n_elt);
<a name="l01416"></a>01416     <span class="keywordflow">if</span> (__do_rehash.<a class="code" href="a00444.html#a198b03cffc037835dc1dc01c926ce251" title="second_type is the second bound type">first</a>)
<a name="l01417"></a>01417       _M_rehash(__do_rehash.<a class="code" href="a00444.html#a91179413226db12e66346d3673b7835f" title="first is a copy of the first object">second</a>, __saved_state);
<a name="l01418"></a>01418 
<a name="l01419"></a>01419     <span class="keywordflow">for</span> (; __first != __last; ++__first)
<a name="l01420"></a>01420       this-&gt;insert(*__first);
<a name="l01421"></a>01421       }
<a name="l01422"></a>01422 
<a name="l01423"></a>01423   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01424"></a>01424        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01425"></a>01425        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01426"></a>01426        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01427"></a>01427     <span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01428"></a>01428             _H1, _H2, _Hash, _RehashPolicy,
<a name="l01429"></a>01429             __chc, __cit, __uk&gt;::iterator
<a name="l01430"></a>01430     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01431"></a>01431            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01432"></a>01432     erase(const_iterator __it)
<a name="l01433"></a>01433     {
<a name="l01434"></a>01434       _Node* __n = __it._M_cur;
<a name="l01435"></a>01435       std::size_t __bkt = _M_bucket_index(__n);
<a name="l01436"></a>01436 
<a name="l01437"></a>01437       <span class="comment">// Look for previous node to unlink it from the erased one, this is why</span>
<a name="l01438"></a>01438       <span class="comment">// we need buckets to contain the before begin to make this search fast.</span>
<a name="l01439"></a>01439       _BaseNode* __prev_n = _M_get_previous_node(__bkt, __n);
<a name="l01440"></a>01440       <span class="keywordflow">if</span> (__n == _M_bucket_begin(__bkt))
<a name="l01441"></a>01441     _M_remove_bucket_begin(__bkt, __n-&gt;_M_next(),
<a name="l01442"></a>01442        __n-&gt;_M_nxt ? _M_bucket_index(__n-&gt;_M_next()) : 0);
<a name="l01443"></a>01443       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (__n-&gt;_M_nxt)
<a name="l01444"></a>01444     {
<a name="l01445"></a>01445       size_type __next_bkt = _M_bucket_index(__n-&gt;_M_next());
<a name="l01446"></a>01446       <span class="keywordflow">if</span> (__next_bkt != __bkt)
<a name="l01447"></a>01447         _M_buckets[__next_bkt] = __prev_n;
<a name="l01448"></a>01448     }
<a name="l01449"></a>01449 
<a name="l01450"></a>01450       __prev_n-&gt;_M_nxt = __n-&gt;_M_nxt;
<a name="l01451"></a>01451       iterator __result(__n-&gt;_M_next());
<a name="l01452"></a>01452       _M_deallocate_node(__n);
<a name="l01453"></a>01453       --_M_element_count;
<a name="l01454"></a>01454 
<a name="l01455"></a>01455       <span class="keywordflow">return</span> __result;
<a name="l01456"></a>01456     }
<a name="l01457"></a>01457 
<a name="l01458"></a>01458   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01459"></a>01459        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01460"></a>01460        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01461"></a>01461        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01462"></a>01462     <span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01463"></a>01463             _H1, _H2, _Hash, _RehashPolicy,
<a name="l01464"></a>01464             __chc, __cit, __uk&gt;::size_type
<a name="l01465"></a>01465     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01466"></a>01466            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01467"></a>01467     erase(<span class="keyword">const</span> key_type&amp; __k)
<a name="l01468"></a>01468     {
<a name="l01469"></a>01469       <span class="keyword">typename</span> _Hashtable::_Hash_code_type __code = this-&gt;_M_hash_code(__k);
<a name="l01470"></a>01470       std::size_t __bkt = _M_bucket_index(__k, __code);
<a name="l01471"></a>01471       <span class="comment">// Look for the node before the first matching node.</span>
<a name="l01472"></a>01472       _BaseNode* __prev_n = _M_find_before_node(__bkt, __k, __code);
<a name="l01473"></a>01473       <span class="keywordflow">if</span> (!__prev_n)
<a name="l01474"></a>01474     <span class="keywordflow">return</span> 0;
<a name="l01475"></a>01475       _Node* __n = <span class="keyword">static_cast&lt;</span>_Node*<span class="keyword">&gt;</span>(__prev_n-&gt;_M_nxt);
<a name="l01476"></a>01476       <span class="keywordtype">bool</span> __is_bucket_begin = _M_buckets[__bkt] == __prev_n;
<a name="l01477"></a>01477 
<a name="l01478"></a>01478       <span class="comment">// We found a matching node, start deallocation loop from it</span>
<a name="l01479"></a>01479       std::size_t __next_bkt = __bkt;
<a name="l01480"></a>01480       _Node* __next_n = __n;
<a name="l01481"></a>01481       size_type __result = 0;
<a name="l01482"></a>01482       _Node* __saved_n = <span class="keyword">nullptr</span>;
<a name="l01483"></a>01483       <span class="keywordflow">do</span>
<a name="l01484"></a>01484     {
<a name="l01485"></a>01485       _Node* __p = __next_n;
<a name="l01486"></a>01486       __next_n = __p-&gt;_M_next();
<a name="l01487"></a>01487       <span class="comment">// _GLIBCXX_RESOLVE_LIB_DEFECTS</span>
<a name="l01488"></a>01488       <span class="comment">// 526. Is it undefined if a function in the standard changes</span>
<a name="l01489"></a>01489       <span class="comment">// in parameters?</span>
<a name="l01490"></a>01490       <span class="keywordflow">if</span> (<a class="code" href="a01615.html#gad66b096e6b2754b94943e989481dca57" title="Same as C++11 std::addressof.">std::__addressof</a>(this-&gt;_M_extract()(__p-&gt;_M_v))
<a name="l01491"></a>01491           != <a class="code" href="a01615.html#gad66b096e6b2754b94943e989481dca57" title="Same as C++11 std::addressof.">std::__addressof</a>(__k))
<a name="l01492"></a>01492         _M_deallocate_node(__p);
<a name="l01493"></a>01493       <span class="keywordflow">else</span>
<a name="l01494"></a>01494         __saved_n = __p;
<a name="l01495"></a>01495       --_M_element_count;
<a name="l01496"></a>01496       ++__result;
<a name="l01497"></a>01497       <span class="keywordflow">if</span> (!__next_n)
<a name="l01498"></a>01498         <span class="keywordflow">break</span>;
<a name="l01499"></a>01499       __next_bkt = _M_bucket_index(__next_n);
<a name="l01500"></a>01500     }
<a name="l01501"></a>01501       <span class="keywordflow">while</span> (__next_bkt == __bkt &amp;&amp; this-&gt;_M_equals(__k, __code, __next_n));
<a name="l01502"></a>01502 
<a name="l01503"></a>01503       <span class="keywordflow">if</span> (__saved_n)
<a name="l01504"></a>01504     _M_deallocate_node(__saved_n);
<a name="l01505"></a>01505       <span class="keywordflow">if</span> (__is_bucket_begin)
<a name="l01506"></a>01506     _M_remove_bucket_begin(__bkt, __next_n, __next_bkt);
<a name="l01507"></a>01507       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (__next_n &amp;&amp; __next_bkt != __bkt)
<a name="l01508"></a>01508     _M_buckets[__next_bkt] = __prev_n;
<a name="l01509"></a>01509       <span class="keywordflow">if</span> (__prev_n)
<a name="l01510"></a>01510     __prev_n-&gt;_M_nxt = __next_n;
<a name="l01511"></a>01511       <span class="keywordflow">return</span> __result;
<a name="l01512"></a>01512     }
<a name="l01513"></a>01513 
<a name="l01514"></a>01514   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01515"></a>01515        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01516"></a>01516        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01517"></a>01517        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01518"></a>01518     <span class="keyword">typename</span> _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01519"></a>01519             _H1, _H2, _Hash, _RehashPolicy,
<a name="l01520"></a>01520             __chc, __cit, __uk&gt;::iterator
<a name="l01521"></a>01521     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01522"></a>01522            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01523"></a>01523     erase(const_iterator __first, const_iterator __last)
<a name="l01524"></a>01524     {
<a name="l01525"></a>01525       _Node* __n = __first._M_cur;
<a name="l01526"></a>01526       _Node* __last_n = __last._M_cur;
<a name="l01527"></a>01527       <span class="keywordflow">if</span> (__n == __last_n)
<a name="l01528"></a>01528     <span class="keywordflow">return</span> iterator(__n);
<a name="l01529"></a>01529 
<a name="l01530"></a>01530       std::size_t __bkt = _M_bucket_index(__n);
<a name="l01531"></a>01531 
<a name="l01532"></a>01532       _BaseNode* __prev_n = _M_get_previous_node(__bkt, __n);
<a name="l01533"></a>01533       <span class="keywordtype">bool</span> __is_bucket_begin = __n == _M_bucket_begin(__bkt);
<a name="l01534"></a>01534       std::size_t __n_bkt = __bkt;
<a name="l01535"></a>01535       <span class="keywordflow">for</span> (;;)
<a name="l01536"></a>01536     {
<a name="l01537"></a>01537       <span class="keywordflow">do</span>
<a name="l01538"></a>01538         {
<a name="l01539"></a>01539           _Node* __tmp = __n;
<a name="l01540"></a>01540           __n = __n-&gt;_M_next();
<a name="l01541"></a>01541           _M_deallocate_node(__tmp);
<a name="l01542"></a>01542           --_M_element_count;
<a name="l01543"></a>01543           <span class="keywordflow">if</span> (!__n)
<a name="l01544"></a>01544         <span class="keywordflow">break</span>;
<a name="l01545"></a>01545           __n_bkt = _M_bucket_index(__n);
<a name="l01546"></a>01546         }
<a name="l01547"></a>01547       <span class="keywordflow">while</span> (__n != __last_n &amp;&amp; __n_bkt == __bkt);
<a name="l01548"></a>01548       <span class="keywordflow">if</span> (__is_bucket_begin)
<a name="l01549"></a>01549         _M_remove_bucket_begin(__bkt, __n, __n_bkt);
<a name="l01550"></a>01550       <span class="keywordflow">if</span> (__n == __last_n)
<a name="l01551"></a>01551         <span class="keywordflow">break</span>;
<a name="l01552"></a>01552       __is_bucket_begin = <span class="keyword">true</span>;
<a name="l01553"></a>01553       __bkt = __n_bkt;
<a name="l01554"></a>01554     }
<a name="l01555"></a>01555 
<a name="l01556"></a>01556       <span class="keywordflow">if</span> (__n &amp;&amp; (__n_bkt != __bkt || __is_bucket_begin))
<a name="l01557"></a>01557     _M_buckets[__n_bkt] = __prev_n;
<a name="l01558"></a>01558       __prev_n-&gt;_M_nxt = __n;
<a name="l01559"></a>01559       <span class="keywordflow">return</span> iterator(__n);
<a name="l01560"></a>01560     }
<a name="l01561"></a>01561 
<a name="l01562"></a>01562   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01563"></a>01563        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01564"></a>01564        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01565"></a>01565        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01566"></a>01566     <span class="keywordtype">void</span>
<a name="l01567"></a>01567     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01568"></a>01568            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01569"></a>01569     clear() noexcept
<a name="l01570"></a>01570     {
<a name="l01571"></a>01571       _M_deallocate_nodes(_M_begin());
<a name="l01572"></a>01572       __builtin_memset(_M_buckets, 0, _M_bucket_count * <span class="keyword">sizeof</span>(_Bucket));
<a name="l01573"></a>01573       _M_element_count = 0;
<a name="l01574"></a>01574       _M_before_begin._M_nxt = <span class="keyword">nullptr</span>;
<a name="l01575"></a>01575     }
<a name="l01576"></a>01576 
<a name="l01577"></a>01577   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01578"></a>01578        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01579"></a>01579        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01580"></a>01580        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01581"></a>01581     <span class="keywordtype">void</span>
<a name="l01582"></a>01582     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01583"></a>01583            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01584"></a>01584     rehash(size_type __n)
<a name="l01585"></a>01585     {
<a name="l01586"></a>01586       <span class="keyword">const</span> _RehashPolicyState&amp; __saved_state = _M_rehash_policy._M_state();
<a name="l01587"></a>01587       std::size_t __buckets
<a name="l01588"></a>01588     = _M_rehash_policy._M_bkt_for_elements(_M_element_count + 1);
<a name="l01589"></a>01589       <span class="keywordflow">if</span> (__buckets &lt;= __n)
<a name="l01590"></a>01590     __buckets = _M_rehash_policy._M_next_bkt(__n);
<a name="l01591"></a>01591 
<a name="l01592"></a>01592       <span class="keywordflow">if</span> (__buckets != _M_bucket_count)
<a name="l01593"></a>01593     {
<a name="l01594"></a>01594       _M_rehash(__buckets, __saved_state);
<a name="l01595"></a>01595       
<a name="l01596"></a>01596       <span class="comment">// We don&#39;t want the rehash policy to ask for the hashtable to shrink</span>
<a name="l01597"></a>01597       <span class="comment">// on the next insertion so we need to reset its previous resize</span>
<a name="l01598"></a>01598       <span class="comment">// level.</span>
<a name="l01599"></a>01599       _M_rehash_policy._M_prev_resize = 0;
<a name="l01600"></a>01600     }
<a name="l01601"></a>01601       <span class="keywordflow">else</span>
<a name="l01602"></a>01602     <span class="comment">// No rehash, restore previous state to keep a consistent state.</span>
<a name="l01603"></a>01603     _M_rehash_policy._M_reset(__saved_state);
<a name="l01604"></a>01604     }
<a name="l01605"></a>01605 
<a name="l01606"></a>01606   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01607"></a>01607        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01608"></a>01608        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01609"></a>01609        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01610"></a>01610     <span class="keywordtype">void</span>
<a name="l01611"></a>01611     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01612"></a>01612            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01613"></a>01613     _M_rehash(size_type __n, <span class="keyword">const</span> _RehashPolicyState&amp; __state)
<a name="l01614"></a>01614     {
<a name="l01615"></a>01615       __try
<a name="l01616"></a>01616     {
<a name="l01617"></a>01617       _M_rehash_aux(__n, integral_constant&lt;bool, __uk&gt;());
<a name="l01618"></a>01618     }
<a name="l01619"></a>01619       __catch(...)
<a name="l01620"></a>01620     {
<a name="l01621"></a>01621       <span class="comment">// A failure here means that buckets allocation failed.  We only</span>
<a name="l01622"></a>01622       <span class="comment">// have to restore hash policy previous state.</span>
<a name="l01623"></a>01623       _M_rehash_policy._M_reset(__state);
<a name="l01624"></a>01624       __throw_exception_again;
<a name="l01625"></a>01625     }
<a name="l01626"></a>01626     }
<a name="l01627"></a>01627 
<a name="l01628"></a>01628   <span class="comment">// Rehash when there is no equivalent elements.</span>
<a name="l01629"></a>01629   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01630"></a>01630        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01631"></a>01631        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01632"></a>01632        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01633"></a>01633     <span class="keywordtype">void</span>
<a name="l01634"></a>01634     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01635"></a>01635            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01636"></a>01636     _M_rehash_aux(size_type __n, <a class="code" href="a00432.html" title="integral_constant">std::true_type</a>)
<a name="l01637"></a>01637     {
<a name="l01638"></a>01638       _Bucket* __new_buckets = _M_allocate_buckets(__n);
<a name="l01639"></a>01639       _Node* __p = _M_begin();
<a name="l01640"></a>01640       _M_before_begin._M_nxt = <span class="keyword">nullptr</span>;
<a name="l01641"></a>01641       std::size_t __bbegin_bkt = 0;
<a name="l01642"></a>01642       <span class="keywordflow">while</span> (__p)
<a name="l01643"></a>01643     {
<a name="l01644"></a>01644       _Node* __next = __p-&gt;_M_next();
<a name="l01645"></a>01645       std::size_t __bkt = _HCBase::_M_bucket_index(__p, __n);
<a name="l01646"></a>01646       <span class="keywordflow">if</span> (!__new_buckets[__bkt])
<a name="l01647"></a>01647         {
<a name="l01648"></a>01648           __p-&gt;_M_nxt = _M_before_begin._M_nxt;
<a name="l01649"></a>01649           _M_before_begin._M_nxt = __p;
<a name="l01650"></a>01650           __new_buckets[__bkt] = &amp;_M_before_begin;
<a name="l01651"></a>01651           <span class="keywordflow">if</span> (__p-&gt;_M_nxt)
<a name="l01652"></a>01652         __new_buckets[__bbegin_bkt] = __p;
<a name="l01653"></a>01653           __bbegin_bkt = __bkt;
<a name="l01654"></a>01654         }
<a name="l01655"></a>01655       <span class="keywordflow">else</span>
<a name="l01656"></a>01656         {
<a name="l01657"></a>01657           __p-&gt;_M_nxt = __new_buckets[__bkt]-&gt;_M_nxt;
<a name="l01658"></a>01658           __new_buckets[__bkt]-&gt;_M_nxt = __p;
<a name="l01659"></a>01659         }
<a name="l01660"></a>01660       __p = __next;
<a name="l01661"></a>01661     }
<a name="l01662"></a>01662       _M_deallocate_buckets(_M_buckets, _M_bucket_count);
<a name="l01663"></a>01663       _M_bucket_count = __n;
<a name="l01664"></a>01664       _M_buckets = __new_buckets;
<a name="l01665"></a>01665     }
<a name="l01666"></a>01666 
<a name="l01667"></a>01667   <span class="comment">// Rehash when there can be equivalent elements, preserve their relative</span>
<a name="l01668"></a>01668   <span class="comment">// order.</span>
<a name="l01669"></a>01669   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, <span class="keyword">typename</span> _Value,
<a name="l01670"></a>01670        <span class="keyword">typename</span> _Allocator, <span class="keyword">typename</span> _ExtractKey, <span class="keyword">typename</span> _Equal,
<a name="l01671"></a>01671        <span class="keyword">typename</span> _H1, <span class="keyword">typename</span> _H2, <span class="keyword">typename</span> _Hash, <span class="keyword">typename</span> _RehashPolicy,
<a name="l01672"></a>01672        <span class="keywordtype">bool</span> __chc, <span class="keywordtype">bool</span> __cit, <span class="keywordtype">bool</span> __uk&gt;
<a name="l01673"></a>01673     <span class="keywordtype">void</span>
<a name="l01674"></a>01674     _Hashtable&lt;_Key, _Value, _Allocator, _ExtractKey, _Equal,
<a name="l01675"></a>01675            _H1, _H2, _Hash, _RehashPolicy, __chc, __cit, __uk&gt;::
<a name="l01676"></a>01676     _M_rehash_aux(size_type __n, <a class="code" href="a00432.html" title="integral_constant">std::false_type</a>)
<a name="l01677"></a>01677     {
<a name="l01678"></a>01678       _Bucket* __new_buckets = _M_allocate_buckets(__n);
<a name="l01679"></a>01679 
<a name="l01680"></a>01680       _Node* __p = _M_begin();
<a name="l01681"></a>01681       _M_before_begin._M_nxt = <span class="keyword">nullptr</span>;
<a name="l01682"></a>01682       std::size_t __bbegin_bkt = 0;
<a name="l01683"></a>01683       std::size_t __prev_bkt = 0;
<a name="l01684"></a>01684       _Node* __prev_p = <span class="keyword">nullptr</span>;
<a name="l01685"></a>01685       <span class="keywordtype">bool</span> __check_bucket = <span class="keyword">false</span>;
<a name="l01686"></a>01686 
<a name="l01687"></a>01687       <span class="keywordflow">while</span> (__p)
<a name="l01688"></a>01688     {
<a name="l01689"></a>01689       _Node* __next = __p-&gt;_M_next();
<a name="l01690"></a>01690       std::size_t __bkt = _HCBase::_M_bucket_index(__p, __n);
<a name="l01691"></a>01691 
<a name="l01692"></a>01692       <span class="keywordflow">if</span> (__prev_p &amp;&amp; __prev_bkt == __bkt)
<a name="l01693"></a>01693         {
<a name="l01694"></a>01694           <span class="comment">// Previous insert was already in this bucket, we insert after</span>
<a name="l01695"></a>01695           <span class="comment">// the previously inserted one to preserve equivalent elements</span>
<a name="l01696"></a>01696           <span class="comment">// relative order.</span>
<a name="l01697"></a>01697           __p-&gt;_M_nxt = __prev_p-&gt;_M_nxt;
<a name="l01698"></a>01698           __prev_p-&gt;_M_nxt = __p;
<a name="l01699"></a>01699           
<a name="l01700"></a>01700           <span class="comment">// Inserting after a node in a bucket require to check that we</span>
<a name="l01701"></a>01701           <span class="comment">// haven&#39;t change the bucket last node, in this case next</span>
<a name="l01702"></a>01702           <span class="comment">// bucket containing its before begin node must be updated. We</span>
<a name="l01703"></a>01703           <span class="comment">// schedule a check as soon as we move out of the sequence of</span>
<a name="l01704"></a>01704           <span class="comment">// equivalent nodes to limit the number of checks.</span>
<a name="l01705"></a>01705           __check_bucket = <span class="keyword">true</span>;
<a name="l01706"></a>01706         }
<a name="l01707"></a>01707       <span class="keywordflow">else</span>
<a name="l01708"></a>01708         {
<a name="l01709"></a>01709           <span class="keywordflow">if</span> (__check_bucket)
<a name="l01710"></a>01710         {
<a name="l01711"></a>01711           <span class="comment">// Check if we shall update the next bucket because of</span>
<a name="l01712"></a>01712           <span class="comment">// insertions into __prev_bkt bucket.</span>
<a name="l01713"></a>01713           <span class="keywordflow">if</span> (__prev_p-&gt;_M_nxt)
<a name="l01714"></a>01714             {
<a name="l01715"></a>01715               std::size_t __next_bkt
<a name="l01716"></a>01716             = _HCBase::_M_bucket_index(__prev_p-&gt;_M_next(), __n);
<a name="l01717"></a>01717               <span class="keywordflow">if</span> (__next_bkt != __prev_bkt)
<a name="l01718"></a>01718             __new_buckets[__next_bkt] = __prev_p;
<a name="l01719"></a>01719             }
<a name="l01720"></a>01720           __check_bucket = <span class="keyword">false</span>;
<a name="l01721"></a>01721         }
<a name="l01722"></a>01722           <span class="keywordflow">if</span> (!__new_buckets[__bkt])
<a name="l01723"></a>01723         {
<a name="l01724"></a>01724           __p-&gt;_M_nxt = _M_before_begin._M_nxt;
<a name="l01725"></a>01725           _M_before_begin._M_nxt = __p;
<a name="l01726"></a>01726           __new_buckets[__bkt] = &amp;_M_before_begin;
<a name="l01727"></a>01727           <span class="keywordflow">if</span> (__p-&gt;_M_nxt)
<a name="l01728"></a>01728             __new_buckets[__bbegin_bkt] = __p;
<a name="l01729"></a>01729           __bbegin_bkt = __bkt;
<a name="l01730"></a>01730         }
<a name="l01731"></a>01731           <span class="keywordflow">else</span>
<a name="l01732"></a>01732         {
<a name="l01733"></a>01733           __p-&gt;_M_nxt = __new_buckets[__bkt]-&gt;_M_nxt;
<a name="l01734"></a>01734           __new_buckets[__bkt]-&gt;_M_nxt = __p;
<a name="l01735"></a>01735         }
<a name="l01736"></a>01736         }
<a name="l01737"></a>01737 
<a name="l01738"></a>01738       __prev_p = __p;
<a name="l01739"></a>01739       __prev_bkt = __bkt;
<a name="l01740"></a>01740       __p = __next;
<a name="l01741"></a>01741     }
<a name="l01742"></a>01742 
<a name="l01743"></a>01743       <span class="keywordflow">if</span> (__check_bucket &amp;&amp; __prev_p-&gt;_M_nxt)
<a name="l01744"></a>01744     {
<a name="l01745"></a>01745       std::size_t __next_bkt
<a name="l01746"></a>01746         = _HCBase::_M_bucket_index(__prev_p-&gt;_M_next(), __n);
<a name="l01747"></a>01747       <span class="keywordflow">if</span> (__next_bkt != __prev_bkt)
<a name="l01748"></a>01748         __new_buckets[__next_bkt] = __prev_p;
<a name="l01749"></a>01749     }
<a name="l01750"></a>01750 
<a name="l01751"></a>01751       _M_deallocate_buckets(_M_buckets, _M_bucket_count);
<a name="l01752"></a>01752       _M_bucket_count = __n;
<a name="l01753"></a>01753       _M_buckets = __new_buckets;
<a name="l01754"></a>01754     }
<a name="l01755"></a>01755 
<a name="l01756"></a>01756 _GLIBCXX_END_NAMESPACE_VERSION
<a name="l01757"></a>01757 } <span class="comment">// namespace std</span>
<a name="l01758"></a>01758 
<a name="l01759"></a>01759 <span class="preprocessor">#endif // _HASHTABLE_H</span>
</pre></div></div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a01197.html">hashtable.h</a>      </li>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
