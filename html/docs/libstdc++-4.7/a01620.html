<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libstdc++: Sorting</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a01620.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Sorting</div>  </div>
<div class="ingroups"><a class="el" href="a01617.html">Algorithms</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Sorting:</div>
<div class="dyncontent">
<center><table><tr><td><img src="a01620.png" border="0" alt="" usemap="#a01620"/>
<map name="a01620" id="a01620">
<area shape="rect" id="node1" href="a01622.html" title="Binary Search" alt="" coords="257,5,364,33"/><area shape="rect" id="node2" href="a01621.html" title="Set Operation" alt="" coords="256,55,365,83"/><area shape="rect" id="node3" href="a01636.html" title="Heap" alt="" coords="284,106,337,134"/><area shape="rect" id="node4" href="a01617.html" title="Algorithms" alt="" coords="5,55,93,83"/></map>
</td></tr></table></center>
</div>
<h2><a name="groups"></a>
Modules</h2>
<ul>
<li><a class="el" href="a01621.html">Set Operation</a>
<li><a class="el" href="a01622.html">Binary Search</a>
<li><a class="el" href="a01636.html">Heap</a>
</ul>
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li>template&lt;typename _BidirectionalIterator &gt; void <a class="el" href="a01620.html#ga5e5479e1ac5e92b0c1f77bcf762d07e9">std::inplace_merge</a> (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)
<li>template&lt;typename _BidirectionalIterator , typename _Compare &gt; void <a class="el" href="a01620.html#gaf6a8379ab8a648fd05d52ed0632081fa">std::inplace_merge</a> (_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp)
<li>template&lt;typename _ForwardIterator &gt; bool <a class="el" href="a01620.html#ga3a5337f3b4d2394123033a6c6279abbb">std::is_sorted</a> (_ForwardIterator __first, _ForwardIterator __last)
<li>template&lt;typename _ForwardIterator , typename _Compare &gt; bool <a class="el" href="a01620.html#gaba6fffa1d87bd34155dcd980bbe02a53">std::is_sorted</a> (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
<li>template&lt;typename _ForwardIterator &gt; _ForwardIterator <a class="el" href="a01620.html#ga76cfb20887dfce8ce554053b6b6935c9">std::is_sorted_until</a> (_ForwardIterator __first, _ForwardIterator __last)
<li>template&lt;typename _ForwardIterator , typename _Compare &gt; _ForwardIterator <a class="el" href="a01620.html#ga07069e2148fa7ce5fc6df47a43fd8240">std::is_sorted_until</a> (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
<li>template&lt;typename _II1 , typename _II2 &gt; bool <a class="el" href="a01620.html#ga869d1fd6bb4929ef491edbfdbcc9f7b9">std::lexicographical_compare</a> (_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
<li>template&lt;typename _II1 , typename _II2 , typename _Compare &gt; bool <a class="el" href="a01620.html#gae179ce2d015dc0908973644687dce4c6">std::lexicographical_compare</a> (_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)
<li>template&lt;typename _Tp &gt; const _Tp &amp; <a class="el" href="a01620.html#ga47fe7a943a5b88c1bba1032392a04671">std::max</a> (const _Tp &amp;__a, const _Tp &amp;__b)
<li>template&lt;typename _Tp , typename _Compare &gt; const _Tp &amp; <a class="el" href="a01620.html#gaa927592dda302adb422eedd6e7b040f0">std::max</a> (const _Tp &amp;__a, const _Tp &amp;__b, _Compare __comp)
<li>template&lt;typename _ForwardIterator &gt; _ForwardIterator <a class="el" href="a01620.html#ga9d27c4bd0748ad81515f72d603fee104">std::max_element</a> (_ForwardIterator __first, _ForwardIterator __last)
<li>template&lt;typename _ForwardIterator , typename _Compare &gt; _ForwardIterator <a class="el" href="a01620.html#ga22977acf55fc52777acd326745a815fe">std::max_element</a> (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
<li>template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; _OutputIterator <a class="el" href="a01620.html#gabb18bc670a27e539246a2eb154f60351">std::merge</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)
<li>template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; _OutputIterator <a class="el" href="a01620.html#ga7f7771648d074e296d019153633efa8d">std::merge</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)
<li>template&lt;typename _Tp &gt; const _Tp &amp; <a class="el" href="a01620.html#ga976d02d45bf6128ae0490642d5961ced">std::min</a> (const _Tp &amp;__a, const _Tp &amp;__b)
<li>template&lt;typename _Tp , typename _Compare &gt; const _Tp &amp; <a class="el" href="a01620.html#gacdb5fe7f1f3affda3dbb77c4fe775e30">std::min</a> (const _Tp &amp;__a, const _Tp &amp;__b, _Compare __comp)
<li>template&lt;typename _ForwardIterator &gt; _ForwardIterator <a class="el" href="a01620.html#gaa6857903fa35b3bd21350dec28bfc83b">std::min_element</a> (_ForwardIterator __first, _ForwardIterator __last)
<li>template&lt;typename _ForwardIterator , typename _Compare &gt; _ForwardIterator <a class="el" href="a01620.html#ga47cab3ee8aa0738016547d35568f757d">std::min_element</a> (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
<li>template&lt;typename _Tp &gt; pair&lt; const _Tp &amp;, const _Tp &amp; &gt; <a class="el" href="a01620.html#ga2e3e87fd06f7a5c2a0b82f8b01f5d694">std::minmax</a> (const _Tp &amp;__a, const _Tp &amp;__b)
<li>template&lt;typename _Tp , typename _Compare &gt; pair&lt; const _Tp &amp;, const _Tp &amp; &gt; <a class="el" href="a01620.html#gabe59501644630ae801b467a2b0c4c55c">std::minmax</a> (const _Tp &amp;__a, const _Tp &amp;__b, _Compare __comp)
<li>template&lt;typename _ForwardIterator &gt; pair&lt; _ForwardIterator, <br class="typebreak"/>
_ForwardIterator &gt; <a class="el" href="a01620.html#ga3953de9d28749a9c8a48c11a8983b9c1">std::minmax_element</a> (_ForwardIterator __first, _ForwardIterator __last)
<li>template&lt;typename _ForwardIterator , typename _Compare &gt; pair&lt; _ForwardIterator, <br class="typebreak"/>
_ForwardIterator &gt; <a class="el" href="a01620.html#gac6543caa897ff4c33276e6835d4f9498">std::minmax_element</a> (_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)
<li>template&lt;typename _BidirectionalIterator &gt; bool <a class="el" href="a01620.html#ga0a84cc794bbfca40a0664edaedd05c34">std::next_permutation</a> (_BidirectionalIterator __first, _BidirectionalIterator __last)
<li>template&lt;typename _BidirectionalIterator , typename _Compare &gt; bool <a class="el" href="a01620.html#ga84b626c10da677e22bdbbb058cc8e7da">std::next_permutation</a> (_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
<li>template&lt;typename _RandomAccessIterator &gt; void <a class="el" href="a01620.html#ga3a4f2ca9c1c627576aeeaa99181c8c63">std::nth_element</a> (_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)
<li>template&lt;typename _RandomAccessIterator , typename _Compare &gt; void <a class="el" href="a01620.html#ga6d43f0d62204409f18762c8e1bf1867b">std::nth_element</a> (_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)
<li>template&lt;typename _RandomAccessIterator &gt; void <a class="el" href="a01620.html#ga91f25d546637f075de3958a25928b687">std::partial_sort</a> (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)
<li>template&lt;typename _RandomAccessIterator , typename _Compare &gt; void <a class="el" href="a01620.html#ga6401ff7e25d2ef7a6119d894cb40eec0">std::partial_sort</a> (_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)
<li>template&lt;typename _InputIterator , typename _RandomAccessIterator &gt; _RandomAccessIterator <a class="el" href="a01620.html#ga7b262260421978833cc1b1c6b3969bb4">std::partial_sort_copy</a> (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)
<li>template&lt;typename _InputIterator , typename _RandomAccessIterator , typename _Compare &gt; _RandomAccessIterator <a class="el" href="a01620.html#gaf53e3f9d5e3c9cd4d36a0801d411e324">std::partial_sort_copy</a> (_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)
<li>template&lt;typename _BidirectionalIterator &gt; bool <a class="el" href="a01620.html#ga0b0e35a43f5f87ea1c66363be3a34619">std::prev_permutation</a> (_BidirectionalIterator __first, _BidirectionalIterator __last)
<li>template&lt;typename _BidirectionalIterator , typename _Compare &gt; bool <a class="el" href="a01620.html#ga44e9b1d39001f68fa9fcb408b25a77f0">std::prev_permutation</a> (_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)
<li>template&lt;typename _RandomAccessIterator &gt; void <a class="el" href="a01620.html#ga4ea03048647c50ea7cbdd5da30e82755">std::sort</a> (_RandomAccessIterator __first, _RandomAccessIterator __last)
<li>template&lt;typename _RandomAccessIterator , typename _Compare &gt; void <a class="el" href="a01620.html#gae3c0067ae83db1824367ded659a960b2">std::sort</a> (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
<li>template&lt;typename _RandomAccessIterator &gt; void <a class="el" href="a01620.html#ga7d8bb8e52b7b0e80301dcbec17225b4a">std::stable_sort</a> (_RandomAccessIterator __first, _RandomAccessIterator __last)
<li>template&lt;typename _RandomAccessIterator , typename _Compare &gt; void <a class="el" href="a01620.html#ga3a3ce3aa8ac2297f8290939a7988596d">std::stable_sort</a> (_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)
</ul>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga5e5479e1ac5e92b0c1f77bcf762d07e9"></a><!-- doxytag: member="std::inplace_merge" ref="ga5e5479e1ac5e92b0c1f77bcf762d07e9" args="(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::inplace_merge </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merges two sorted ranges in place. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>Merges two sorted and consecutive ranges, [__first,__middle) and [__middle,__last), and puts the result in [__first,__last). The output will be sorted. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>If enough additional memory is available, this takes (__last-__first)-1 comparisons. Otherwise an NlogN algorithm is used, where N is distance(__first,__last). </p>

<p>Definition at line <a class="el" href="a01462_source.html#l03179">3179</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l02959">std::__merge_adaptive()</a>, <a class="el" href="a01462_source.html#l03072">std::__merge_without_buffer()</a>, <a class="el" href="a01483_source.html#l00153">std::_Temporary_buffer&lt; _ForwardIterator, _Tp &gt;::begin()</a>, <a class="el" href="a01470_source.html#l00114">std::distance()</a>, and <a class="el" href="a01483_source.html#l00143">std::_Temporary_buffer&lt; _ForwardIterator, _Tp &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf6a8379ab8a648fd05d52ed0632081fa"></a><!-- doxytag: member="std::inplace_merge" ref="gaf6a8379ab8a648fd05d52ed0632081fa" args="(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::inplace_merge </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merges two sorted ranges in place. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>Merges two sorted and consecutive ranges, [__first,__middle) and [middle,last), and puts the result in [__first,__last). The output will be sorted. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>If enough additional memory is available, this takes (__last-__first)-1 comparisons. Otherwise an NlogN algorithm is used, where N is distance(__first,__last).</p>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l03234">3234</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l02959">std::__merge_adaptive()</a>, <a class="el" href="a01462_source.html#l03072">std::__merge_without_buffer()</a>, <a class="el" href="a01483_source.html#l00153">std::_Temporary_buffer&lt; _ForwardIterator, _Tp &gt;::begin()</a>, <a class="el" href="a01470_source.html#l00114">std::distance()</a>, and <a class="el" href="a01483_source.html#l00143">std::_Temporary_buffer&lt; _ForwardIterator, _Tp &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a5337f3b4d2394123033a6c6279abbb"></a><!-- doxytag: member="std::is_sorted" ref="ga3a5337f3b4d2394123033a6c6279abbb" args="(_ForwardIterator __first, _ForwardIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::is_sorted </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the elements of a sequence are sorted. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the elements are sorted, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l03977">3977</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l04034">std::is_sorted_until()</a>.</p>

</div>
</div>
<a class="anchor" id="gaba6fffa1d87bd34155dcd980bbe02a53"></a><!-- doxytag: member="std::is_sorted" ref="gaba6fffa1d87bd34155dcd980bbe02a53" args="(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::is_sorted </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines whether the elements of a sequence are sorted according to a comparison functor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the elements are sorted, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l03991">3991</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l04034">std::is_sorted_until()</a>.</p>

</div>
</div>
<a class="anchor" id="ga76cfb20887dfce8ce554053b6b6935c9"></a><!-- doxytag: member="std::is_sorted_until" ref="ga76cfb20887dfce8ce554053b6b6935c9" args="(_ForwardIterator __first, _ForwardIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the end of a sorted sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the last iterator i in [__first, __last) for which the range [__first, i) is sorted. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l04005">4005</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga07069e2148fa7ce5fc6df47a43fd8240"></a><!-- doxytag: member="std::is_sorted_until" ref="ga07069e2148fa7ce5fc6df47a43fd8240" args="(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::is_sorted_until </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the end of a sorted sequence using comparison functor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the last iterator i in [__first, __last) for which the range [__first, i) is sorted. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l04034">4034</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>Referenced by <a class="el" href="a01462_source.html#l03977">std::is_sorted()</a>.</p>

</div>
</div>
<a class="anchor" id="ga869d1fd6bb4929ef491edbfdbcc9f7b9"></a><!-- doxytag: member="std::lexicographical_compare" ref="ga869d1fd6bb4929ef491edbfdbcc9f7b9" args="(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _II1 , typename _II2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II2&#160;</td>
          <td class="paramname"><em>__last2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs <b>dictionary</b> comparison on ranges. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>An input iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A boolean true or false.</dd></dl>
<p><em>Returns true if the sequence of elements defined by the range [first1,last1) is lexicographically less than the sequence of elements defined by the range [first2,last2). Returns false otherwise.</em> (Quoted from [25.3.8]/1.) If the iterators are all character pointers, then this is an inline call to <code>memcmp</code>. </p>

<p>Definition at line <a class="el" href="a01463_source.html#l01086">1086</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae179ce2d015dc0908973644687dce4c6"></a><!-- doxytag: member="std::lexicographical_compare" ref="gae179ce2d015dc0908973644687dce4c6" args="(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _II1 , typename _II2 , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::lexicographical_compare </td>
          <td>(</td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs <b>dictionary</b> comparison on ranges. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A <a class="el" href="a01631.html">comparison functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A boolean true or false.</dd></dl>
<p>The same as the four-parameter <code>lexicographical_compare</code>, but uses the comp parameter instead of <code>&lt;</code>. </p>

<p>Definition at line <a class="el" href="a01463_source.html#l01120">1120</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

<p>Referenced by <a class="el" href="a01168_source.html#l01277">std::operator&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="ga47fe7a943a5b88c1bba1032392a04671"></a><!-- doxytag: member="std::max" ref="ga47fe7a943a5b88c1bba1032392a04671" args="(const _Tp &amp;__a, const _Tp &amp;__b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; <a class="el" href="a01620.html#ga47fe7a943a5b88c1bba1032392a04671">std::max</a> </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The greater of the parameters.</dd></dl>
<p>This is the simple classic generic implementation. It will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

<p>Definition at line <a class="el" href="a01463_source.html#l00210">210</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

<p>Referenced by <a class="el" href="a01466_source.html#l00583">std::_Deque_base&lt; _Tp, _Alloc &gt;::_M_initialize_map()</a>, <a class="el" href="a01107_source.html#l00872">std::deque&lt; _Tp, _Alloc &gt;::_M_reallocate_map()</a>, <a class="el" href="a01111_source.html#l01165">std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;::max_size()</a>, <a class="el" href="a01368_source.html#l00732">std::independent_bits_engine&lt; _RandomNumberEngine, __w, _UIntType &gt;::operator()()</a>, and <a class="el" href="a01452_source.html#l00082">std::basic_stringbuf&lt; _CharT, _Traits, _Alloc &gt;::overflow()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa927592dda302adb422eedd6e7b040f0"></a><!-- doxytag: member="std::max" ref="gaa927592dda302adb422eedd6e7b040f0" args="(const _Tp &amp;__a, const _Tp &amp;__b, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; <a class="el" href="a01620.html#ga47fe7a943a5b88c1bba1032392a04671">std::max</a> </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__comp</td><td>A <a class="el" href="a01631.html">comparison functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The greater of the parameters.</dd></dl>
<p>This will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

<p>Definition at line <a class="el" href="a01463_source.html#l00254">254</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9d27c4bd0748ad81515f72d603fee104"></a><!-- doxytag: member="std::max_element" ref="ga9d27c4bd0748ad81515f72d603fee104" args="(_ForwardIterator __first, _ForwardIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::max_element </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the maximum element in a range. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Iterator referencing the first instance of the largest value. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l06300">6300</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga22977acf55fc52777acd326745a815fe"></a><!-- doxytag: member="std::max_element" ref="ga22977acf55fc52777acd326745a815fe" args="(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::max_element </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the maximum element in a range using comparison functor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Iterator referencing the first instance of the largest value according to __comp. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l06328">6328</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>Referenced by <a class="el" href="a01547_source.html#l01030">std::valarray&lt; _Tp &gt;::max()</a>.</p>

</div>
</div>
<a class="anchor" id="gabb18bc670a27e539246a2eb154f60351"></a><!-- doxytag: member="std::merge" ref="gabb18bc670a27e539246a2eb154f60351" args="(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::merge </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merges two sorted ranges. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An iterator pointing to the end of the merged range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the first element <em>not less than</em> <em>val</em>.</dd></dl>
<p>Merges the ranges <code></code>[__first1,__last1) and <code></code>[__first2,__last2) into the sorted range <code></code>[__result, __result + (__last1-__first1) + (__last2-__first2)). Both input ranges must be sorted, and the output range must not overlap with either of the input ranges. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05542">5542</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7f7771648d074e296d019153633efa8d"></a><!-- doxytag: member="std::merge" ref="ga7f7771648d074e296d019153633efa8d" args="(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::merge </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Merges two sorted ranges. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last2</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An iterator pointing to the end of the merged range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A functor to use for comparisons. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the first element "not less
                  than" <em>val</em>.</dd></dl>
<p>Merges the ranges <code></code>[__first1,__last1) and <code></code>[__first2,__last2) into the sorted range <code></code>[__result, __result + (__last1-__first1) + (__last2-__first2)). Both input ranges must be sorted, and the output range must not overlap with either of the input ranges. The sort is <em>stable</em>, that is, for equivalent elements in the two ranges, elements from the first range will always come before elements from the second.</p>
<p>The comparison function should have the same effects on ordering as the function used for the initial sort. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05606">5606</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga976d02d45bf6128ae0490642d5961ced"></a><!-- doxytag: member="std::min" ref="ga976d02d45bf6128ae0490642d5961ced" args="(const _Tp &amp;__a, const _Tp &amp;__b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; <a class="el" href="a01620.html#ga976d02d45bf6128ae0490642d5961ced">std::min</a> </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The lesser of the parameters.</dd></dl>
<p>This is the simple classic generic implementation. It will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

<p>Definition at line <a class="el" href="a01463_source.html#l00187">187</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

<p>Referenced by <a class="el" href="a01356_source.html#l00440">__gnu_profile::__report()</a>, <a class="el" href="a01556_source.html#l01930">__gnu_cxx::__versa_string&lt; _CharT, _Traits, _Alloc, _Base &gt;::compare()</a>, <a class="el" href="a00970_source.html#l02222">std::basic_string&lt; char &gt;::compare()</a>, <a class="el" href="a00971_source.html#l00918">std::basic_string&lt; _CharT, _Traits, _Alloc &gt;::compare()</a>, <a class="el" href="a01368_source.html#l02838">std::generate_canonical()</a>, <a class="el" href="a01452_source.html#l00082">std::basic_stringbuf&lt; _CharT, _Traits, _Alloc &gt;::overflow()</a>, <a class="el" href="a00946_source.html#l00269">__gnu_cxx::random_sample_n()</a>, <a class="el" href="a01236_source.html#l00681">std::basic_istream&lt; _CharT, _Traits &gt;::readsome()</a>, <a class="el" href="a01557_source.html#l00313">__gnu_cxx::__versa_string&lt; _CharT, _Traits, _Alloc, _Base &gt;::rfind()</a>, <a class="el" href="a00971_source.html#l00780">std::basic_string&lt; _CharT, _Traits, _Alloc &gt;::rfind()</a>, <a class="el" href="a01171_source.html#l00206">std::basic_filebuf&lt; _CharT, _Traits &gt;::underflow()</a>, <a class="el" href="a01489_source.html#l00047">std::basic_streambuf&lt; _CharT, _Traits &gt;::xsgetn()</a>, <a class="el" href="a01171_source.html#l00639">std::basic_filebuf&lt; _CharT, _Traits &gt;::xsputn()</a>, and <a class="el" href="a01489_source.html#l00081">std::basic_streambuf&lt; _CharT, _Traits &gt;::xsputn()</a>.</p>

</div>
</div>
<a class="anchor" id="gacdb5fe7f1f3affda3dbb77c4fe775e30"></a><!-- doxytag: member="std::min" ref="gacdb5fe7f1f3affda3dbb77c4fe775e30" args="(const _Tp &amp;__a, const _Tp &amp;__b, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const _Tp &amp; <a class="el" href="a01620.html#ga976d02d45bf6128ae0490642d5961ced">std::min</a> </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This does what you think it does. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__comp</td><td>A <a class="el" href="a01631.html">comparison functor</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The lesser of the parameters.</dd></dl>
<p>This will work on temporary expressions, since they are only evaluated once, unlike a preprocessor macro. </p>

<p>Definition at line <a class="el" href="a01463_source.html#l00233">233</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaa6857903fa35b3bd21350dec28bfc83b"></a><!-- doxytag: member="std::min_element" ref="gaa6857903fa35b3bd21350dec28bfc83b" args="(_ForwardIterator __first, _ForwardIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::min_element </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the minimum element in a range. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Iterator referencing the first instance of the smallest value. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l06244">6244</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga47cab3ee8aa0738016547d35568f757d"></a><!-- doxytag: member="std::min_element" ref="ga47cab3ee8aa0738016547d35568f757d" args="(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::min_element </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the minimum element in a range using comparison functor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Iterator referencing the first instance of the smallest value according to __comp. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l06272">6272</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>Referenced by <a class="el" href="a01547_source.html#l01022">std::valarray&lt; _Tp &gt;::min()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2e3e87fd06f7a5c2a0b82f8b01f5d694"></a><!-- doxytag: member="std::minmax" ref="ga2e3e87fd06f7a5c2a0b82f8b01f5d694" args="(const _Tp &amp;__a, const _Tp &amp;__b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; const _Tp &amp;, const _Tp &amp; &gt; <a class="el" href="a01620.html#ga2e3e87fd06f7a5c2a0b82f8b01f5d694">std::minmax</a> </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines min and max at once as an ordered pair. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pair(__b, __a) if __b is smaller than __a, pair(__a, __b) otherwise. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l04064">4064</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gabe59501644630ae801b467a2b0c4c55c"></a><!-- doxytag: member="std::minmax" ref="gabe59501644630ae801b467a2b0c4c55c" args="(const _Tp &amp;__a, const _Tp &amp;__b, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Tp , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; const _Tp &amp;, const _Tp &amp; &gt; <a class="el" href="a01620.html#ga2e3e87fd06f7a5c2a0b82f8b01f5d694">std::minmax</a> </td>
          <td>(</td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines min and max at once as an ordered pair. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>A thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__b</td><td>Another thing of arbitrary type. </td></tr>
    <tr><td class="paramname">__comp</td><td>A <a class="el" href="a01631.html">comparison functor </a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pair(__b, __a) if __b is smaller than __a, pair(__a, __b) otherwise. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l04084">4084</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga3953de9d28749a9c8a48c11a8983b9c1"></a><!-- doxytag: member="std::minmax_element" ref="ga3953de9d28749a9c8a48c11a8983b9c1" args="(_ForwardIterator __first, _ForwardIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;_ForwardIterator, _ForwardIterator&gt; std::minmax_element </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a pair of iterators pointing to the minimum and maximum elements in a range. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>make_pair(m, M), where m is the first iterator i in [__first, __last) such that no other element in the range is smaller, and where M is the last iterator i in [__first, __last) such that no other element in the range is larger. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l04103">4103</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01477_source.html#l00268">std::make_pair()</a>.</p>

</div>
</div>
<a class="anchor" id="gac6543caa897ff4c33276e6835d4f9498"></a><!-- doxytag: member="std::minmax_element" ref="gac6543caa897ff4c33276e6835d4f9498" args="(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;_ForwardIterator, _ForwardIterator&gt; std::minmax_element </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return a pair of iterators pointing to the minimum and maximum elements in a range. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>Comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>make_pair(m, M), where m is the first iterator i in [__first, __last) such that no other element in the range is smaller, and where M is the last iterator i in [__first, __last) such that no other element in the range is larger. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l04179">4179</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01477_source.html#l00268">std::make_pair()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0a84cc794bbfca40a0664edaedd05c34"></a><!-- doxytag: member="std::next_permutation" ref="ga0a84cc794bbfca40a0664edaedd05c34" args="(_BidirectionalIterator __first, _BidirectionalIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::next_permutation </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permute range into the next <em>dictionary</em> ordering. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>False if wrapped to first permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range as a set of <em>dictionary</em> sorted sequences. Permutes the current sequence into the next one of this set. Returns true if there are more sequences to generate. If the sequence is the largest of the set, the smallest is generated and false returned. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l03679">3679</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01463_source.html#l00118">std::iter_swap()</a>, and <a class="el" href="a01462_source.html#l01468">std::reverse()</a>.</p>

</div>
</div>
<a class="anchor" id="ga84b626c10da677e22bdbbb058cc8e7da"></a><!-- doxytag: member="std::next_permutation" ref="ga84b626c10da677e22bdbbb058cc8e7da" args="(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::next_permutation </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permute range into the next <em>dictionary</em> ordering using comparison functor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>False if wrapped to first permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range [__first,__last) as a set of <em>dictionary</em> sorted sequences ordered by <code>__comp</code>. Permutes the current sequence into the next one of this set. Returns true if there are more sequences to generate. If the sequence is the largest of the set, the smallest is generated and false returned. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l03736">3736</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01463_source.html#l00118">std::iter_swap()</a>, and <a class="el" href="a01462_source.html#l01468">std::reverse()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a4f2ca9c1c627576aeeaa99181c8c63"></a><!-- doxytag: member="std::nth_element" ref="ga3a4f2ca9c1c627576aeeaa99181c8c63" args="(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::nth_element </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__nth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort a sequence just enough to find a particular position. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__nth</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>Rearranges the elements in the range <code></code>[__first,__last) so that <code>*__nth</code> is the same element that would have been in that position had the whole sequence been sorted. The elements either side of <code>*__nth</code> are not completely sorted, but for any iterator <em>i</em> in the range <code></code>[__first,__nth) and any iterator <em>j</em> in the range <code></code>[__nth,__last) it holds that *j &lt; *i is false. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05386">5386</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01463_source.html#l00973">std::__lg()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6d43f0d62204409f18762c8e1bf1867b"></a><!-- doxytag: member="std::nth_element" ref="ga6d43f0d62204409f18762c8e1bf1867b" args="(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::nth_element </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__nth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort a sequence just enough to find a particular position using a predicate for comparison. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__nth</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>Rearranges the elements in the range <code></code>[__first,__last) so that <code>*__nth</code> is the same element that would have been in that position had the whole sequence been sorted. The elements either side of <code>*__nth</code> are not completely sorted, but for any iterator <em>i</em> in the range <code></code>[__first,__nth) and any iterator <em>j</em> in the range <code></code>[__nth,__last) it holds that <code>__comp(*j,*i)</code> is false. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05425">5425</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01463_source.html#l00973">std::__lg()</a>.</p>

</div>
</div>
<a class="anchor" id="ga91f25d546637f075de3958a25928b687"></a><!-- doxytag: member="std::partial_sort" ref="ga91f25d546637f075de3958a25928b687" args="(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::partial_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort the smallest elements of a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>Sorts the smallest <code></code>(__middle-__first) elements in the range <code></code>[first,last) and moves them to the range <code></code>[__first,__middle). The order of the remaining elements in the range <code></code>[__middle,__last) is undefined. After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__first,__middle) such that i precedes j and <em>k</em> is an iterator in the range <code></code>[__middle,__last) then *j&lt;*i and *k&lt;*i are both false. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05310">5310</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l01955">std::__heap_select()</a>, and <a class="el" href="a01468_source.html#l00489">std::sort_heap()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6401ff7e25d2ef7a6119d894cb40eec0"></a><!-- doxytag: member="std::partial_sort" ref="ga6401ff7e25d2ef7a6119d894cb40eec0" args="(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::partial_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort the smallest elements of a sequence using a predicate for comparison. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>Sorts the smallest <code></code>(__middle-__first) elements in the range <code></code>[__first,__last) and moves them to the range <code></code>[__first,__middle). The order of the remaining elements in the range <code></code>[__middle,__last) is undefined. After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__first,__middle) such that i precedes j and <em>k</em> is an iterator in the range <code></code>[__middle,__last) then <code>*__comp</code>(j,*i) and <code>__comp(*k,*i)</code> are both false. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05349">5349</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l01955">std::__heap_select()</a>, and <a class="el" href="a01468_source.html#l00489">std::sort_heap()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7b262260421978833cc1b1c6b3969bb4"></a><!-- doxytag: member="std::partial_sort_copy" ref="ga7b262260421978833cc1b1c6b3969bb4" args="(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_RandomAccessIterator std::partial_sort_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__result_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__result_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy the smallest elements of a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__result_first</td><td>A random-access iterator. </td></tr>
    <tr><td class="paramname">__result_last</td><td>Another random-access iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator indicating the end of the resulting sequence.</dd></dl>
<p>Copies and sorts the smallest N values from the range <code></code>[__first,__last) to the range beginning at <code>__result_first</code>, where the number of elements to be copied, <code>N</code>, is the smaller of <code></code>(__last-__first) and <code></code>(__result_last-__result_first). After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__result_first,__result_first+N) such that i precedes j then *j&lt;*i is false. The value returned is <code>__result_first+N</code>. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l02000">2000</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01468_source.html#l00421">std::make_heap()</a>, and <a class="el" href="a01468_source.html#l00489">std::sort_heap()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf53e3f9d5e3c9cd4d36a0801d411e324"></a><!-- doxytag: member="std::partial_sort_copy" ref="gaf53e3f9d5e3c9cd4d36a0801d411e324" args="(_InputIterator __first, _InputIterator __last, _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _RandomAccessIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_RandomAccessIterator std::partial_sort_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__result_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__result_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy the smallest elements of a sequence using a predicate for comparison. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another input iterator. </td></tr>
    <tr><td class="paramname">__result_first</td><td>A random-access iterator. </td></tr>
    <tr><td class="paramname">__result_last</td><td>Another random-access iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator indicating the end of the resulting sequence.</dd></dl>
<p>Copies and sorts the smallest N values from the range <code></code>[__first,__last) to the range beginning at <code>result_first</code>, where the number of elements to be copied, <code>N</code>, is the smaller of <code></code>(__last-__first) and <code></code>(__result_last-__result_first). After the sort if <em>i</em> and <em>j</em> are iterators in the range <code></code>[__result_first,__result_first+N) such that i precedes j then <code>__comp(*j,*i)</code> is false. The value returned is <code>__result_first+N</code>. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l02066">2066</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01468_source.html#l00421">std::make_heap()</a>, and <a class="el" href="a01468_source.html#l00489">std::sort_heap()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b0e35a43f5f87ea1c66363be3a34619"></a><!-- doxytag: member="std::prev_permutation" ref="ga0b0e35a43f5f87ea1c66363be3a34619" args="(_BidirectionalIterator __first, _BidirectionalIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::prev_permutation </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permute range into the previous <em>dictionary</em> ordering. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>False if wrapped to last permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range as a set of <em>dictionary</em> sorted sequences. Permutes the current sequence into the previous one of this set. Returns true if there are more sequences to generate. If the sequence is the smallest of the set, the largest is generated and false returned. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l03792">3792</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01463_source.html#l00118">std::iter_swap()</a>, and <a class="el" href="a01462_source.html#l01468">std::reverse()</a>.</p>

</div>
</div>
<a class="anchor" id="ga44e9b1d39001f68fa9fcb408b25a77f0"></a><!-- doxytag: member="std::prev_permutation" ref="ga44e9b1d39001f68fa9fcb408b25a77f0" args="(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::prev_permutation </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permute range into the previous <em>dictionary</em> ordering using comparison functor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Start of range. </td></tr>
    <tr><td class="paramname">__last</td><td>End of range. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>False if wrapped to last permutation, true otherwise.</dd></dl>
<p>Treats all permutations of the range [__first,__last) as a set of <em>dictionary</em> sorted sequences ordered by <code>__comp</code>. Permutes the current sequence into the previous one of this set. Returns true if there are more sequences to generate. If the sequence is the smallest of the set, the largest is generated and false returned. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l03849">3849</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01463_source.html#l00118">std::iter_swap()</a>, and <a class="el" href="a01462_source.html#l01468">std::reverse()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ea03048647c50ea7cbdd5da30e82755"></a><!-- doxytag: member="std::sort" ref="ga4ea03048647c50ea7cbdd5da30e82755" args="(_RandomAccessIterator __first, _RandomAccessIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort the elements of a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that for each iterator <em>i</em> in the range <code></code>[__first,__last-1), *(i+1)&lt;*i is false.</p>
<p>The relative ordering of equivalent elements is not preserved, use <code>stable_sort()</code> if this is needed. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05463">5463</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l02232">std::__final_insertion_sort()</a>, <a class="el" href="a01462_source.html#l02327">std::__introsort_loop()</a>, and <a class="el" href="a01463_source.html#l00973">std::__lg()</a>.</p>

</div>
</div>
<a class="anchor" id="gae3c0067ae83db1824367ded659a960b2"></a><!-- doxytag: member="std::sort" ref="gae3c0067ae83db1824367ded659a960b2" args="(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort the elements of a sequence using a predicate for comparison. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that <code>__comp</code>(*(i+1),*i) is false for every iterator <em>i</em> in the range <code></code>[__first,__last-1).</p>
<p>The relative ordering of equivalent elements is not preserved, use <code>stable_sort()</code> if this is needed. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05499">5499</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l02232">std::__final_insertion_sort()</a>, <a class="el" href="a01462_source.html#l02327">std::__introsort_loop()</a>, and <a class="el" href="a01463_source.html#l00973">std::__lg()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7d8bb8e52b7b0e80301dcbec17225b4a"></a><!-- doxytag: member="std::stable_sort" ref="ga7d8bb8e52b7b0e80301dcbec17225b4a" args="(_RandomAccessIterator __first, _RandomAccessIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::stable_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort the elements of a sequence, preserving the relative order of equivalent elements. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that for each iterator <code>i</code> in the range <code></code>[__first,__last-1), <code>*</code>(i+1)&lt;*i is false.</p>
<p>The relative ordering of equivalent elements is preserved, so any two elements <code>x</code> and <code>y</code> in the range <code></code>[__first,__last) such that <code>x&lt;y</code> is false and <code>y&lt;x</code> is false will have the same relative ordering after calling <code>stable_sort()</code>. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05665">5665</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l03511">std::__inplace_stable_sort()</a>, <a class="el" href="a01483_source.html#l00153">std::_Temporary_buffer&lt; _ForwardIterator, _Tp &gt;::begin()</a>, and <a class="el" href="a01483_source.html#l00143">std::_Temporary_buffer&lt; _ForwardIterator, _Tp &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a3ce3aa8ac2297f8290939a7988596d"></a><!-- doxytag: member="std::stable_sort" ref="ga3a3ce3aa8ac2297f8290939a7988596d" args="(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator , typename _Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::stable_sort </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Compare&#160;</td>
          <td class="paramname"><em>__comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sort the elements of a sequence using a predicate for comparison, preserving the relative order of equivalent elements. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>Sorts the elements in the range <code></code>[__first,__last) in ascending order, such that for each iterator <code>i</code> in the range <code></code>[__first,__last-1), <code>__comp</code>(*(i+1),*i) is false.</p>
<p>The relative ordering of equivalent elements is preserved, so any two elements <code>x</code> and <code>y</code> in the range <code></code>[__first,__last) such that <code>__comp(x,y)</code> is false and <code>__comp(y,x)</code> is false will have the same relative ordering after calling <code>stable_sort()</code>. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05707">5707</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l03511">std::__inplace_stable_sort()</a>, <a class="el" href="a01483_source.html#l00153">std::_Temporary_buffer&lt; _ForwardIterator, _Tp &gt;::begin()</a>, and <a class="el" href="a01483_source.html#l00143">std::_Temporary_buffer&lt; _ForwardIterator, _Tp &gt;::size()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
