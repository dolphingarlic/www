<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libstdc++: std::set&lt; _Key, _Compare, _Alloc &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a00449.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">std::set&lt; _Key, _Compare, _Alloc &gt; Class Template Reference<div class="ingroups"><a class="el" href="a01598.html">Associative</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="std::set" --><div class="dynheader">
Inheritance diagram for std::set&lt; _Key, _Compare, _Alloc &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="a03137.png" border="0" usemap="#std_1_1set_3_01___key_00_01___compare_00_01___alloc_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="std_1_1set_3_01___key_00_01___compare_00_01___alloc_01_4_inherit__map" id="std_1_1set_3_01___key_00_01___compare_00_01___alloc_01_4_inherit__map">
<area shape="rect" id="node3" href="a00449.html" title="std::set\&lt; _StateIdT \&gt;" alt="" coords="47,99,201,127"/></map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><a href="a03138.html">List of all members.</a></p>
<h2><a name="pub-types"></a>
Public Types</h2>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<ul>
<li>typedef _Key <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a>
<li>typedef _Key <a class="el" href="a00449.html#a3e752147bbbb2d617e85d6a9f15cd57b">value_type</a>
<li>typedef _Compare <a class="el" href="a00449.html#a7ef2f84268354d05e7213606d2f364c9">key_compare</a>
<li>typedef _Compare <a class="el" href="a00449.html#a2d638b35695b151f99f992e5048cb58d">value_compare</a>
<li>typedef _Alloc <a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a>
</ul>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<ul>
<li>typedef _Key_alloc_type::pointer <a class="el" href="a00449.html#a5c75bebdcbe727e8fe85ede5351301e1">pointer</a>
<li>typedef <br class="typebreak"/>
_Key_alloc_type::const_pointer <a class="el" href="a00449.html#a178eef3559480df0b22e516a4f0ee812">const_pointer</a>
<li>typedef _Key_alloc_type::reference <a class="el" href="a00449.html#a4492a01e04b7e235eadec66eb4154874">reference</a>
<li>typedef <br class="typebreak"/>
_Key_alloc_type::const_reference <a class="el" href="a00449.html#a4fae7e0a321bd1c0e67603c9764bb890">const_reference</a>
<li>typedef _Rep_type::const_iterator <a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a>
<li>typedef _Rep_type::const_iterator <a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a>
<li>typedef <br class="typebreak"/>
<a class="el" href="a00887.html">_Rep_type::const_reverse_iterator</a> <a class="el" href="a00449.html#ab7b54ee87cf04d32f163e87e1bd0b5c5">reverse_iterator</a>
<li>typedef <br class="typebreak"/>
<a class="el" href="a00887.html">_Rep_type::const_reverse_iterator</a> <a class="el" href="a00449.html#ab28676718c0dc84a292b8998fa943c83">const_reverse_iterator</a>
<li>typedef _Rep_type::size_type <a class="el" href="a00449.html#ad9837325cd001566e32eb95539a8ded5">size_type</a>
<li>typedef _Rep_type::difference_type <a class="el" href="a00449.html#a1209ccfa7ee8ec775e03282e07a4d3ab">difference_type</a>
</ul>
<h2><a name="pub-methods"></a>
Public Member Functions</h2>
<ul>
<li><a class="el" href="a00449.html#ae9620ab923754bc313da0a8cc76a5cde">set</a> ()
<li><a class="el" href="a00449.html#aed34d26628e845f2b7e0eb45959ef0fc">set</a> (const _Compare &amp;__comp, const <a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a> &amp;__a=<a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a>())
<li>template&lt;typename _InputIterator &gt; <a class="el" href="a00449.html#a5c24e6efdb6526f5a28e7c54af8e3e15">set</a> (_InputIterator __first, _InputIterator __last)
<li>template&lt;typename _InputIterator &gt; <a class="el" href="a00449.html#a0b099bbbac6aef91b91c671c3e231979">set</a> (_InputIterator __first, _InputIterator __last, const _Compare &amp;__comp, const <a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a> &amp;__a=<a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a>())
<li><a class="el" href="a00449.html#a55ad8220eb27334c32663e81c84f4966">set</a> (const <a class="el" href="a00449.html">set</a> &amp;__x)
<li><a class="el" href="a00449.html#ac860e368e010286fbf6bb4bbfa642049">set</a> (<a class="el" href="a00449.html">set</a> &amp;&amp;__x) noexcept(<a class="el" href="a00752.html">is_nothrow_copy_constructible</a>&lt; _Compare &gt;
<li><a class="el" href="a00449.html#acdf4b44f5a2f222c735237d763b89eaa">set</a> (<a class="el" href="a00708.html">initializer_list</a>&lt; <a class="el" href="a00449.html#a3e752147bbbb2d617e85d6a9f15cd57b">value_type</a> &gt; __l, const _Compare &amp;__comp=_Compare(), const <a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a> &amp;__a=<a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a>())
<li><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html#a2845ad2b648b419edba995575a1c7979">begin</a> () const _GLIBCXX_NOEXCEPT
<li><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html#a39e7d303fb234db62a1faa6df63f4604">cbegin</a> () const noexcept
<li><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html#a5d2030f67826e8bfea0b6dce51e792b7">cend</a> () const noexcept
<li>void <a class="el" href="a00449.html#aa5ba8ae06431f696a32bb401c8316392">clear</a> () _GLIBCXX_NOEXCEPT
<li><a class="el" href="a00449.html#ad9837325cd001566e32eb95539a8ded5">size_type</a> <a class="el" href="a00449.html#a967644cc24e90c66aa71162952905878">count</a> (const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;__x) const 
<li><a class="el" href="a00449.html#ab7b54ee87cf04d32f163e87e1bd0b5c5">reverse_iterator</a> <a class="el" href="a00449.html#aa748ce25c53c595cbb332058bf1841d3">crbegin</a> () const noexcept
<li><a class="el" href="a00449.html#ab7b54ee87cf04d32f163e87e1bd0b5c5">reverse_iterator</a> <a class="el" href="a00449.html#abb253be090c388adfba1f54046c0f416">crend</a> () const noexcept
<li>bool <a class="el" href="a00449.html#ac6ba6ea1418242a1017238ecbfd1e376">empty</a> () const _GLIBCXX_NOEXCEPT
<li><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html#a289af40cd3219bd03b1c2520187dab25">end</a> () const _GLIBCXX_NOEXCEPT
<li><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html#a49008cc93d9740e5d3253863cbb61d54">erase</a> (<a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a> __position)
<li><a class="el" href="a00449.html#ad9837325cd001566e32eb95539a8ded5">size_type</a> <a class="el" href="a00449.html#af75595c05a003b09225a0367cbe4d468">erase</a> (const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;__x)
<li><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html#a0d27b1ac6f5325db17081c540755accf">erase</a> (<a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a> __first, <a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a> __last)
<li><a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a> <a class="el" href="a00449.html#a2f527216302c22a32ec656b205107020">get_allocator</a> () const _GLIBCXX_NOEXCEPT
<li><a class="el" href="a00444.html">std::pair</a>&lt; <a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a>, bool &gt; <a class="el" href="a00449.html#af168dfb4d8e0515557884b2619117c78">insert</a> (const <a class="el" href="a00449.html#a3e752147bbbb2d617e85d6a9f15cd57b">value_type</a> &amp;__x)
<li><a class="anchor" id="ac95c6255bf14fcd54bc1a6c2a97c2aea"></a><!-- doxytag: member="std::set::insert" ref="ac95c6255bf14fcd54bc1a6c2a97c2aea" args="(value_type &amp;&amp;__x)" -->
<a class="el" href="a00444.html">std::pair</a>&lt; <a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a>, bool &gt; <b>insert</b> (<a class="el" href="a00449.html#a3e752147bbbb2d617e85d6a9f15cd57b">value_type</a> &amp;&amp;__x)
<li><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html#abe856758e09628d4ec26d1e77ceee152">insert</a> (<a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a> __position, const <a class="el" href="a00449.html#a3e752147bbbb2d617e85d6a9f15cd57b">value_type</a> &amp;__x)
<li><a class="anchor" id="a73375989cdd1e9578efd644c9d269816"></a><!-- doxytag: member="std::set::insert" ref="a73375989cdd1e9578efd644c9d269816" args="(const_iterator __position, value_type &amp;&amp;__x)" -->
<a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <b>insert</b> (<a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a> __position, <a class="el" href="a00449.html#a3e752147bbbb2d617e85d6a9f15cd57b">value_type</a> &amp;&amp;__x)
<li>template&lt;typename _InputIterator &gt; void <a class="el" href="a00449.html#aa383fd1111f8ced96c22eacf1e42c258">insert</a> (_InputIterator __first, _InputIterator __last)
<li>void <a class="el" href="a00449.html#a555b9e2cf15a4d3aac095883904743a8">insert</a> (<a class="el" href="a00708.html">initializer_list</a>&lt; <a class="el" href="a00449.html#a3e752147bbbb2d617e85d6a9f15cd57b">value_type</a> &gt; __l)
<li><a class="el" href="a00449.html#a7ef2f84268354d05e7213606d2f364c9">key_compare</a> <a class="el" href="a00449.html#aebd0348aa21584e7c9cd531ba19d336c">key_comp</a> () const 
<li><a class="el" href="a00449.html#ad9837325cd001566e32eb95539a8ded5">size_type</a> <a class="el" href="a00449.html#acfc72c594a3d623f979be673434ea9e6">max_size</a> () const _GLIBCXX_NOEXCEPT
<li><a class="el" href="a00449.html">set</a> &amp; <a class="el" href="a00449.html#af3f30ac5b858d8ee1959ec8852083073">operator=</a> (const <a class="el" href="a00449.html">set</a> &amp;__x)
<li><a class="el" href="a00449.html">set</a> &amp; <a class="el" href="a00449.html#a093f0784776a14f43c176787862000ae">operator=</a> (<a class="el" href="a00449.html">set</a> &amp;&amp;__x)
<li><a class="el" href="a00449.html">set</a> &amp; <a class="el" href="a00449.html#a8e269a4d9e589df1ef1bc6df659e7a96">operator=</a> (<a class="el" href="a00708.html">initializer_list</a>&lt; <a class="el" href="a00449.html#a3e752147bbbb2d617e85d6a9f15cd57b">value_type</a> &gt; __l)
<li><a class="el" href="a00449.html#ab7b54ee87cf04d32f163e87e1bd0b5c5">reverse_iterator</a> <a class="el" href="a00449.html#a3d434ebb7ecbe1d9eb6bf6b12e51c473">rbegin</a> () const _GLIBCXX_NOEXCEPT
<li><a class="el" href="a00449.html#ab7b54ee87cf04d32f163e87e1bd0b5c5">reverse_iterator</a> <a class="el" href="a00449.html#aa06efdcdc2f7724bf0b08791cccd4bff">rend</a> () const _GLIBCXX_NOEXCEPT
<li><a class="el" href="a00449.html#ad9837325cd001566e32eb95539a8ded5">size_type</a> <a class="el" href="a00449.html#ad110e6a86f6746027c3baa63458e3c32">size</a> () const _GLIBCXX_NOEXCEPT
<li>void <a class="el" href="a00449.html#a53b2780abb1a6f4d29368c9859cf3b5a">swap</a> (<a class="el" href="a00449.html">set</a> &amp;__x)
<li><a class="el" href="a00449.html#a2d638b35695b151f99f992e5048cb58d">value_compare</a> <a class="el" href="a00449.html#a8834d557a6121d489472da8dd9b01ae1">value_comp</a> () const 
</ul>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<ul>
<li><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html#af20eddb69820079242b06871210f9b06">find</a> (const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;__x)
<li><a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a> <a class="el" href="a00449.html#afba88755f3da582c1f81662702ea1dfd">find</a> (const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;__x) const 
</ul>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<ul>
<li><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html#ae0623408c438fcbe7426deb496d3fd36">lower_bound</a> (const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;__x)
<li><a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a> <a class="el" href="a00449.html#abed960c43909e26e781b8f04684692b2">lower_bound</a> (const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;__x) const 
</ul>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<ul>
<li><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html#ae03b8775010d8dc4709a4d34013964d7">upper_bound</a> (const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;__x)
<li><a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a> <a class="el" href="a00449.html#aead5df0feb273c1cdeba65dc105b2a0f">upper_bound</a> (const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;__x) const 
</ul>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<ul>
<li><a class="el" href="a00444.html">std::pair</a>&lt; <a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a>, <a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> &gt; <a class="el" href="a00449.html#af9f201350c153d3da65fe02191c0129f">equal_range</a> (const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;__x)
<li><a class="el" href="a00444.html">std::pair</a>&lt; <a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a>, <br class="typebreak"/>
<a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a> &gt; <a class="el" href="a00449.html#a09816b4325300c9eab7f4d4f6559ba9d">equal_range</a> (const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;__x) const 
</ul>
<h2><a name="friends"></a>
Friends</h2>
<ul>
<li><a class="anchor" id="a81fc242f018cef3856ab94e602aee814"></a><!-- doxytag: member="std::set::operator&lt;" ref="a81fc242f018cef3856ab94e602aee814" args="(const set&lt; _K1, _C1, _A1 &gt; &amp;, const set&lt; _K1, _C1, _A1 &gt; &amp;)" -->
template&lt;typename _K1 , typename _C1 , typename _A1 &gt; bool <b>operator&lt;</b> (const <a class="el" href="a00449.html">set</a>&lt; _K1, _C1, _A1 &gt; &amp;, const <a class="el" href="a00449.html">set</a>&lt; _K1, _C1, _A1 &gt; &amp;)
<li><a class="anchor" id="a415a6ff4f3ee72a59094b0838386cbeb"></a><!-- doxytag: member="std::set::operator==" ref="a415a6ff4f3ee72a59094b0838386cbeb" args="(const set&lt; _K1, _C1, _A1 &gt; &amp;, const set&lt; _K1, _C1, _A1 &gt; &amp;)" -->
template&lt;typename _K1 , typename _C1 , typename _A1 &gt; bool <b>operator==</b> (const <a class="el" href="a00449.html">set</a>&lt; _K1, _C1, _A1 &gt; &amp;, const <a class="el" href="a00449.html">set</a>&lt; _K1, _C1, _A1 &gt; &amp;)
</ul>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt;<br/>
class std::set&lt; _Key, _Compare, _Alloc &gt;</h3>

<p>A standard container made up of unique keys, which can be retrieved in logarithmic time. </p>
<p>Meets the requirements of a <a href="tables.html#65">container</a>, a <a href="tables.html#66">reversible container</a>, and an <a href="tables.html#69">associative container</a> (using unique keys).</p>
<p>Sets support bidirectional iterators.</p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">_Key</td><td>Type of key objects. </td></tr>
    <tr><td class="paramname">_Compare</td><td>Comparison function object type, defaults to less&lt;Key&gt;. </td></tr>
    <tr><td class="paramname">_Alloc</td><td>Allocator type, defaults to allocator&lt;Key&gt;.</td></tr>
  </table>
  </dd>
</dl>
<p>The private tree data is declared exactly the same way for set and multiset; the distinction is made entirely in how the tree functions are called (*_unique versus *_equal, same as the standard). </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00091">91</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a3cfe51976315c0c1fbe62ac14c98e1f7"></a><!-- doxytag: member="std::set::allocator_type" ref="a3cfe51976315c0c1fbe62ac14c98e1f7" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Alloc <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Public typedefs. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00108">108</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d51d0ac851fe6c1b5d59e3b5aacfe57"></a><!-- doxytag: member="std::set::const_iterator" ref="a3d51d0ac851fe6c1b5d59e3b5aacfe57" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Rep_type::const_iterator <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator-related typedefs. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00129">129</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a178eef3559480df0b22e516a4f0ee812"></a><!-- doxytag: member="std::set::const_pointer" ref="a178eef3559480df0b22e516a4f0ee812" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Key_alloc_type::const_pointer <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a178eef3559480df0b22e516a4f0ee812">const_pointer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator-related typedefs. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00122">122</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4fae7e0a321bd1c0e67603c9764bb890"></a><!-- doxytag: member="std::set::const_reference" ref="a4fae7e0a321bd1c0e67603c9764bb890" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Key_alloc_type::const_reference <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a4fae7e0a321bd1c0e67603c9764bb890">const_reference</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator-related typedefs. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00124">124</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab28676718c0dc84a292b8998fa943c83"></a><!-- doxytag: member="std::set::const_reverse_iterator" ref="ab28676718c0dc84a292b8998fa943c83" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00887.html">_Rep_type::const_reverse_iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#ab28676718c0dc84a292b8998fa943c83">const_reverse_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator-related typedefs. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00131">131</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1209ccfa7ee8ec775e03282e07a4d3ab"></a><!-- doxytag: member="std::set::difference_type" ref="a1209ccfa7ee8ec775e03282e07a4d3ab" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Rep_type::difference_type <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a1209ccfa7ee8ec775e03282e07a4d3ab">difference_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator-related typedefs. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00133">133</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab67be28282428ca9d7bd2f77a5507c1a"></a><!-- doxytag: member="std::set::iterator" ref="ab67be28282428ca9d7bd2f77a5507c1a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Rep_type::const_iterator <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator-related typedefs. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00128">128</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7ef2f84268354d05e7213606d2f364c9"></a><!-- doxytag: member="std::set::key_compare" ref="a7ef2f84268354d05e7213606d2f364c9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Compare <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a7ef2f84268354d05e7213606d2f364c9">key_compare</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Public typedefs. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00106">106</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8629917347e6dc60f7b778017591ac89"></a><!-- doxytag: member="std::set::key_type" ref="a8629917347e6dc60f7b778017591ac89" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Key <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Public typedefs. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00104">104</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5c75bebdcbe727e8fe85ede5351301e1"></a><!-- doxytag: member="std::set::pointer" ref="a5c75bebdcbe727e8fe85ede5351301e1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Key_alloc_type::pointer <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a5c75bebdcbe727e8fe85ede5351301e1">pointer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator-related typedefs. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00121">121</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4492a01e04b7e235eadec66eb4154874"></a><!-- doxytag: member="std::set::reference" ref="a4492a01e04b7e235eadec66eb4154874" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Key_alloc_type::reference <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a4492a01e04b7e235eadec66eb4154874">reference</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator-related typedefs. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00123">123</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab7b54ee87cf04d32f163e87e1bd0b5c5"></a><!-- doxytag: member="std::set::reverse_iterator" ref="ab7b54ee87cf04d32f163e87e1bd0b5c5" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="a00887.html">_Rep_type::const_reverse_iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#ab7b54ee87cf04d32f163e87e1bd0b5c5">reverse_iterator</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator-related typedefs. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00130">130</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad9837325cd001566e32eb95539a8ded5"></a><!-- doxytag: member="std::set::size_type" ref="ad9837325cd001566e32eb95539a8ded5" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Rep_type::size_type <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#ad9837325cd001566e32eb95539a8ded5">size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Iterator-related typedefs. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00132">132</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2d638b35695b151f99f992e5048cb58d"></a><!-- doxytag: member="std::set::value_compare" ref="a2d638b35695b151f99f992e5048cb58d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Compare <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a2d638b35695b151f99f992e5048cb58d">value_compare</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Public typedefs. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00107">107</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3e752147bbbb2d617e85d6a9f15cd57b"></a><!-- doxytag: member="std::set::value_type" ref="a3e752147bbbb2d617e85d6a9f15cd57b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef _Key <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a3e752147bbbb2d617e85d6a9f15cd57b">value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Public typedefs. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00105">105</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae9620ab923754bc313da0a8cc76a5cde"></a><!-- doxytag: member="std::set::set" ref="ae9620ab923754bc313da0a8cc76a5cde" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html">set</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor creates no elements. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00140">140</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="aed34d26628e845f2b7e0eb45959ef0fc"></a><!-- doxytag: member="std::set::set" ref="aed34d26628e845f2b7e0eb45959ef0fc" args="(const _Compare &amp;__comp, const allocator_type &amp;__a=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html">set</a> </td>
          <td>(</td>
          <td class="paramtype">const _Compare &amp;&#160;</td>
          <td class="paramname"><em>__comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code><a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a set with no elements. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__comp</td><td>Comparator to use. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01481_source.html#l00149">149</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5c24e6efdb6526f5a28e7c54af8e3e15"></a><!-- doxytag: member="std::set::set" ref="a5c24e6efdb6526f5a28e7c54af8e3e15" args="(_InputIterator __first, _InputIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html">set</a> </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a set from a range. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a set consisting of copies of the elements from [__first,__last). This is linear in N if the range is already sorted, and NlogN otherwise (where N is distance(__first,__last)). </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00164">164</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0b099bbbac6aef91b91c671c3e231979"></a><!-- doxytag: member="std::set::set" ref="a0b099bbbac6aef91b91c671c3e231979" args="(_InputIterator __first, _InputIterator __last, const _Compare &amp;__comp, const allocator_type &amp;__a=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html">set</a> </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Compare &amp;&#160;</td>
          <td class="paramname"><em>__comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code><a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a set from a range. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a set consisting of copies of the elements from [__first,__last). This is linear in N if the range is already sorted, and NlogN otherwise (where N is distance(__first,__last)). </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00181">181</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a55ad8220eb27334c32663e81c84f4966"></a><!-- doxytag: member="std::set::set" ref="a55ad8220eb27334c32663e81c84f4966" args="(const set &amp;__x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html">set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00449.html">set</a>&lt; _Key, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set copy constructor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A set of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>The newly-created set uses a copy of the allocation object used by <em>__x</em>. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00194">194</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac860e368e010286fbf6bb4bbfa642049"></a><!-- doxytag: member="std::set::set" ref="ac860e368e010286fbf6bb4bbfa642049" args="(set &amp;&amp;__x) noexcept(is_nothrow_copy_constructible&lt; _Compare &gt;" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html">set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00449.html">set</a>&lt; _Key, _Compare, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set move constructor </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A set of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>The newly-created set contains the exact contents of <em>x</em>. The contents of <em>x</em> are a valid, but unspecified set. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00205">205</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="acdf4b44f5a2f222c735237d763b89eaa"></a><!-- doxytag: member="std::set::set" ref="acdf4b44f5a2f222c735237d763b89eaa" args="(initializer_list&lt; value_type &gt; __l, const _Compare &amp;__comp=_Compare(), const allocator_type &amp;__a=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html">set</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00708.html">initializer_list</a>&lt; <a class="el" href="a00449.html#a3e752147bbbb2d617e85d6a9f15cd57b">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Compare &amp;&#160;</td>
          <td class="paramname"><em>__comp</em> = <code>_Compare()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__a</em> = <code><a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Builds a set from an <a class="el" href="a00708.html" title="initializer_list">initializer_list</a>. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An <a class="el" href="a00708.html" title="initializer_list">initializer_list</a>. </td></tr>
    <tr><td class="paramname">__comp</td><td>A comparison functor. </td></tr>
    <tr><td class="paramname">__a</td><td>An allocator object.</td></tr>
  </table>
  </dd>
</dl>
<p>Create a set consisting of copies of the elements in the list. This is linear in N if the list is already sorted, and NlogN otherwise (where N is <em><a class="el" href="a01576.html#a07a6b1e7078b72c0ddd334fe26bd349f" title="Returns the total number of bits.">__l.size()</a></em>). </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00219">219</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2845ad2b648b419edba995575a1c7979"></a><!-- doxytag: member="std::set::begin" ref="a2845ad2b648b419edba995575a1c7979" args="() const _GLIBCXX_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a2845ad2b648b419edba995575a1c7979">begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the set. Iteration is done in ascending order according to the keys. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00299">299</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a39e7d303fb234db62a1faa6df63f4604"></a><!-- doxytag: member="std::set::cbegin" ref="a39e7d303fb234db62a1faa6df63f4604" args="() const noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a39e7d303fb234db62a1faa6df63f4604">cbegin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the first element in the set. Iteration is done in ascending order according to the keys. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00336">336</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5d2030f67826e8bfea0b6dce51e792b7"></a><!-- doxytag: member="std::set::cend" ref="a5d2030f67826e8bfea0b6dce51e792b7" args="() const noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a5d2030f67826e8bfea0b6dce51e792b7">cend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the set. Iteration is done in ascending order according to the keys. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00345">345</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa5ba8ae06431f696a32bb401c8316392"></a><!-- doxytag: member="std::set::clear" ref="aa5ba8ae06431f696a32bb401c8316392" args="() _GLIBCXX_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#aa5ba8ae06431f696a32bb401c8316392">clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erases all elements in a set. Note that this function only erases the elements, and that if the elements themselves are pointers, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00580">580</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

<p>Referenced by <a class="el" href="a01481_source.html#l00249">std::set&lt; _StateIdT &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="a967644cc24e90c66aa71162952905878"></a><!-- doxytag: member="std::set::count" ref="a967644cc24e90c66aa71162952905878" args="(const key_type &amp;__x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ad9837325cd001566e32eb95539a8ded5">size_type</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a967644cc24e90c66aa71162952905878">count</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the number of elements. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Element to located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of elements with specified key.</dd></dl>
<p>This function only makes sense for multisets; for set the result will either be 0 (not present) or 1 (present). </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00594">594</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa748ce25c53c595cbb332058bf1841d3"></a><!-- doxytag: member="std::set::crbegin" ref="aa748ce25c53c595cbb332058bf1841d3" args="() const noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ab7b54ee87cf04d32f163e87e1bd0b5c5">reverse_iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#aa748ce25c53c595cbb332058bf1841d3">crbegin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the last element in the set. Iteration is done in descending order according to the keys. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00354">354</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="abb253be090c388adfba1f54046c0f416"></a><!-- doxytag: member="std::set::crend" ref="abb253be090c388adfba1f54046c0f416" args="() const noexcept" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ab7b54ee87cf04d32f163e87e1bd0b5c5">reverse_iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#abb253be090c388adfba1f54046c0f416">crend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to the last pair in the set. Iteration is done in descending order according to the keys. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00363">363</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac6ba6ea1418242a1017238ecbfd1e376"></a><!-- doxytag: member="std::set::empty" ref="ac6ba6ea1418242a1017238ecbfd1e376" args="() const _GLIBCXX_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#ac6ba6ea1418242a1017238ecbfd1e376">empty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the set is empty. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00369">369</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a289af40cd3219bd03b1c2520187dab25"></a><!-- doxytag: member="std::set::end" ref="a289af40cd3219bd03b1c2520187dab25" args="() const _GLIBCXX_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a289af40cd3219bd03b1c2520187dab25">end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a read-only (constant) iterator that points one past the last element in the set. Iteration is done in ascending order according to the keys. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00308">308</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="af9f201350c153d3da65fe02191c0129f"></a><!-- doxytag: member="std::set::equal_range" ref="af9f201350c153d3da65fe02191c0129f" args="(const key_type &amp;__x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00444.html">std::pair</a>&lt;<a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a>, <a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a>&gt; <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#af9f201350c153d3da65fe02191c0129f">equal_range</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pair of iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function is equivalent to </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="a01576.html#a0409e288f07b697cb6885d1002df0bd6" title="A convenience wrapper for creating a pair from two objects.">std::make_pair</a>(c.lower_bound(val),
                   c.upper_bound(val))
</pre></div><p> (but is faster than making the calls separately).</p>
<p>This function probably only makes sense for multisets. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00674">674</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a09816b4325300c9eab7f4d4f6559ba9d"></a><!-- doxytag: member="std::set::equal_range" ref="a09816b4325300c9eab7f4d4f6559ba9d" args="(const key_type &amp;__x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00444.html">std::pair</a>&lt;<a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a>, <a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a>&gt; <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#af9f201350c153d3da65fe02191c0129f">equal_range</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds a subsequence matching given key. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pair of iterators that possibly points to the subsequence matching given key.</dd></dl>
<p>This function is equivalent to </p>
<div class="fragment"><pre class="fragment">    <a class="code" href="a01576.html#a0409e288f07b697cb6885d1002df0bd6" title="A convenience wrapper for creating a pair from two objects.">std::make_pair</a>(c.lower_bound(val),
                   c.upper_bound(val))
</pre></div><p> (but is faster than making the calls separately).</p>
<p>This function probably only makes sense for multisets. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00678">678</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a49008cc93d9740e5d3253863cbb61d54"></a><!-- doxytag: member="std::set::erase" ref="a49008cc93d9740e5d3253863cbb61d54" args="(const_iterator __position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a49008cc93d9740e5d3253863cbb61d54">erase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases an element from a set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>An iterator pointing to the element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator pointing to the element immediately following <em>__position</em> prior to the element being erased. If no such element exists, <a class="el" href="a00449.html#a289af40cd3219bd03b1c2520187dab25">end()</a> is returned.</dd></dl>
<p>This function erases an element, pointed to by the given iterator, from a set. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00502">502</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="af75595c05a003b09225a0367cbe4d468"></a><!-- doxytag: member="std::set::erase" ref="af75595c05a003b09225a0367cbe4d468" args="(const key_type &amp;__x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ad9837325cd001566e32eb95539a8ded5">size_type</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a49008cc93d9740e5d3253863cbb61d54">erase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases elements according to the provided key. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key of element to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of elements erased.</dd></dl>
<p>This function erases all the elements located by the given key from a set. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00532">532</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0d27b1ac6f5325db17081c540755accf"></a><!-- doxytag: member="std::set::erase" ref="a0d27b1ac6f5325db17081c540755accf" args="(const_iterator __first, const_iterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a49008cc93d9740e5d3253863cbb61d54">erase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases a [__first,__last) range of elements from a set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Iterator pointing to the start of the range to be erased.</td></tr>
    <tr><td class="paramname">__last</td><td>Iterator pointing to the end of the range to be erased. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The iterator <em>__last</em>.</dd></dl>
<p>This function erases a sequence of elements from a set. Note that this function only erases the element, and that if the element is itself a pointer, the pointed-to memory is not touched in any way. Managing the pointer is the user's responsibility. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00553">553</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="af20eddb69820079242b06871210f9b06"></a><!-- doxytag: member="std::set::find" ref="af20eddb69820079242b06871210f9b06" args="(const key_type &amp;__x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#af20eddb69820079242b06871210f9b06">find</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to locate an element in a set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Element to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Iterator pointing to sought-after element, or <a class="el" href="a00449.html#a289af40cd3219bd03b1c2520187dab25">end()</a> if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( <code><a class="el" href="a00449.html#a289af40cd3219bd03b1c2520187dab25">end()</a></code> ) iterator. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00612">612</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="afba88755f3da582c1f81662702ea1dfd"></a><!-- doxytag: member="std::set::find" ref="afba88755f3da582c1f81662702ea1dfd" args="(const key_type &amp;__x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#af20eddb69820079242b06871210f9b06">find</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tries to locate an element in a set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Element to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Iterator pointing to sought-after element, or <a class="el" href="a00449.html#a289af40cd3219bd03b1c2520187dab25">end()</a> if not found.</dd></dl>
<p>This function takes a key and tries to locate the element with which the key matches. If successful the function returns an iterator pointing to the sought after element. If unsuccessful it returns the past-the-end ( <code><a class="el" href="a00449.html#a289af40cd3219bd03b1c2520187dab25">end()</a></code> ) iterator. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00616">616</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2f527216302c22a32ec656b205107020"></a><!-- doxytag: member="std::set::get_allocator" ref="a2f527216302c22a32ec656b205107020" args="() const _GLIBCXX_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#a3cfe51976315c0c1fbe62ac14c98e1f7">allocator_type</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a2f527216302c22a32ec656b205107020">get_allocator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the allocator object with which the set was constructed. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00290">290</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="af168dfb4d8e0515557884b2619117c78"></a><!-- doxytag: member="std::set::insert" ref="af168dfb4d8e0515557884b2619117c78" args="(const value_type &amp;__x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00444.html">std::pair</a>&lt;<a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a>, bool&gt; <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#af168dfb4d8e0515557884b2619117c78">insert</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00449.html#a3e752147bbbb2d617e85d6a9f15cd57b">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to insert an element into the set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Element to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pair, of which the first element is an iterator that points to the possibly inserted element, and the second is a bool that is true if the element was actually inserted.</dd></dl>
<p>This function attempts to insert an element into the set. A set relies on unique keys and thus an element is only inserted if it is not already present in the set.</p>
<p>Insertion requires logarithmic time. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00412">412</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

<p>Referenced by <a class="el" href="a01481_source.html#l00270">std::set&lt; _StateIdT &gt;::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="abe856758e09628d4ec26d1e77ceee152"></a><!-- doxytag: member="std::set::insert" ref="abe856758e09628d4ec26d1e77ceee152" args="(const_iterator __position, const value_type &amp;__x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#af168dfb4d8e0515557884b2619117c78">insert</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a>&#160;</td>
          <td class="paramname"><em>__position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="a00449.html#a3e752147bbbb2d617e85d6a9f15cd57b">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to insert an element into the set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__position</td><td>An iterator that serves as a hint as to where the element should be inserted. </td></tr>
    <tr><td class="paramname">__x</td><td>Element to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator that points to the element with key of <em>__x</em> (may or may not be the element passed in).</dd></dl>
<p>This function is not concerned about whether the insertion took place, and thus does not return a boolean like the single-argument <a class="el" href="a00449.html#af168dfb4d8e0515557884b2619117c78" title="Attempts to insert an element into the set.">insert()</a> does. Note that the first parameter is only a hint and can potentially improve the performance of the insertion process. A bad hint would cause no gains in efficiency.</p>
<p>For more on <em>hinting</em>, see: <a href="http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html">http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt07ch17.html</a></p>
<p>Insertion requires logarithmic time (if the hint is not taken). </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00449">449</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa383fd1111f8ced96c22eacf1e42c258"></a><!-- doxytag: member="std::set::insert" ref="aa383fd1111f8ced96c22eacf1e42c258" args="(_InputIterator __first, _InputIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename _InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#af168dfb4d8e0515557884b2619117c78">insert</a> </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A template function that attempts to insert a range of elements. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>Iterator pointing to the start of the range to be inserted. </td></tr>
    <tr><td class="paramname">__last</td><td>Iterator pointing to the end of the range.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity similar to that of the range constructor. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00469">469</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a555b9e2cf15a4d3aac095883904743a8"></a><!-- doxytag: member="std::set::insert" ref="a555b9e2cf15a4d3aac095883904743a8" args="(initializer_list&lt; value_type &gt; __l)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#af168dfb4d8e0515557884b2619117c78">insert</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00708.html">initializer_list</a>&lt; <a class="el" href="a00449.html#a3e752147bbbb2d617e85d6a9f15cd57b">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Attempts to insert a list of elements into the set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>A std::initializer_list&lt;value_type&gt; of elements to be inserted.</td></tr>
  </table>
  </dd>
</dl>
<p>Complexity similar to that of the range constructor. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00481">481</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

<p>Referenced by <a class="el" href="a01481_source.html#l00481">std::set&lt; _StateIdT &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="aebd0348aa21584e7c9cd531ba19d336c"></a><!-- doxytag: member="std::set::key_comp" ref="aebd0348aa21584e7c9cd531ba19d336c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#a7ef2f84268354d05e7213606d2f364c9">key_compare</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#aebd0348aa21584e7c9cd531ba19d336c">key_comp</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the comparison object with which the set was constructed. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00282">282</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae0623408c438fcbe7426deb496d3fd36"></a><!-- doxytag: member="std::set::lower_bound" ref="ae0623408c438fcbe7426deb496d3fd36" args="(const key_type &amp;__x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#ae0623408c438fcbe7426deb496d3fd36">lower_bound</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the beginning of a subsequence matching given key. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Iterator pointing to first element equal to or greater than key, or <a class="el" href="a00449.html#a289af40cd3219bd03b1c2520187dab25">end()</a>.</dd></dl>
<p>This function returns the first element of a subsequence of elements that matches the given key. If unsuccessful it returns an iterator pointing to the first element that has a greater value than given key or <a class="el" href="a00449.html#a289af40cd3219bd03b1c2520187dab25">end()</a> if no such element exists. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00633">633</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="abed960c43909e26e781b8f04684692b2"></a><!-- doxytag: member="std::set::lower_bound" ref="abed960c43909e26e781b8f04684692b2" args="(const key_type &amp;__x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#ae0623408c438fcbe7426deb496d3fd36">lower_bound</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the beginning of a subsequence matching given key. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Iterator pointing to first element equal to or greater than key, or <a class="el" href="a00449.html#a289af40cd3219bd03b1c2520187dab25">end()</a>.</dd></dl>
<p>This function returns the first element of a subsequence of elements that matches the given key. If unsuccessful it returns an iterator pointing to the first element that has a greater value than given key or <a class="el" href="a00449.html#a289af40cd3219bd03b1c2520187dab25">end()</a> if no such element exists. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00637">637</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="acfc72c594a3d623f979be673434ea9e6"></a><!-- doxytag: member="std::set::max_size" ref="acfc72c594a3d623f979be673434ea9e6" args="() const _GLIBCXX_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ad9837325cd001566e32eb95539a8ded5">size_type</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#acfc72c594a3d623f979be673434ea9e6">max_size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the maximum size of the set. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00379">379</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="af3f30ac5b858d8ee1959ec8852083073"></a><!-- doxytag: member="std::set::operator=" ref="af3f30ac5b858d8ee1959ec8852083073" args="(const set &amp;__x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html">set</a>&amp; <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00449.html">set</a>&lt; _Key, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set assignment operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A set of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>All the elements of <em>__x</em> are copied, but unlike the copy constructor, the allocator object is not copied. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00234">234</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a093f0784776a14f43c176787862000ae"></a><!-- doxytag: member="std::set::operator=" ref="a093f0784776a14f43c176787862000ae" args="(set &amp;&amp;__x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html">set</a>&amp; <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00449.html">set</a>&lt; _Key, _Compare, _Alloc &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set move assignment operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A set of identical element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>The contents of <em>__x</em> are moved into this set (without copying). <em>__x</em> is a valid, but unspecified set. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00249">249</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8e269a4d9e589df1ef1bc6df659e7a96"></a><!-- doxytag: member="std::set::operator=" ref="a8e269a4d9e589df1ef1bc6df659e7a96" args="(initializer_list&lt; value_type &gt; __l)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html">set</a>&amp; <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00708.html">initializer_list</a>&lt; <a class="el" href="a00449.html#a3e752147bbbb2d617e85d6a9f15cd57b">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>__l</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set list assignment operator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__l</td><td>An <a class="el" href="a00708.html" title="initializer_list">initializer_list</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function fills a set with copies of the elements in the initializer list <em>__l</em>.</p>
<p>Note that the assignment completely changes the set and that the resulting set's size is the same as the number of elements assigned. Old data may be lost. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00270">270</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3d434ebb7ecbe1d9eb6bf6b12e51c473"></a><!-- doxytag: member="std::set::rbegin" ref="a3d434ebb7ecbe1d9eb6bf6b12e51c473" args="() const _GLIBCXX_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ab7b54ee87cf04d32f163e87e1bd0b5c5">reverse_iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a3d434ebb7ecbe1d9eb6bf6b12e51c473">rbegin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a read-only (constant) iterator that points to the last element in the set. Iteration is done in descending order according to the keys. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00317">317</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="aa06efdcdc2f7724bf0b08791cccd4bff"></a><!-- doxytag: member="std::set::rend" ref="aa06efdcdc2f7724bf0b08791cccd4bff" args="() const _GLIBCXX_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ab7b54ee87cf04d32f163e87e1bd0b5c5">reverse_iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#aa06efdcdc2f7724bf0b08791cccd4bff">rend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns a read-only (constant) reverse iterator that points to the last pair in the set. Iteration is done in descending order according to the keys. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00326">326</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad110e6a86f6746027c3baa63458e3c32"></a><!-- doxytag: member="std::set::size" ref="ad110e6a86f6746027c3baa63458e3c32" args="() const _GLIBCXX_NOEXCEPT" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ad9837325cd001566e32eb95539a8ded5">size_type</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#ad110e6a86f6746027c3baa63458e3c32">size</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of the set. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00374">374</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a53b2780abb1a6f4d29368c9859cf3b5a"></a><!-- doxytag: member="std::set::swap" ref="a53b2780abb1a6f4d29368c9859cf3b5a" args="(set &amp;__x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a53b2780abb1a6f4d29368c9859cf3b5a">swap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="a00449.html">set</a>&lt; _Key, _Compare, _Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps data with another set. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>A set of the same element and allocator types.</td></tr>
  </table>
  </dd>
</dl>
<p>This exchanges the elements between two sets in constant time. (It is only swapping a pointer, an integer, and an instance of the <code>Compare</code> type (which itself is often stateless and empty), so it should be quite fast.) Note that the global std::swap() function is specialized such that std::swap(s1,s2) will feed to this function. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00394">394</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

<p>Referenced by <a class="el" href="a01481_source.html#l00249">std::set&lt; _StateIdT &gt;::operator=()</a>, and <a class="el" href="a01481_source.html#l00756">std::swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ae03b8775010d8dc4709a4d34013964d7"></a><!-- doxytag: member="std::set::upper_bound" ref="ae03b8775010d8dc4709a4d34013964d7" args="(const key_type &amp;__x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#ab67be28282428ca9d7bd2f77a5507c1a">iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#ae03b8775010d8dc4709a4d34013964d7">upper_bound</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the end of a subsequence matching given key. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Iterator pointing to the first element greater than key, or <a class="el" href="a00449.html#a289af40cd3219bd03b1c2520187dab25">end()</a>. </dd></dl>

<p>Definition at line <a class="el" href="a01481_source.html#l00649">649</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="aead5df0feb273c1cdeba65dc105b2a0f"></a><!-- doxytag: member="std::set::upper_bound" ref="aead5df0feb273c1cdeba65dc105b2a0f" args="(const key_type &amp;__x) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#a3d51d0ac851fe6c1b5d59e3b5aacfe57">const_iterator</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#ae03b8775010d8dc4709a4d34013964d7">upper_bound</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="a00449.html#a8629917347e6dc60f7b778017591ac89">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>__x</em></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds the end of a subsequence matching given key. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__x</td><td>Key to be located. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Iterator pointing to the first element greater than key, or <a class="el" href="a00449.html#a289af40cd3219bd03b1c2520187dab25">end()</a>. </dd></dl>

<p>Definition at line <a class="el" href="a01481_source.html#l00653">653</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<a class="anchor" id="a8834d557a6121d489472da8dd9b01ae1"></a><!-- doxytag: member="std::set::value_comp" ref="a8834d557a6121d489472da8dd9b01ae1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _Key, typename _Compare = std::less&lt;_Key&gt;, typename _Alloc = std::allocator&lt;_Key&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="a00449.html#a2d638b35695b151f99f992e5048cb58d">value_compare</a> <a class="el" href="a00449.html">std::set</a>&lt; _Key, _Compare, _Alloc &gt;::<a class="el" href="a00449.html#a8834d557a6121d489472da8dd9b01ae1">value_comp</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the comparison object with which the set was constructed. </p>

<p>Definition at line <a class="el" href="a01481_source.html#l00286">286</a> of file <a class="el" href="a01481_source.html">stl_set.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="a01481_source.html">stl_set.h</a></li>
</ul>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="a01576.html">std</a>      </li>
      <li class="navelem"><a class="el" href="a00449.html">set</a>      </li>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
