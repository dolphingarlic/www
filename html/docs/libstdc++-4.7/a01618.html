<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libstdc++: Mutating</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>


</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libstdc++
   
   </div>
   
  </td>
  
  
  
   
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('a01618.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Mutating</div>  </div>
<div class="ingroups"><a class="el" href="a01617.html">Algorithms</a></div></div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Mutating:</div>
<div class="dyncontent">
<center><table><tr><td><img src="a01618.png" border="0" alt="" usemap="#a01618"/>
<map name="a01618" id="a01618">
<area shape="rect" id="node2" href="a01617.html" title="Algorithms" alt="" coords="5,5,93,33"/></map>
</td></tr></table></center>
</div>
<h2><a name="func-members"></a>
Functions</h2>
<ul>
<li>template&lt;typename _II , typename _OI &gt; _OI <a class="el" href="a01618.html#ga894f503412130680dc19c87af289f4f4">std::copy</a> (_II __first, _II __last, _OI __result)
<li>template&lt;typename _BI1 , typename _BI2 &gt; _BI2 <a class="el" href="a01618.html#gaf0de0305e64a82131960e2769624a740">std::copy_backward</a> (_BI1 __first, _BI1 __last, _BI2 __result)
<li>template&lt;typename _InputIterator , typename _OutputIterator , typename _Predicate &gt; _OutputIterator <a class="el" href="a01618.html#ga0450d291c012c315181300fb83de8501">std::copy_if</a> (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
<li>template&lt;typename _InputIterator , typename _Size , typename _OutputIterator &gt; _OutputIterator <a class="el" href="a01618.html#ga6b6a2a5b1c55fb141030b8e6c8aad212">std::copy_n</a> (_InputIterator __first, _Size __n, _OutputIterator __result)
<li>template&lt;typename _ForwardIterator , typename _Tp &gt; void <a class="el" href="a01618.html#gab2e4bb5cc3300aaf6c0e5bdc3371bf06">std::fill</a> (_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__value)
<li>template&lt;typename _OI , typename _Size , typename _Tp &gt; _OI <a class="el" href="a01618.html#ga0af400b776b8486401daf6ecf91bacca">std::fill_n</a> (_OI __first, _Size __n, const _Tp &amp;__value)
<li>template&lt;typename _ForwardIterator , typename _Generator &gt; void <a class="el" href="a01618.html#ga691c5789ea06238032ea649bf4b81855">std::generate</a> (_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)
<li>template&lt;typename _OutputIterator , typename _Size , typename _Generator &gt; _OutputIterator <a class="el" href="a01618.html#gae428f053e61ca88f817152bd0f44c5fb">std::generate_n</a> (_OutputIterator __first, _Size __n, _Generator __gen)
<li>template&lt;typename _InputIterator , typename _Predicate &gt; bool <a class="el" href="a01618.html#gaba1a020bbd42810ce065fa9e239652d6">std::is_partitioned</a> (_InputIterator __first, _InputIterator __last, _Predicate __pred)
<li>template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; void <a class="el" href="a01618.html#gad93e66478d9a63e5777733be09931388">std::iter_swap</a> (_ForwardIterator1 __a, _ForwardIterator2 __b)
<li>template&lt;typename _II , typename _OI &gt; _OI <a class="el" href="a01618.html#gaedffc88b77674cbf9966e30a9c275bb6">std::move</a> (_II __first, _II __last, _OI __result)
<li>template&lt;typename _BI1 , typename _BI2 &gt; _BI2 <a class="el" href="a01618.html#ga1743475fe627f5302b98ae41f8bf0ad5">std::move_backward</a> (_BI1 __first, _BI1 __last, _BI2 __result)
<li>template&lt;typename _ForwardIterator , typename _Predicate &gt; _ForwardIterator <a class="el" href="a01618.html#ga64c8d89411856cea58194aa69a3c37f3">std::partition</a> (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
<li>template&lt;typename _InputIterator , typename _OutputIterator1 , typename _OutputIterator2 , typename _Predicate &gt; pair&lt; _OutputIterator1, <br class="typebreak"/>
_OutputIterator2 &gt; <a class="el" href="a01618.html#ga15ed8c195c2228b62770f24b4fd9de05">std::partition_copy</a> (_InputIterator __first, _InputIterator __last, _OutputIterator1 __out_true, _OutputIterator2 __out_false, _Predicate __pred)
<li>template&lt;typename _ForwardIterator , typename _Predicate &gt; _ForwardIterator <a class="el" href="a01618.html#gaca57a24221766660c3b9d83e2b3f8f97">std::partition_point</a> (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
<li>template&lt;typename _RandomAccessIterator &gt; void <a class="el" href="a01618.html#ga695aabc23dc8890aab28a155a13e9fa5">std::random_shuffle</a> (_RandomAccessIterator __first, _RandomAccessIterator __last)
<li>template&lt;typename _RandomAccessIterator , typename _RandomNumberGenerator &gt; void <a class="el" href="a01618.html#gabf4e555bd94a923ad7d263703b4ab2bc">std::random_shuffle</a> (_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomNumberGenerator &amp;&amp;__rand)
<li>template&lt;typename _ForwardIterator , typename _Tp &gt; _ForwardIterator <a class="el" href="a01618.html#ga166f118ed07d6a2dd58c9bbdd7c0f5b5">std::remove</a> (_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__value)
<li>template&lt;typename _InputIterator , typename _OutputIterator , typename _Tp &gt; _OutputIterator <a class="el" href="a01618.html#ga6118d2d397ae6ad3b11604c6eb843a31">std::remove_copy</a> (_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &amp;__value)
<li>template&lt;typename _InputIterator , typename _OutputIterator , typename _Predicate &gt; _OutputIterator <a class="el" href="a01618.html#ga80d825ff82bc980758c885296cec1fb1">std::remove_copy_if</a> (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)
<li>template&lt;typename _ForwardIterator , typename _Predicate &gt; _ForwardIterator <a class="el" href="a01618.html#ga80cc02d9d8e0975b92933a90579b3678">std::remove_if</a> (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
<li>template&lt;typename _ForwardIterator , typename _Tp &gt; void <a class="el" href="a01618.html#ga77aa7f436223611f545f84715a30ffeb">std::replace</a> (_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__old_value, const _Tp &amp;__new_value)
<li>template&lt;typename _InputIterator , typename _OutputIterator , typename _Predicate , typename _Tp &gt; _OutputIterator <a class="el" href="a01618.html#gaf42cb56a0d7dfd9124bddc4194cb53a4">std::replace_copy_if</a> (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred, const _Tp &amp;__new_value)
<li>template&lt;typename _ForwardIterator , typename _Predicate , typename _Tp &gt; void <a class="el" href="a01618.html#ga0afa1177a761d23ec3ec965207144455">std::replace_if</a> (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp &amp;__new_value)
<li>template&lt;typename _BidirectionalIterator &gt; void <a class="el" href="a01618.html#gaeee34a9f7380d22d29f0e895d1c014e0">std::reverse</a> (_BidirectionalIterator __first, _BidirectionalIterator __last)
<li>template&lt;typename _BidirectionalIterator , typename _OutputIterator &gt; _OutputIterator <a class="el" href="a01618.html#gaea264a482d59bc9c99edca7595f025eb">std::reverse_copy</a> (_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)
<li>template&lt;typename _ForwardIterator &gt; void <a class="el" href="a01618.html#ga45552c38c0376d2efdd6c295047fcbb8">std::rotate</a> (_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)
<li>template&lt;typename _ForwardIterator , typename _OutputIterator &gt; _OutputIterator <a class="el" href="a01618.html#gaf2a738ab86e393c9c8689708fd9afbf0">std::rotate_copy</a> (_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)
<li>template&lt;typename _RandomAccessIterator , typename _UniformRandomNumberGenerator &gt; void <a class="el" href="a01618.html#ga9c197f83f8612241f91e0a44703fdeaf">std::shuffle</a> (_RandomAccessIterator __first, _RandomAccessIterator __last, _UniformRandomNumberGenerator &amp;&amp;__g)
<li>template&lt;typename _ForwardIterator , typename _Predicate &gt; _ForwardIterator <a class="el" href="a01618.html#ga4396b91f26c7aaf0ae150a79ebd965b7">std::stable_partition</a> (_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)
<li>template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; _ForwardIterator2 <a class="el" href="a01618.html#gae9603907c05659cb5cfc6ea20be9ae01">std::swap_ranges</a> (_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)
<li>template&lt;typename _InputIterator , typename _OutputIterator , typename _UnaryOperation &gt; _OutputIterator <a class="el" href="a01618.html#ga475f12632a75f77b41aa843dfddfe422">std::transform</a> (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __unary_op)
<li>template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _BinaryOperation &gt; _OutputIterator <a class="el" href="a01618.html#ga92e41473c3907d39cbc98ab6bea346fe">std::transform</a> (_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _OutputIterator __result, _BinaryOperation __binary_op)
<li>template&lt;typename _ForwardIterator &gt; _ForwardIterator <a class="el" href="a01618.html#ga84999f9a9f647b18e3ec9e9e9aaa81f4">std::unique</a> (_ForwardIterator __first, _ForwardIterator __last)
<li>template&lt;typename _ForwardIterator , typename _BinaryPredicate &gt; _ForwardIterator <a class="el" href="a01618.html#ga7db53d49590370140ef23f2c9bf7b225">std::unique</a> (_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)
<li>template&lt;typename _InputIterator , typename _OutputIterator &gt; _OutputIterator <a class="el" href="a01618.html#ga6e0563edcc7414a3f1ee52d1c3e9e1e0">std::unique_copy</a> (_InputIterator __first, _InputIterator __last, _OutputIterator __result)
<li>template&lt;typename _InputIterator , typename _OutputIterator , typename _BinaryPredicate &gt; _OutputIterator <a class="el" href="a01618.html#gae33ff01e114f7384a462a242a75dd311">std::unique_copy</a> (_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred)
</ul>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga894f503412130680dc19c87af289f4f4"></a><!-- doxytag: member="std::copy" ref="ga894f503412130680dc19c87af289f4f4" args="(_II __first, _II __last, _OI __result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _II , typename _OI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OI std::copy </td>
          <td>(</td>
          <td class="paramtype">_II&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OI&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the range [first,last) into result. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>result + (first - last)</dd></dl>
<p>This inline function will boil down to a call to <code>memmove</code> whenever possible. Failing that, if random access iterators are passed, then the loop count will be known (and therefore a candidate for compiler optimizations such as unrolling). Result may not be contained within [first,last); the copy_backward function should be used instead.</p>
<p>Note that the end of the output range is permitted to be contained within [first,last). </p>

<p>Definition at line <a class="el" href="a01463_source.html#l00444">444</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf0de0305e64a82131960e2769624a740"></a><!-- doxytag: member="std::copy_backward" ref="gaf0de0305e64a82131960e2769624a740" args="(_BI1 __first, _BI1 __last, _BI2 __result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BI1 , typename _BI2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_BI2 std::copy_backward </td>
          <td>(</td>
          <td class="paramtype">_BI1&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BI1&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BI2&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the range [first,last) into result. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>A bidirectional iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>result - (first - last)</dd></dl>
<p>The function has the same effect as copy, but starts at the end of the range and works its way to the start, returning the start of the result. This inline function will boil down to a call to <code>memmove</code> whenever possible. Failing that, if random access iterators are passed, then the loop count will be known (and therefore a candidate for compiler optimizations such as unrolling).</p>
<p>Result may not be in the range [first,last). Use copy instead. Note that the start of the output range may overlap [first,last). </p>

<p>Definition at line <a class="el" href="a01463_source.html#l00613">613</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0450d291c012c315181300fb83de8501"></a><!-- doxytag: member="std::copy_if" ref="ga0450d291c012c315181300fb83de8501" args="(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _OutputIterator , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::copy_if </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy the elements of a sequence for which a predicate is true. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) for which <code>__pred</code> returns true to the range beginning at <code>__result</code>.</p>
<p>copy_if() is stable, so the relative order of elements that are copied is unchanged. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l00976">976</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6b6a2a5b1c55fb141030b8e6c8aad212"></a><!-- doxytag: member="std::copy_n" ref="ga6b6a2a5b1c55fb141030b8e6c8aad212" args="(_InputIterator __first, _Size __n, _OutputIterator __result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Size , typename _OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::copy_n </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Size&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the range [first,first+n) into [result,result+n). </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__n</td><td>The number of elements to copy. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>result+n.</dd></dl>
<p>This inline function will boil down to a call to <code>memmove</code> whenever possible. Failing that, if random access iterators are passed, then the loop count will be known (and therefore a candidate for compiler optimizations such as unrolling). </p>

<p>Definition at line <a class="el" href="a01462_source.html#l01039">1039</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01471_source.html#l00202">std::__iterator_category()</a>.</p>

</div>
</div>
<a class="anchor" id="gab2e4bb5cc3300aaf6c0e5bdc3371bf06"></a><!-- doxytag: member="std::fill" ref="gab2e4bb5cc3300aaf6c0e5bdc3371bf06" args="(_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::fill </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills the range [first,last) with copies of value. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>A reference-to-const of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>This function fills a range with copies of the same value. For char types filling contiguous areas of memory, this becomes an inline call to <code>memset</code> or <code>wmemset</code>. </p>

<p>Definition at line <a class="el" href="a01463_source.html#l00715">715</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0af400b776b8486401daf6ecf91bacca"></a><!-- doxytag: member="std::fill_n" ref="ga0af400b776b8486401daf6ecf91bacca" args="(_OI __first, _Size __n, const _Tp &amp;__value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _OI , typename _Size , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OI std::fill_n </td>
          <td>(</td>
          <td class="paramtype">_OI&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Size&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Fills the range [first,first+n) with copies of value. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__n</td><td>The count of copies to perform. </td></tr>
    <tr><td class="paramname">__value</td><td>A reference-to-const of arbitrary type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The iterator at first+n.</dd></dl>
<p>This function fills a range with copies of the same value. For char types filling contiguous areas of memory, this becomes an inline call to <code>memset</code> or @ wmemset.</p>
<p>_GLIBCXX_RESOLVE_LIB_DEFECTS DR 865. More algorithms that throw away information </p>

<p>Definition at line <a class="el" href="a01463_source.html#l00775">775</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga691c5789ea06238032ea649bf4b81855"></a><!-- doxytag: member="std::generate" ref="ga691c5789ea06238032ea649bf4b81855" args="(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::generate </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Generator&#160;</td>
          <td class="paramname"><em>__gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign the result of a function object to each value in a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__gen</td><td>A function object taking no arguments and returning std::iterator_traits&lt;_ForwardIterator&gt;::value_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>generate() returns no value.</dd></dl>
<p>Performs the assignment <code>*i</code> = <code>__gen()</code> for each <code>i</code> in the range <code></code>[__first,__last). </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05073">5073</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gae428f053e61ca88f817152bd0f44c5fb"></a><!-- doxytag: member="std::generate_n" ref="gae428f053e61ca88f817152bd0f44c5fb" args="(_OutputIterator __first, _Size __n, _Generator __gen)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _OutputIterator , typename _Size , typename _Generator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::generate_n </td>
          <td>(</td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Size&#160;</td>
          <td class="paramname"><em>__n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Generator&#160;</td>
          <td class="paramname"><em>__gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign the result of a function object to each value in a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__n</td><td>The length of the sequence. </td></tr>
    <tr><td class="paramname">__gen</td><td>A function object taking no arguments and returning std::iterator_traits&lt;_ForwardIterator&gt;::value_type </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the sequence, <code>__first+__n</code> </dd></dl>
<p>Performs the assignment <code>*i</code> = <code>__gen()</code> for each <code>i</code> in the range <code></code>[__first,__first+__n).</p>
<p>_GLIBCXX_RESOLVE_LIB_DEFECTS DR 865. More algorithms that throw away information </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05104">5104</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaba1a020bbd42810ce065fa9e239652d6"></a><!-- doxytag: member="std::is_partitioned" ref="gaba1a020bbd42810ce065fa9e239652d6" args="(_InputIterator __first, _InputIterator __last, _Predicate __pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool std::is_partitioned </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether the sequence is partitioned. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the range <code></code>[__first,__last) is partioned by <code>__pred</code>, i.e. if all elements that satisfy <code>__pred</code> appear before those that do not. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l00828">828</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l00805">std::find_if_not()</a>, and <a class="el" href="a01462_source.html#l00772">std::none_of()</a>.</p>

</div>
</div>
<a class="anchor" id="gad93e66478d9a63e5777733be09931388"></a><!-- doxytag: member="std::iter_swap" ref="gad93e66478d9a63e5777733be09931388" args="(_ForwardIterator1 __a, _ForwardIterator2 __b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::iter_swap </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the contents of two iterators. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__a</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__b</td><td>Another iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>This function swaps the values pointed to by two iterators, not the iterators themselves. </p>

<p>Definition at line <a class="el" href="a01463_source.html#l00118">118</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

<p>Referenced by <a class="el" href="a01462_source.html#l03072">std::__merge_without_buffer()</a>, <a class="el" href="a01462_source.html#l00080">std::__move_median_first()</a>, <a class="el" href="a01462_source.html#l01754">std::__partition()</a>, <a class="el" href="a01462_source.html#l01420">std::__reverse()</a>, <a class="el" href="a01462_source.html#l01534">std::__rotate()</a>, <a class="el" href="a01462_source.html#l02263">std::__unguarded_partition()</a>, <a class="el" href="a01462_source.html#l03679">std::next_permutation()</a>, <a class="el" href="a01462_source.html#l03792">std::prev_permutation()</a>, <a class="el" href="a01462_source.html#l05212">std::random_shuffle()</a>, <a class="el" href="a01462_source.html#l04392">std::shuffle()</a>, and <a class="el" href="a01463_source.html#l00159">std::swap_ranges()</a>.</p>

</div>
</div>
<a class="anchor" id="gaedffc88b77674cbf9966e30a9c275bb6"></a><!-- doxytag: member="std::move" ref="gaedffc88b77674cbf9966e30a9c275bb6" args="(_II __first, _II __last, _OI __result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _II , typename _OI &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OI std::move </td>
          <td>(</td>
          <td class="paramtype">_II&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_II&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OI&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the range [first,last) into result. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>result + (first - last)</dd></dl>
<p>This inline function will boil down to a call to <code>memmove</code> whenever possible. Failing that, if random access iterators are passed, then the loop count will be known (and therefore a candidate for compiler optimizations such as unrolling). Result may not be contained within [first,last); the move_backward function should be used instead.</p>
<p>Note that the end of the output range is permitted to be contained within [first,last). </p>

<p>Definition at line <a class="el" href="a01463_source.html#l00477">477</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga1743475fe627f5302b98ae41f8bf0ad5"></a><!-- doxytag: member="std::move_backward" ref="ga1743475fe627f5302b98ae41f8bf0ad5" args="(_BI1 __first, _BI1 __last, _BI2 __result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BI1 , typename _BI2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_BI2 std::move_backward </td>
          <td>(</td>
          <td class="paramtype">_BI1&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BI1&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BI2&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Moves the range [first,last) into result. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>A bidirectional iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>result - (first - last)</dd></dl>
<p>The function has the same effect as move, but starts at the end of the range and works its way to the start, returning the start of the result. This inline function will boil down to a call to <code>memmove</code> whenever possible. Failing that, if random access iterators are passed, then the loop count will be known (and therefore a candidate for compiler optimizations such as unrolling).</p>
<p>Result may not be in the range (first,last]. Use move instead. Note that the start of the output range may overlap [first,last). </p>

<p>Definition at line <a class="el" href="a01463_source.html#l00649">649</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga64c8d89411856cea58194aa69a3c37f3"></a><!-- doxytag: member="std::partition" ref="ga64c8d89411856cea58194aa69a3c37f3" args="(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::partition </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move elements for which a predicate is true to the beginning of a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator <code>middle</code> such that <code>__pred(i)</code> is true for each iterator <code>i</code> in the range <code></code>[__first,middle) and false for each <code>i</code> in the range <code></code>[middle,__last).</dd></dl>
<p><code>__pred</code> must not modify its operand. <code>partition()</code> does not preserve the relative ordering of elements in each group, use <code>stable_partition()</code> if this is needed. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05276">5276</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01471_source.html#l00202">std::__iterator_category()</a>, and <a class="el" href="a01462_source.html#l01754">std::__partition()</a>.</p>

</div>
</div>
<a class="anchor" id="ga15ed8c195c2228b62770f24b4fd9de05"></a><!-- doxytag: member="std::partition_copy" ref="ga15ed8c195c2228b62770f24b4fd9de05" args="(_InputIterator __first, _InputIterator __last, _OutputIterator1 __out_true, _OutputIterator2 __out_false, _Predicate __pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _OutputIterator1 , typename _OutputIterator2 , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;_OutputIterator1, _OutputIterator2&gt; std::partition_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator1&#160;</td>
          <td class="paramname"><em>__out_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator2&#160;</td>
          <td class="paramname"><em>__out_false</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy the elements of a sequence to separate output sequences depending on the truth value of a predicate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__out_true</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__out_false</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pair designating the ends of the resulting sequences.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) for which <code>__pred</code> returns true to the range beginning at <code>out_true</code> and each element for which <code>__pred</code> returns false to <code>__out_false</code>. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l01068">1068</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaca57a24221766660c3b9d83e2b3f8f97"></a><!-- doxytag: member="std::partition_point" ref="gaca57a24221766660c3b9d83e2b3f8f97" args="(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::partition_point </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the partition point of a partitioned range. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>Another iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator <code>mid</code> such that <code>all_of(__first, mid, __pred)</code> and <code>none_of(mid, __last, __pred)</code> are both true. </dd></dl>

<p>Definition at line <a class="el" href="a01462_source.html#l00846">846</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01470_source.html#l00172">std::advance()</a>, and <a class="el" href="a01470_source.html#l00114">std::distance()</a>.</p>

</div>
</div>
<a class="anchor" id="ga695aabc23dc8890aab28a155a13e9fa5"></a><!-- doxytag: member="std::random_shuffle" ref="ga695aabc23dc8890aab28a155a13e9fa5" args="(_RandomAccessIterator __first, _RandomAccessIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::random_shuffle </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Randomly shuffle the elements of a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>Reorder the elements in the range <code></code>[__first,__last) using a random distribution, so that every possible ordering of the sequence is equally likely. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05212">5212</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01463_source.html#l00118">std::iter_swap()</a>.</p>

</div>
</div>
<a class="anchor" id="gabf4e555bd94a923ad7d263703b4ab2bc"></a><!-- doxytag: member="std::random_shuffle" ref="gabf4e555bd94a923ad7d263703b4ab2bc" args="(_RandomAccessIterator __first, _RandomAccessIterator __last, _RandomNumberGenerator &amp;&amp;__rand)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator , typename _RandomNumberGenerator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::random_shuffle </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomNumberGenerator &amp;&amp;&#160;</td>
          <td class="paramname"><em>__rand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shuffle the elements of a sequence using a random number generator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__rand</td><td>The RNG functor or function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>Reorders the elements in the range <code></code>[__first,__last) using <code>__rand</code> to provide a random distribution. Calling <code>__rand(N)</code> for a positive integer <code>N</code> should return a randomly chosen integer from the range [0,N). </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05240">5240</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01463_source.html#l00118">std::iter_swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ga166f118ed07d6a2dd58c9bbdd7c0f5b5"></a><!-- doxytag: member="std::remove" ref="ga166f118ed07d6a2dd58c9bbdd7c0f5b5" args="(_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::remove </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove elements from a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>All elements equal to <code>__value</code> are removed from the range <code></code>[__first,__last).</p>
<p>remove() is stable, so the relative order of elements that are not removed is unchanged.</p>
<p>Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l01117">1117</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6118d2d397ae6ad3b11604c6eb843a31"></a><!-- doxytag: member="std::remove_copy" ref="ga6118d2d397ae6ad3b11604c6eb843a31" args="(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp &amp;__value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _OutputIterator , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::remove_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a sequence, removing elements of a given value. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__value</td><td>The value to be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) not equal to <code>__value</code> to the range beginning at <code>__result</code>. remove_copy() is stable, so the relative order of elements that are copied is unchanged. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l00899">899</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga80d825ff82bc980758c885296cec1fb1"></a><!-- doxytag: member="std::remove_copy_if" ref="ga80d825ff82bc980758c885296cec1fb1" args="(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _OutputIterator , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::remove_copy_if </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a sequence, removing elements for which a predicate is true. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) for which <code>__pred</code> returns false to the range beginning at <code>__result</code>.</p>
<p>remove_copy_if() is stable, so the relative order of elements that are copied is unchanged. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l00937">937</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga80cc02d9d8e0975b92933a90579b3678"></a><!-- doxytag: member="std::remove_if" ref="ga80cc02d9d8e0975b92933a90579b3678" args="(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::remove_if </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove elements from a sequence using a predicate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>All elements for which <code>__pred</code> returns true are removed from the range <code></code>[__first,__last).</p>
<p>remove_if() is stable, so the relative order of elements that are not removed is unchanged.</p>
<p>Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l01160">1160</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga77aa7f436223611f545f84715a30ffeb"></a><!-- doxytag: member="std::replace" ref="ga77aa7f436223611f545f84715a30ffeb" args="(_ForwardIterator __first, _ForwardIterator __last, const _Tp &amp;__old_value, const _Tp &amp;__new_value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::replace </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__old_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replace each occurrence of one value in a sequence with another value. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__old_value</td><td>The value to be replaced. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>replace() returns no value.</dd></dl>
<p>For each iterator <code>i</code> in the range <code></code>[__first,__last) if <code>*i</code> == <code>__old_value</code> then the assignment <code>*i</code> = <code>__new_value</code> is performed. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05009">5009</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaf42cb56a0d7dfd9124bddc4194cb53a4"></a><!-- doxytag: member="std::replace_copy_if" ref="gaf42cb56a0d7dfd9124bddc4194cb53a4" args="(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred, const _Tp &amp;__new_value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _OutputIterator , typename _Predicate , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::replace_copy_if </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a sequence, replacing each value for which a predicate returns true with another value. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The end of the output sequence, <code>__result+</code>(__last-__first).</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) to the range <code></code>[__result,__result+(__last-__first)) replacing elements for which <code>__pred</code> returns true with <code>__new_value</code>. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l03947">3947</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga0afa1177a761d23ec3ec965207144455"></a><!-- doxytag: member="std::replace_if" ref="ga0afa1177a761d23ec3ec965207144455" args="(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp &amp;__new_value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Predicate , typename _Tp &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::replace_if </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const _Tp &amp;&#160;</td>
          <td class="paramname"><em>__new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replace each value in a sequence for which a predicate returns true with another value. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate. </td></tr>
    <tr><td class="paramname">__new_value</td><td>The replacement value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>replace_if() returns no value.</dd></dl>
<p>For each iterator <code>i</code> in the range <code></code>[__first,__last) if <code>__pred(*i)</code> is true then the assignment <code>*i</code> = <code>__new_value</code> is performed. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05041">5041</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="gaeee34a9f7380d22d29f0e895d1c014e0"></a><!-- doxytag: member="std::reverse" ref="gaeee34a9f7380d22d29f0e895d1c014e0" args="(_BidirectionalIterator __first, _BidirectionalIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::reverse </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reverse a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A bidirectional iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>reverse() returns no value.</dd></dl>
<p>Reverses the order of the elements in the range <code></code>[__first,__last), so that the first element becomes the last etc. For every <code>i</code> such that <code>0&lt;=i&lt;=</code>(__last-__first)/2), <code>reverse()</code> swaps <code>*</code>(__first+i) and <code>*</code>(__last-(i+1)) </p>

<p>Definition at line <a class="el" href="a01462_source.html#l01468">1468</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01471_source.html#l00202">std::__iterator_category()</a>, and <a class="el" href="a01462_source.html#l01420">std::__reverse()</a>.</p>

<p>Referenced by <a class="el" href="a01462_source.html#l03679">std::next_permutation()</a>, and <a class="el" href="a01462_source.html#l03792">std::prev_permutation()</a>.</p>

</div>
</div>
<a class="anchor" id="gaea264a482d59bc9c99edca7595f025eb"></a><!-- doxytag: member="std::reverse_copy" ref="gaea264a482d59bc9c99edca7595f025eb" args="(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _BidirectionalIterator , typename _OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::reverse_copy </td>
          <td>(</td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BidirectionalIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a sequence, reversing its elements. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A bidirectional iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies the elements in the range <code></code>[__first,__last) to the range <code></code>[__result,__result+(__last-__first)) such that the order of the elements is reversed. For every <code>i</code> such that <code>0&lt;=i&lt;=</code>(__last-__first), <code>reverse_copy()</code> performs the assignment <code>*</code>(__result+(__last-__first)-i) = *(__first+i). The ranges <code></code>[__first,__last) and <code></code>[__result,__result+(__last-__first)) must not overlap. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l01495">1495</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga45552c38c0376d2efdd6c295047fcbb8"></a><!-- doxytag: member="std::rotate" ref="ga45552c38c0376d2efdd6c295047fcbb8" args="(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::rotate </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotate the elements of a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>Rotates the elements of the range <code></code>[__first,__last) by <code></code>(__middle - __first) positions so that the element at <code>__middle</code> is moved to <code>__first</code>, the element at <code>__middle+1</code> is moved to <code>__first+1</code> and so on for each element in the range <code></code>[__first,__last).</p>
<p>This effectively swaps the ranges <code></code>[__first,__middle) and <code></code>[__middle,__last).</p>
<p>Performs <code>*</code>(__first+(n+(__last-__middle))%(__last-__first))=*(__first+n) for each <code>n</code> in the range <code></code>[0,__last-__first). </p>

<p>Definition at line <a class="el" href="a01462_source.html#l01701">1701</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l01534">std::__rotate()</a>.</p>

<p>Referenced by <a class="el" href="a01462_source.html#l01811">std::__inplace_stable_partition()</a>, <a class="el" href="a01462_source.html#l03072">std::__merge_without_buffer()</a>, <a class="el" href="a01462_source.html#l02917">std::__rotate_adaptive()</a>, and <a class="el" href="a01462_source.html#l01843">std::__stable_partition_adaptive()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf2a738ab86e393c9c8689708fd9afbf0"></a><!-- doxytag: member="std::rotate_copy" ref="gaf2a738ab86e393c9c8689708fd9afbf0" args="(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::rotate_copy </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a sequence, rotating its elements. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__middle</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies the elements of the range <code></code>[__first,__last) to the range beginning at </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>, rotating the copied elements by <code></code>(__middle-__first) positions so that the element at <code>__middle</code> is moved to <code>__result</code>, the element at <code>__middle+1</code> is moved to <code>__result+1</code> and so on for each element in the range <code></code>[__first,__last).</dd></dl>
<p>Performs <code>*</code>(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n) for each <code>n</code> in the range <code></code>[0,__last-__first). </p>

<p>Definition at line <a class="el" href="a01462_source.html#l01737">1737</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga9c197f83f8612241f91e0a44703fdeaf"></a><!-- doxytag: member="std::shuffle" ref="ga9c197f83f8612241f91e0a44703fdeaf" args="(_RandomAccessIterator __first, _RandomAccessIterator __last, _UniformRandomNumberGenerator &amp;&amp;__g)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _RandomAccessIterator , typename _UniformRandomNumberGenerator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void std::shuffle </td>
          <td>(</td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_RandomAccessIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_UniformRandomNumberGenerator &amp;&amp;&#160;</td>
          <td class="paramname"><em>__g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Shuffle the elements of a sequence using a uniform random number generator. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__g</td><td>A UniformRandomNumberGenerator (26.5.1.3). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Nothing.</dd></dl>
<p>Reorders the elements in the range <code></code>[__first,__last) using <code>__g</code> to provide random numbers. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l04392">4392</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01463_source.html#l00118">std::iter_swap()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4396b91f26c7aaf0ae150a79ebd965b7"></a><!-- doxytag: member="std::stable_partition" ref="ga4396b91f26c7aaf0ae150a79ebd965b7" args="(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::stable_partition </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_Predicate&#160;</td>
          <td class="paramname"><em>__pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move elements for which a predicate is true to the beginning of a sequence, preserving relative ordering. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__pred</td><td>A predicate functor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator <code>middle</code> such that <code>__pred(i)</code> is true for each iterator <code>i</code> in the range <code></code>[first,middle) and false for each <code>i</code> in the range <code></code>[middle,last).</dd></dl>
<p>Performs the same function as <code>partition()</code> with the additional guarantee that the relative ordering of elements in each group is preserved, so any two elements <code>x</code> and <code>y</code> in the range <code></code>[__first,__last) such that <code>__pred(x)==__pred(y)</code> will have the same relative ordering after calling <code>stable_partition()</code>. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l01916">1916</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01462_source.html#l00250">std::__find_if_not()</a>, <a class="el" href="a01462_source.html#l01811">std::__inplace_stable_partition()</a>, <a class="el" href="a01462_source.html#l01843">std::__stable_partition_adaptive()</a>, <a class="el" href="a01483_source.html#l00153">std::_Temporary_buffer&lt; _ForwardIterator, _Tp &gt;::begin()</a>, <a class="el" href="a01483_source.html#l00148">std::_Temporary_buffer&lt; _ForwardIterator, _Tp &gt;::requested_size()</a>, and <a class="el" href="a01483_source.html#l00143">std::_Temporary_buffer&lt; _ForwardIterator, _Tp &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="gae9603907c05659cb5cfc6ea20be9ae01"></a><!-- doxytag: member="std::swap_ranges" ref="gae9603907c05659cb5cfc6ea20be9ae01" args="(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator1 , typename _ForwardIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator2 std::swap_ranges </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap the elements of two sequences. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator equal to <code>first2+</code>(last1-first1).</dd></dl>
<p>Swaps each element in the range <code></code>[first1,last1) with the corresponding element in the range <code></code>[first2,(last1-first1)). The ranges must not overlap. </p>

<p>Definition at line <a class="el" href="a01463_source.html#l00159">159</a> of file <a class="el" href="a01463_source.html">stl_algobase.h</a>.</p>

<p>References <a class="el" href="a01463_source.html#l00118">std::iter_swap()</a>.</p>

<p>Referenced by <a class="el" href="a01462_source.html#l01600">std::__rotate()</a>.</p>

</div>
</div>
<a class="anchor" id="ga475f12632a75f77b41aa843dfddfe422"></a><!-- doxytag: member="std::transform" ref="ga475f12632a75f77b41aa843dfddfe422" args="(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __unary_op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _OutputIterator , typename _UnaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::transform </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_UnaryOperation&#160;</td>
          <td class="paramname"><em>__unary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform an operation on a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__unary_op</td><td>A unary operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An output iterator equal to <code>__result+</code>(__last-__first).</dd></dl>
<p>Applies the operator to each element in the input range and assigns the results to successive elements of the output sequence. Evaluates <code>*</code>(__result+N)=unary_op(*(__first+N)) for each <code>N</code> in the range <code></code>[0,__last-__first).</p>
<p><code>unary_op</code> must not alter its argument. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l04940">4940</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga92e41473c3907d39cbc98ab6bea346fe"></a><!-- doxytag: member="std::transform" ref="ga92e41473c3907d39cbc98ab6bea346fe" args="(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _OutputIterator __result, _BinaryOperation __binary_op)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator1 , typename _InputIterator2 , typename _OutputIterator , typename _BinaryOperation &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::transform </td>
          <td>(</td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator1&#160;</td>
          <td class="paramname"><em>__last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator2&#160;</td>
          <td class="paramname"><em>__first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryOperation&#160;</td>
          <td class="paramname"><em>__binary_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Perform an operation on corresponding elements of two sequences. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last1</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__first2</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__binary_op</td><td>A binary operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An output iterator equal to <code>result+</code>(last-first).</dd></dl>
<p>Applies the operator to the corresponding elements in the two input ranges and assigns the results to successive elements of the output sequence. Evaluates <code>*</code>(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each <code>N</code> in the range <code></code>[0,__last1-__first1).</p>
<p><code>binary_op</code> must not alter either of its arguments. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l04977">4977</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga84999f9a9f647b18e3ec9e9e9aaa81f4"></a><!-- doxytag: member="std::unique" ref="ga84999f9a9f647b18e3ec9e9e9aaa81f4" args="(_ForwardIterator __first, _ForwardIterator __last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::unique </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove consecutive duplicate values from a sequence. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Removes all but the first element from each group of consecutive values that compare equal. unique() is stable, so the relative order of elements that are not removed is unchanged. Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l01200">1200</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga7db53d49590370140ef23f2c9bf7b225"></a><!-- doxytag: member="std::unique" ref="ga7db53d49590370140ef23f2c9bf7b225" args="(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __binary_pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _ForwardIterator , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_ForwardIterator std::unique </td>
          <td>(</td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_ForwardIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove consecutive values from a sequence using a predicate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>A forward iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Removes all but the first element from each group of consecutive values for which <code>__binary_pred</code> returns true. unique() is stable, so the relative order of elements that are not removed is unchanged. Elements between the end of the resulting sequence and <code>__last</code> are still present, but their value is unspecified. </p>

<p>Definition at line <a class="el" href="a01462_source.html#l01240">1240</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

</div>
</div>
<a class="anchor" id="ga6e0563edcc7414a3f1ee52d1c3e9e1e0"></a><!-- doxytag: member="std::unique_copy" ref="ga6e0563edcc7414a3f1ee52d1c3e9e1e0" args="(_InputIterator __first, _InputIterator __last, _OutputIterator __result)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::unique_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a sequence, removing consecutive duplicate values. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) to the range beginning at <code>__result</code>, except that only the first element is copied from groups of consecutive elements that compare equal. unique_copy() is stable, so the relative order of elements that are copied is unchanged.</p>
<p>_GLIBCXX_RESOLVE_LIB_DEFECTS DR 241. Does unique_copy() require CopyConstructible and Assignable?</p>
<p>_GLIBCXX_RESOLVE_LIB_DEFECTS DR 538. 241 again: Does unique_copy() require CopyConstructible and Assignable? </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05141">5141</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01471_source.html#l00202">std::__iterator_category()</a>, and <a class="el" href="a01462_source.html#l01272">std::__unique_copy()</a>.</p>

</div>
</div>
<a class="anchor" id="gae33ff01e114f7384a462a242a75dd311"></a><!-- doxytag: member="std::unique_copy" ref="gae33ff01e114f7384a462a242a75dd311" args="(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __binary_pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename _InputIterator , typename _OutputIterator , typename _BinaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_OutputIterator std::unique_copy </td>
          <td>(</td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_InputIterator&#160;</td>
          <td class="paramname"><em>__last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_OutputIterator&#160;</td>
          <td class="paramname"><em>__result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">_BinaryPredicate&#160;</td>
          <td class="paramname"><em>__binary_pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy a sequence, removing consecutive values using a predicate. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">__first</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__last</td><td>An input iterator. </td></tr>
    <tr><td class="paramname">__result</td><td>An output iterator. </td></tr>
    <tr><td class="paramname">__binary_pred</td><td>A binary predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator designating the end of the resulting sequence.</dd></dl>
<p>Copies each element in the range <code></code>[__first,__last) to the range beginning at <code>__result</code>, except that only the first element is copied from groups of consecutive elements for which <code>__binary_pred</code> returns true. unique_copy() is stable, so the relative order of elements that are copied is unchanged.</p>
<p>_GLIBCXX_RESOLVE_LIB_DEFECTS DR 241. Does unique_copy() require CopyConstructible and Assignable? </p>

<p>Definition at line <a class="el" href="a01462_source.html#l05181">5181</a> of file <a class="el" href="a01462_source.html">stl_algo.h</a>.</p>

<p>References <a class="el" href="a01471_source.html#l00202">std::__iterator_category()</a>, and <a class="el" href="a01462_source.html#l01272">std::__unique_copy()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
